; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28106.4 

	TITLE	i:\projets\aes\aes\aes\c_encode_interactif.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z	; C_Encode_Interactif::Open_File
PUBLIC	?Current_Dir@C_Encode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ ; C_Encode_Interactif::Current_Dir
PUBLIC	??0C_Encode_Interactif@@QAE@XZ			; C_Encode_Interactif::C_Encode_Interactif
PUBLIC	?Go@C_Encode_Interactif@@QAE_NXZ		; C_Encode_Interactif::Go
PUBLIC	??1C_Encode_Interactif@@QAE@XZ			; C_Encode_Interactif::~C_Encode_Interactif
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1C_Encode_Interactif@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Go@C_Encode_Interactif@@QAE_NXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?Go@C_Encode_Interactif@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Go@C_Encode_Interactif@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Go@C_Encode_Interactif@@QAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Go@C_Encode_Interactif@@QAE_NXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Go@C_Encode_Interactif@@QAE_NXZ$4
	DD	02H
	DD	FLAT:__unwindfunclet$?Go@C_Encode_Interactif@@QAE_NXZ$6
	DD	03H
	DD	FLAT:__unwindfunclet$?Go@C_Encode_Interactif@@QAE_NXZ$8
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0C_Encode_Interactif@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0C_Encode_Interactif@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0C_Encode_Interactif@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0C_Encode_Interactif@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0C_Encode_Interactif@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0C_Encode_Interactif@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0C_Encode_Interactif@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0C_Encode_Interactif@@QAE@XZ$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Current_Dir@C_Encode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Current_Dir@C_Encode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ$0
__ehfuncinfo$?Current_Dir@C_Encode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Current_Dir@C_Encode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z$3
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
;	COMDAT ??1C_Encode_Interactif@@QAE@XZ
_TEXT	SEGMENT
$T12 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1C_Encode_Interactif@@QAE@XZ PROC			; C_Encode_Interactif::~C_Encode_Interactif, COMDAT
; _this$ = ecx

; 24   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1C_Encode_Interactif@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 25   : 	delete pt_encode;

	mov	ebx, DWORD PTR [esi+24]
	or	edi, -1
	test	ebx, ebx
	je	SHORT $LN12@C_Encode_I
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp

; 20   : 	delete pt_Erreur;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR $T12[ebp], eax
	test	eax, eax
	je	SHORT $LN20@C_Encode_I
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [eax]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, edi

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN32@C_Encode_I

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN32@C_Encode_I:
	push	4
	push	DWORD PTR $T12[ebp]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN20@C_Encode_I:

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [ebx+4]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, edi

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN41@C_Encode_I

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN41@C_Encode_I:
	push	20					; 00000014H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@C_Encode_I:
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 26   : 	delete pt_pass;

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN44@C_Encode_I
	push	1
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN44@C_Encode_I:

; 27   : 	delete pt_Erreur;

	mov	ebx, DWORD PTR [esi+32]
	test	ebx, ebx
	je	SHORT $LN47@C_Encode_I
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [ebx]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, edi

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN59@C_Encode_I

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN59@C_Encode_I:
	push	4
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN47@C_Encode_I:
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 28   : 	delete pt_fichier;

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN62@C_Encode_I
	push	1
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN62@C_Encode_I:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [esi+20]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, edi

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN71@C_Encode_I

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN71@C_Encode_I:

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [esi+16]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, edi

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN80@C_Encode_I

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN80@C_Encode_I:

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [esi+12]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, edi

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN89@C_Encode_I

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN89@C_Encode_I:

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [esi+8]
	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], edi
	dec	edi
	test	edi, edi
	jg	SHORT $LN98@C_Encode_I

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN98@C_Encode_I:
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 29   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1C_Encode_Interactif@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1C_Encode_Interactif@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1C_Encode_Interactif@@QAE@XZ ENDP			; C_Encode_Interactif::~C_Encode_Interactif
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxcoll.inl
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
;	COMDAT ?Go@C_Encode_Interactif@@QAE_NXZ
_TEXT	SEGMENT
_this$1$ = -64						; size = 4
tv1390 = -64						; size = 4
_this$GSCopy$1$ = -60					; size = 4
tv1397 = -56						; size = 4
_this$ = -56						; size = 4
$T14 = -56						; size = 4
$T10 = -52						; size = 4
$T8 = -52						; size = 4
$T5 = -52						; size = 4
$T2 = -52						; size = 4
tv1396 = -48						; size = 4
_this$ = -48						; size = 4
_this$ = -48						; size = 4
_pNewData$1$ = -44					; size = 4
tv1400 = -44						; size = 4
tv1398 = -44						; size = 4
$T31 = -37						; size = 1
_timebuffer$32 = -36					; size = 16
_timebuffer$33 = -36					; size = 16
_Local$34 = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Go@C_Encode_Interactif@@QAE_NXZ PROC			; C_Encode_Interactif::Go, COMDAT
; _this$ = ecx

; 103  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Go@C_Encode_Interactif@@QAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], edi

; 105  : 	AjustFileName *pt_Ajust = new AjustFileName;

	push	1
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], ebx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ebx, ebx
	je	SHORT $LN6@Go
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxcoll.inl

; 286  : 	{ SetSize(0); }

	push	-1
	push	0
	mov	ecx, OFFSET ?List@@3VCStringArray@@A	; List
	call	?SetSize@CStringArray@@QAEXHH@Z		; CStringArray::SetSize
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 105  : 	AjustFileName *pt_Ajust = new AjustFileName;

	jmp	SHORT $LN7@Go
$LN6@Go:
	xor	ebx, ebx
$LN7@Go:

; 106  : 
; 107  : 	BOOL status = Mess.LoadString(IDS_STRING192);

	push	192					; 000000c0H
	lea	ecx, DWORD PTR [edi+20]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	eax, DWORD PTR [edi+20]

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [eax-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN35@Go

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [eax-12]
	lea	ecx, DWORD PTR [edi+20]
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	eax, DWORD PTR [edi+20]
$LN35@Go:
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 108  : 	if (Open_File(Mess.GetBuffer()) == true)

	push	eax
	mov	ecx, edi
	call	?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z ; C_Encode_Interactif::Open_File
	cmp	al, 1
	jne	$LN241@Go

; 109  : 	{
; 110  : 		    BOOL status = Mess.LoadString(IDS_STRING130);

	push	130					; 00000082H
	lea	ecx, DWORD PTR [edi+20]
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	eax, DWORD PTR [edi+20]
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 111  : 			CString Local = pt_fichier->Ajoute_Extension(pt_fichier->Supprime_Extension(pszSource), Mess);

	push	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	lea	esi, DWORD PTR [eax-16]
	mov	DWORD PTR _Local$34[ebp], 0

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	ecx, DWORD PTR [esi]

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	DWORD PTR tv1397[ebp], eax
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 111  : 			CString Local = pt_fichier->Ajoute_Extension(pt_fichier->Supprime_Extension(pszSource), Mess);

	mov	DWORD PTR $T5[ebp], esp
	mov	DWORD PTR _this$[ebp], esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+16]

; 69   : 		return nRefs < 0;

	cmp	DWORD PTR [esi+12], 0

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	edx, eax

; 69   : 		return nRefs < 0;

	lea	eax, DWORD PTR [esi+12]

; 883  : 		if( !pData->IsLocked() && (pNewStringMgr == pData->pStringMgr) )

	jl	SHORT $LN51@Go
	cmp	edx, DWORD PTR [esi]
	jne	SHORT $LN51@Go

; 65   : 		_InterlockedIncrement(&nRefs);

	lock	 inc	 DWORD PTR [eax]

; 887  : 		}

	jmp	SHORT $LN52@Go
$LN51@Go:

; 888  : 		else
; 889  : 		{
; 890  : 			pNewData = pNewStringMgr->Allocate( pData->nDataLength, sizeof( XCHAR ) );

	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [esi+4]
	push	2
	push	DWORD PTR [ecx]
	mov	DWORD PTR tv1390[ebp], ecx
	mov	ecx, edx
	call	DWORD PTR [eax]
	mov	esi, eax

; 891  : 			if( pNewData == NULL )

	test	esi, esi
	je	$LN250@Go

; 894  : 			}
; 895  : 			pNewData->nDataLength = pData->nDataLength;

	mov	ecx, DWORD PTR tv1390[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+4], eax

; 896  : 			CopyChars( PXSTR( pNewData->data() ), pData->nDataLength+1,

	mov	eax, DWORD PTR [ecx]
	inc	eax
	push	eax
	push	DWORD PTR tv1397[ebp]
	push	eax

; 59   : 		return (this+1);

	lea	eax, DWORD PTR [esi+16]

; 896  : 			CopyChars( PXSTR( pNewData->data() ), pData->nDataLength+1,

	push	eax
	call	?CopyChars@?$CSimpleStringT@_W$0A@@ATL@@SAXPA_WIPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::CopyChars
	add	esp, 16					; 00000010H
$LN52@Go:

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	ecx, DWORD PTR _this$[ebp]

; 59   : 		return (this+1);

	lea	eax, DWORD PTR [esi+16]

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [ecx], eax
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 111  : 			CString Local = pt_fichier->Ajoute_Extension(pt_fichier->Supprime_Extension(pszSource), Mess);

	push	ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	lea	eax, DWORD PTR [edi+12]
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 111  : 			CString Local = pt_fichier->Ajoute_Extension(pt_fichier->Supprime_Extension(pszSource), Mess);

	mov	DWORD PTR tv1400[ebp], esp
	push	ecx
	mov	DWORD PTR _this$[ebp], esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	DWORD PTR _this$1$[ebp], eax
	mov	eax, DWORD PTR [eax]

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	ecx, DWORD PTR [eax-16]

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	lea	esi, DWORD PTR [eax-16]
	mov	DWORD PTR tv1396[ebp], eax

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+16]

; 69   : 		return nRefs < 0;

	cmp	DWORD PTR [esi+12], 0

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	ecx, eax

; 69   : 		return nRefs < 0;

	lea	eax, DWORD PTR [esi+12]

; 883  : 		if( !pData->IsLocked() && (pNewStringMgr == pData->pStringMgr) )

	jl	SHORT $LN78@Go
	cmp	ecx, DWORD PTR [esi]
	jne	SHORT $LN78@Go

; 65   : 		_InterlockedIncrement(&nRefs);

	lock	 inc	 DWORD PTR [eax]

; 887  : 		}

	jmp	SHORT $LN79@Go
$LN78@Go:

; 888  : 		else
; 889  : 		{
; 890  : 			pNewData = pNewStringMgr->Allocate( pData->nDataLength, sizeof( XCHAR ) );

	mov	eax, DWORD PTR [ecx]
	lea	edi, DWORD PTR [esi+4]
	push	2
	push	DWORD PTR [edi]
	call	DWORD PTR [eax]
	mov	esi, eax

; 891  : 			if( pNewData == NULL )

	test	esi, esi
	je	$LN251@Go

; 894  : 			}
; 895  : 			pNewData->nDataLength = pData->nDataLength;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax

; 896  : 			CopyChars( PXSTR( pNewData->data() ), pData->nDataLength+1,

	mov	eax, DWORD PTR [edi]
	inc	eax
	push	eax
	push	DWORD PTR tv1396[ebp]
	push	eax

; 59   : 		return (this+1);

	lea	eax, DWORD PTR [esi+16]

; 896  : 			CopyChars( PXSTR( pNewData->data() ), pData->nDataLength+1,

	push	eax
	call	?CopyChars@?$CSimpleStringT@_W$0A@@ATL@@SAXPA_WIPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::CopyChars
	add	esp, 16					; 00000010H
$LN79@Go:

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	ecx, DWORD PTR _this$[ebp]

; 59   : 		return (this+1);

	lea	eax, DWORD PTR [esi+16]
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 111  : 			CString Local = pt_fichier->Ajoute_Extension(pt_fichier->Supprime_Extension(pszSource), Mess);

	push	DWORD PTR tv1400[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [ecx], eax
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 111  : 			CString Local = pt_fichier->Ajoute_Extension(pt_fichier->Supprime_Extension(pszSource), Mess);

	call	?Supprime_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z ; Manipulation_Fichier::Supprime_Extension
	lea	eax, DWORD PTR _Local$34[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	push	eax
	call	?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z ; Manipulation_Fichier::Ajoute_Extension

; 112  : 			Calcul_temps *pt_time = new Calcul_temps;

	push	24					; 00000018H
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T8[ebp], edi
	test	edi, edi
	je	SHORT $LN8@Go
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp

; 13   : {

	mov	DWORD PTR [edi], OFFSET ??_7Calcul_temps@@6B@

; 14   : 
; 15   : 	Start = Stop = 0;

	mov	DWORD PTR [edi+16], 0
	mov	DWORD PTR [edi+20], 0
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 112  : 			Calcul_temps *pt_time = new Calcul_temps;

	jmp	SHORT $LN9@Go
$LN8@Go:
	xor	edi, edi
$LN9@Go:
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp

; 37   : 	errno_t erreur = _ftime_s(&timebuffer);

	lea	eax, DWORD PTR _timebuffer$33[ebp]
	push	eax
	call	__ftime64_s

; 38   : 	return (uint64_t)(((timebuffer.time * 1000) + timebuffer.millitm));

	mov	eax, DWORD PTR _timebuffer$33[ebp+4]
	mov	ecx, 1000				; 000003e8H
	mul	ecx
	mov	esi, eax
	mov	eax, DWORD PTR _timebuffer$33[ebp]
	mul	ecx
	mov	ecx, eax
	add	esi, edx
	movzx	eax, WORD PTR _timebuffer$33[ebp+8]
	cdq
	add	ecx, eax
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 114  : 			if (pt_encode->MyEncryptFile(pszSource.GetBuffer(),pt_Ajust->Do(Local).GetBuffer(), pt_pass->Get_Ressource_huff(IDR_MYFILE).GetBuffer()))

	lea	eax, DWORD PTR $T10[ebp]
	push	eax
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp

; 38   : 	return (uint64_t)(((timebuffer.time * 1000) + timebuffer.millitm));

	adc	esi, edx

; 20   : 	Start = Build();

	mov	DWORD PTR [edi+8], ecx
	mov	DWORD PTR [edi+12], esi
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 114  : 			if (pt_encode->MyEncryptFile(pszSource.GetBuffer(),pt_Ajust->Do(Local).GetBuffer(), pt_pass->Get_Ressource_huff(IDR_MYFILE).GetBuffer()))

	call	?Get_Ressource_huff@C_Password@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@H@Z ; C_Password::Get_Ressource_huff
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	ecx, DWORD PTR [esi]

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [ecx-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN129@Go

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [ecx-12]
	mov	ecx, esi
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	ecx, DWORD PTR [esi]
$LN129@Go:

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	esi, DWORD PTR _Local$34[ebp]
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 114  : 			if (pt_encode->MyEncryptFile(pszSource.GetBuffer(),pt_Ajust->Do(Local).GetBuffer(), pt_pass->Get_Ressource_huff(IDR_MYFILE).GetBuffer()))

	push	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	add	esi, -16				; fffffff0H
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 114  : 			if (pt_encode->MyEncryptFile(pszSource.GetBuffer(),pt_Ajust->Do(Local).GetBuffer(), pt_pass->Get_Ressource_huff(IDR_MYFILE).GetBuffer()))

	push	ecx
	mov	DWORD PTR _this$[ebp], esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+16]

; 69   : 		return nRefs < 0;

	cmp	DWORD PTR [esi+12], 0

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	ecx, eax

; 69   : 		return nRefs < 0;

	lea	eax, DWORD PTR [esi+12]

; 883  : 		if( !pData->IsLocked() && (pNewStringMgr == pData->pStringMgr) )

	jl	SHORT $LN143@Go
	cmp	ecx, DWORD PTR [esi]
	jne	SHORT $LN143@Go

; 65   : 		_InterlockedIncrement(&nRefs);

	lock	 inc	 DWORD PTR [eax]

; 887  : 		}

	jmp	SHORT $LN144@Go
$LN143@Go:

; 888  : 		else
; 889  : 		{
; 890  : 			pNewData = pNewStringMgr->Allocate( pData->nDataLength, sizeof( XCHAR ) );

	mov	eax, DWORD PTR [ecx]
	push	2
	push	DWORD PTR [esi+4]
	call	DWORD PTR [eax]
	mov	edx, eax
	mov	DWORD PTR _pNewData$1$[ebp], edx

; 891  : 			if( pNewData == NULL )

	test	edx, edx
	je	$LN252@Go

; 894  : 			}
; 895  : 			pNewData->nDataLength = pData->nDataLength;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx+4], eax

; 59   : 		return (this+1);

	lea	eax, DWORD PTR [esi+16]

; 896  : 			CopyChars( PXSTR( pNewData->data() ), pData->nDataLength+1,

	mov	ecx, DWORD PTR [esi+4]
	inc	ecx
	push	ecx
	push	eax
	push	ecx

; 59   : 		return (this+1);

	lea	eax, DWORD PTR [edx+16]

; 896  : 			CopyChars( PXSTR( pNewData->data() ), pData->nDataLength+1,

	push	eax
	call	?CopyChars@?$CSimpleStringT@_W$0A@@ATL@@SAXPA_WIPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::CopyChars
	mov	esi, DWORD PTR _pNewData$1$[ebp]
	add	esp, 16					; 00000010H
$LN144@Go:

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	ecx, DWORD PTR _this$[ebp]

; 59   : 		return (this+1);

	lea	eax, DWORD PTR [esi+16]

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [ecx], eax
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 114  : 			if (pt_encode->MyEncryptFile(pszSource.GetBuffer(),pt_Ajust->Do(Local).GetBuffer(), pt_pass->Get_Ressource_huff(IDR_MYFILE).GetBuffer()))

	lea	eax, DWORD PTR $T14[ebp]
	push	eax
	call	?Do@AjustFileName@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z ; AjustFileName::Do
	mov	DWORD PTR tv1398[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	esi, DWORD PTR [eax]

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [esi-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN162@Go

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [esi-12]
	mov	ecx, eax
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	esi, DWORD PTR tv1398[ebp]
	mov	esi, DWORD PTR [esi]
$LN162@Go:

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ecx]

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [eax-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN169@Go

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [eax-12]
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ecx]
$LN169@Go:
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 114  : 			if (pt_encode->MyEncryptFile(pszSource.GetBuffer(),pt_Ajust->Do(Local).GetBuffer(), pt_pass->Get_Ressource_huff(IDR_MYFILE).GetBuffer()))

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	esi
	push	eax
	mov	ecx, DWORD PTR [ecx+24]
	call	?MyEncryptFile@C_AES_Encode@@QAE_NPA_W00@Z ; C_AES_Encode::MyEncryptFile
	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	or	esi, -1

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR $T14[ebp]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	ecx, esi
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 114  : 			if (pt_encode->MyEncryptFile(pszSource.GetBuffer(),pt_Ajust->Do(Local).GetBuffer(), pt_pass->Get_Ressource_huff(IDR_MYFILE).GetBuffer()))

	mov	BYTE PTR $T31[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	add	edx, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], ecx
	dec	ecx
	test	ecx, ecx
	jg	SHORT $LN182@Go

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN182@Go:
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 114  : 			if (pt_encode->MyEncryptFile(pszSource.GetBuffer(),pt_Ajust->Do(Local).GetBuffer(), pt_pass->Get_Ressource_huff(IDR_MYFILE).GetBuffer()))

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, esi

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR $T10[ebp]
	add	edx, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN191@Go

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN191@Go:
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 114  : 			if (pt_encode->MyEncryptFile(pszSource.GetBuffer(),pt_Ajust->Do(Local).GetBuffer(), pt_pass->Get_Ressource_huff(IDR_MYFILE).GetBuffer()))

	lea	eax, DWORD PTR _timebuffer$32[ebp]
	push	eax
	call	__ftime64_s
	mov	eax, DWORD PTR _timebuffer$32[ebp+4]
	mov	ecx, 1000				; 000003e8H
	mul	ecx
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR _timebuffer$32[ebp]
	mul	ecx
	mov	ecx, eax
	add	esi, edx
	cmp	BYTE PTR $T31[ebp], 0
	movzx	eax, WORD PTR _timebuffer$32[ebp+8]
	cdq
	je	SHORT $LN3@Go
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp

; 38   : 	return (uint64_t)(((timebuffer.time * 1000) + timebuffer.millitm));

	add	ecx, eax
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 117  : 				Calcul = pt_time->Read_time();

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp

; 25   : 	Stop =  Build();

	mov	DWORD PTR [edi+16], ecx

; 38   : 	return (uint64_t)(((timebuffer.time * 1000) + timebuffer.millitm));

	adc	esi, edx

; 30   : 	return (Stop - Start);

	sub	ecx, DWORD PTR [edi+8]

; 25   : 	Stop =  Build();

	mov	DWORD PTR [edi+20], esi

; 30   : 	return (Stop - Start);

	sbb	esi, DWORD PTR [edi+12]
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 117  : 				Calcul = pt_time->Read_time();

	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], esi

; 118  : 				delete pt_Ajust;

	test	ebx, ebx
	je	SHORT $LN200@Go
	push	1
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN200@Go:

; 119  : 				delete pt_time;

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	push	1
	call	DWORD PTR [eax]
	mov	bl, 1
	jmp	SHORT $LN29@Go
$LN3@Go:
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp

; 38   : 	return (uint64_t)(((timebuffer.time * 1000) + timebuffer.millitm));

	add	ecx, eax

; 25   : 	Stop =  Build();

	mov	DWORD PTR [edi+16], ecx

; 38   : 	return (uint64_t)(((timebuffer.time * 1000) + timebuffer.millitm));

	adc	esi, edx

; 25   : 	Stop =  Build();

	mov	DWORD PTR [edi+20], esi
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 125  : 				status = Mess.LoadString(IDS_STRING190);

	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
	push	190					; 000000beH
	lea	ecx, DWORD PTR [esi+20]
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	eax, DWORD PTR [esi+20]

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [eax-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN246@Go

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [eax-12]
	lea	ecx, DWORD PTR [esi+20]
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	esi, DWORD PTR [esi+20]
	jmp	SHORT $LN216@Go
$LN246@Go:

; 91   : 		}
; 92   : 	}
; 93   : 	void Unlock() throw()
; 94   : 	{
; 95   : 		ATLASSERT( IsLocked() );
; 96   : 
; 97   : 		if(IsLocked())
; 98   : 		{
; 99   : 			nRefs++;  // Locked buffers can't be shared, so no interlocked operation necessary
; 100  : 			if( nRefs == 0 )
; 101  : 			{
; 102  : 				nRefs = 1;
; 103  : 			}
; 104  : 		}
; 105  : 	}
; 106  : };
; 107  : 
; 108  : class CNilStringData :
; 109  : 	public CStringData
; 110  : {
; 111  : public:
; 112  : 	CNilStringData() throw()
; 113  : 	{
; 114  : 		pStringMgr = NULL;
; 115  : 		nRefs = 2;  // Never gets freed by IAtlStringMgr
; 116  : 		nDataLength = 0;
; 117  : 		nAllocLength = 0;
; 118  : 		achNil[0] = 0;
; 119  : 		achNil[1] = 0;
; 120  : 	}
; 121  : 
; 122  : 	void SetManager(_In_ IAtlStringMgr* pMgr) throw()
; 123  : 	{
; 124  : 		ATLASSERT( pStringMgr == NULL );
; 125  : 		pStringMgr = pMgr;
; 126  : 	}
; 127  : 
; 128  : public:
; 129  : 	wchar_t achNil[2];
; 130  : };
; 131  : 
; 132  : template< typename BaseType, const int t_nSize >
; 133  : class CStaticString
; 134  : {
; 135  : public:
; 136  : 	CStaticString(_In_z_ const BaseType* psz) :
; 137  : 		m_psz( psz )
; 138  : 	{
; 139  : 	}
; 140  : 
; 141  : 	operator const BaseType*() const
; 142  : 	{
; 143  : 		return m_psz;
; 144  : 	}
; 145  : 
; 146  : 	static int __cdecl GetLength()
; 147  : 	{
; 148  : 		return (t_nSize/sizeof( BaseType ))-1;
; 149  : 	}
; 150  : 
; 151  : private:
; 152  : 	const BaseType* m_psz;
; 153  : 
; 154  : private:
; 155  : 	CStaticString(_In_ const CStaticString& str) throw();
; 156  : 	CStaticString& operator=(_In_ const CStaticString& str) throw();
; 157  : };
; 158  : 
; 159  : #define _ST( psz ) ATL::CStaticString< TCHAR, sizeof( _T( psz ) ) >( _T( psz ) )
; 160  : #define _SA( psz ) ATL::CStaticString< char, sizeof( psz ) >( psz )
; 161  : #define _SW( psz ) ATL::CStaticString< wchar_t, sizeof( L##psz ) >( L##psz )
; 162  : #define _SO( psz ) _SW( psz )
; 163  : 
; 164  : template< typename BaseType = char >
; 165  : class ChTraitsBase
; 166  : {
; 167  : public:
; 168  : 	typedef char XCHAR;
; 169  : 	typedef LPSTR PXSTR;
; 170  : 	typedef LPCSTR PCXSTR;
; 171  : 	typedef wchar_t YCHAR;
; 172  : 	typedef LPWSTR PYSTR;
; 173  : 	typedef LPCWSTR PCYSTR;
; 174  : };
; 175  : 
; 176  : template<>
; 177  : class ChTraitsBase< wchar_t >
; 178  : {
; 179  : public:
; 180  : 	typedef wchar_t XCHAR;
; 181  : 	typedef LPWSTR PXSTR;
; 182  : 	typedef LPCWSTR PCXSTR;
; 183  : 	typedef char YCHAR;
; 184  : 	typedef LPSTR PYSTR;
; 185  : 	typedef LPCSTR PCYSTR;
; 186  : };
; 187  : 
; 188  : template< typename TCharType, bool t_bMFCDLL = false >
; 189  : class CStrBufT;
; 190  : 
; 191  : template< typename BaseType , bool t_bMFCDLL = false>
; 192  : class CSimpleStringT
; 193  : {
; 194  : public:
; 195  : 	typedef typename ChTraitsBase< BaseType >::XCHAR XCHAR;
; 196  : 	typedef typename ChTraitsBase< BaseType >::PXSTR PXSTR;
; 197  : 	typedef typename ChTraitsBase< BaseType >::PCXSTR PCXSTR;
; 198  : 	typedef typename ChTraitsBase< BaseType >::YCHAR YCHAR;
; 199  : 	typedef typename ChTraitsBase< BaseType >::PYSTR PYSTR;
; 200  : 	typedef typename ChTraitsBase< BaseType >::PCYSTR PCYSTR;
; 201  : 
; 202  : public:
; 203  : 	explicit CSimpleStringT(_Inout_ IAtlStringMgr* pStringMgr)
; 204  : 	{
; 205  : 		ATLENSURE( pStringMgr != NULL );
; 206  : 		CStringData* pData = pStringMgr->GetNilString();
; 207  : 		Attach( pData );
; 208  : 	}
; 209  : 
; 210  : 	CSimpleStringT(_In_ const CSimpleStringT& strSrc)
; 211  : 	{
; 212  : 		CStringData* pSrcData = strSrc.GetData();
; 213  : 		CStringData* pNewData = CloneData( pSrcData );
; 214  : 		Attach( pNewData );
; 215  : 	}
; 216  : 
; 217  : 	CSimpleStringT(_In_ const CSimpleStringT<BaseType, !t_bMFCDLL>& strSrc)
; 218  : 	{
; 219  : 		CStringData* pSrcData = strSrc.GetData();
; 220  : 		CStringData* pNewData = CloneData( pSrcData );
; 221  : 		Attach( pNewData );
; 222  : 	}
; 223  : 
; 224  : 	CSimpleStringT(
; 225  : 		_In_z_ PCXSTR pszSrc,
; 226  : 		_Inout_ IAtlStringMgr* pStringMgr)
; 227  : 	{
; 228  : 		ATLENSURE( pStringMgr != NULL );
; 229  : 
; 230  : 		int nLength = StringLength( pszSrc );
; 231  : 		CStringData* pData = pStringMgr->Allocate( nLength, sizeof( XCHAR ) );
; 232  : 		if( pData == NULL )
; 233  : 		{
; 234  : 			ThrowMemoryException();
; 235  : 		}
; 236  : 		Attach( pData );
; 237  : 		SetLength( nLength );
; 238  : 		CopyChars( m_pszData, nLength, pszSrc, nLength );
; 239  : 	}
; 240  : 	CSimpleStringT(
; 241  : 		_In_reads_(nLength) const XCHAR* pchSrc,
; 242  : 		_In_ int nLength,
; 243  : 		_Inout_ IAtlStringMgr* pStringMgr)
; 244  : 	{
; 245  : 		ATLENSURE( pStringMgr != NULL );
; 246  : 
; 247  : 		if(pchSrc == NULL && nLength != 0)
; 248  : 			AtlThrow(E_INVALIDARG);
; 249  : 
; 250  : 		CStringData* pData = pStringMgr->Allocate( nLength, sizeof( XCHAR ) );
; 251  : 		if( pData == NULL )
; 252  : 		{
; 253  : 			ThrowMemoryException();
; 254  : 		}
; 255  : 		Attach( pData );
; 256  : 		SetLength( nLength );
; 257  : 		CopyChars( m_pszData, nLength, pchSrc, nLength );
; 258  : 	}
; 259  : 	~CSimpleStringT() throw()
; 260  : 	{
; 261  : 		CStringData* pData = GetData();
; 262  : 		pData->Release();
; 263  : 	}
; 264  : 
; 265  : 	operator CSimpleStringT<BaseType, !t_bMFCDLL>&()
; 266  : 	{
; 267  : 		return *(CSimpleStringT<BaseType, !t_bMFCDLL>*)this;
; 268  : 	}
; 269  : 
; 270  : 	CSimpleStringT& operator=(_In_ const CSimpleStringT& strSrc)
; 271  : 	{
; 272  : 		CStringData* pSrcData = strSrc.GetData();
; 273  : 		CStringData* pOldData = GetData();
; 274  : 		if( pSrcData != pOldData)
; 275  : 		{
; 276  : 			if( pOldData->IsLocked() || pSrcData->pStringMgr != pOldData->pStringMgr )
; 277  : 			{
; 278  : 				SetString( strSrc.GetString(), strSrc.GetLength() );
; 279  : 			}
; 280  : 			else
; 281  : 			{
; 282  : 				CStringData* pNewData = CloneData( pSrcData );
; 283  : 				pOldData->Release();
; 284  : 				Attach( pNewData );
; 285  : 			}
; 286  : 		}
; 287  : 
; 288  : 		return( *this );
; 289  : 	}
; 290  : 
; 291  : 	CSimpleStringT& operator=(_In_ const CSimpleStringT<BaseType, !t_bMFCDLL>& strSrc)
; 292  : 	{
; 293  : 		CStringData* pSrcData = strSrc.GetData();
; 294  : 		CStringData* pOldData = GetData();
; 295  : 		if( pSrcData != pOldData)
; 296  : 		{
; 297  : 			if( pOldData->IsLocked() || pSrcData->pStringMgr != pOldData->pStringMgr )
; 298  : 			{
; 299  : 				SetString( strSrc.GetString(), strSrc.GetLength() );
; 300  : 			}
; 301  : 			else
; 302  : 			{
; 303  : 				CStringData* pNewData = CloneData( pSrcData );
; 304  : 				pOldData->Release();
; 305  : 				Attach( pNewData );
; 306  : 			}
; 307  : 		}
; 308  : 
; 309  : 		return( *this );
; 310  : 	}
; 311  : 
; 312  : 	CSimpleStringT& operator=(_In_opt_z_ PCXSTR pszSrc)
; 313  : 	{
; 314  : 		SetString( pszSrc );
; 315  : 
; 316  : 		return( *this );
; 317  : 	}
; 318  : 
; 319  : 	CSimpleStringT& operator+=(_In_ const CSimpleStringT& strSrc)
; 320  : 	{
; 321  : 		Append( strSrc );
; 322  : 
; 323  : 		return( *this );
; 324  : 	}
; 325  : 	template <bool bMFCDLL>
; 326  : 	CSimpleStringT& operator+=(_In_ const CSimpleStringT<BaseType, bMFCDLL>& strSrc)
; 327  : 	{
; 328  : 		Append( strSrc );
; 329  : 
; 330  : 		return( *this );
; 331  : 	}
; 332  : 
; 333  : 	CSimpleStringT& operator+=(_In_z_ PCXSTR pszSrc)
; 334  : 	{
; 335  : 		Append( pszSrc );
; 336  : 
; 337  : 		return( *this );
; 338  : 	}
; 339  : 	template< int t_nSize >
; 340  : 	CSimpleStringT& operator+=(_In_ const CStaticString< XCHAR, t_nSize >& strSrc)
; 341  : 	{
; 342  : 		Append( static_cast<const XCHAR *>(strSrc), strSrc.GetLength() );
; 343  : 
; 344  : 		return( *this );
; 345  : 	}
; 346  : 	CSimpleStringT& operator+=(_In_ char ch)
; 347  : 	{
; 348  : 		AppendChar( XCHAR( ch ) );
; 349  : 
; 350  : 		return( *this );
; 351  : 	}
; 352  : 	CSimpleStringT& operator+=(_In_ unsigned char ch)
; 353  : 	{
; 354  : 		AppendChar( XCHAR( ch ) );
; 355  : 
; 356  : 		return( *this );
; 357  : 	}
; 358  : 	CSimpleStringT& operator+=(_In_ wchar_t ch)
; 359  : 	{
; 360  : 		AppendChar( XCHAR( ch ) );
; 361  : 
; 362  : 		return( *this );
; 363  : 	}
; 364  : 
; 365  : 	XCHAR operator[](_In_ int iChar) const
; 366  : 	{
; 367  : 		ATLASSERT( (iChar >= 0) && (iChar <= GetLength()) );  // Indexing the '\0' is OK
; 368  : 
; 369  : 		if( (iChar < 0) || (iChar > GetLength()) )
; 370  : 			AtlThrow(E_INVALIDARG);
; 371  : 
; 372  : 		return( m_pszData[iChar] );
; 373  : 	}
; 374  : 
; 375  : 	operator PCXSTR() const throw()
; 376  : 	{
; 377  : 		return( m_pszData );
; 378  : 	}
; 379  : 
; 380  : 	void Append(_In_z_ PCXSTR pszSrc)
; 381  : 	{
; 382  : 		Append( pszSrc, StringLength( pszSrc ) );
; 383  : 	}
; 384  : 	void Append(
; 385  : 		_In_reads_(nLength) PCXSTR pszSrc,
; 386  : 		_In_ int nLength)
; 387  : 	{
; 388  : 		// See comment in SetString() about why we do this
; 389  : 		UINT_PTR nOffset = pszSrc-GetString();
; 390  : 
; 391  : 		UINT nOldLength = GetLength();
; 392  : 		if (nOldLength < 0)
; 393  : 		{
; 394  : 			// protects from underflow
; 395  : 			nOldLength = 0;
; 396  : 		}
; 397  : 
; 398  : 		//Make sure the nLength is greater than zero
; 399  : 		ATLENSURE_THROW(nLength >=0, E_INVALIDARG);
; 400  : 
; 401  : 		//Make sure we don't read pass end of the terminating NULL
; 402  : 		nLength = StringLengthN(pszSrc, nLength);
; 403  : 
; 404  : 		//Make sure after the string doesn't exceed INT_MAX after appending
; 405  : 		ATLENSURE_THROW(INT_MAX - nLength >= static_cast<int>(nOldLength), E_INVALIDARG);
; 406  : 
; 407  : 		int nNewLength = nOldLength+nLength;
; 408  : 		PXSTR pszBuffer = GetBuffer( nNewLength );
; 409  : 		if( nOffset <= nOldLength )
; 410  : 		{
; 411  : 			pszSrc = pszBuffer+nOffset;
; 412  : 			// No need to call CopyCharsOverlapped, since the destination is
; 413  : 			// beyond the end of the original buffer
; 414  : 		}
; 415  : 		CopyChars( pszBuffer+nOldLength, nLength, pszSrc, nLength );
; 416  : 		ReleaseBufferSetLength( nNewLength );
; 417  : 	}
; 418  : 	void AppendChar(_In_ XCHAR ch)
; 419  : 	{
; 420  : 		UINT nOldLength = GetLength();
; 421  : 		int nNewLength = nOldLength+1;
; 422  : 		PXSTR pszBuffer = GetBuffer( nNewLength );
; 423  : 		pszBuffer[nOldLength] = ch;
; 424  : 		ReleaseBufferSetLength( nNewLength );
; 425  : 	}
; 426  : 	void Append(_In_ const CSimpleStringT& strSrc)
; 427  : 	{
; 428  : 		Append( strSrc.GetString(), strSrc.GetLength() );
; 429  : 	}
; 430  : 	template <bool bMFCDLL>
; 431  : 	void Append(_In_ const CSimpleStringT<BaseType, bMFCDLL>& strSrc)
; 432  : 	{
; 433  : 		Append( strSrc.GetString(), strSrc.GetLength() );
; 434  : 	}
; 435  : 	void Empty() throw()
; 436  : 	{
; 437  : 		CStringData* pOldData = GetData();
; 438  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
; 439  : 		if( pOldData->nDataLength == 0 )
; 440  : 		{
; 441  : 			return;
; 442  : 		}
; 443  : 
; 444  : 		if( pOldData->IsLocked() )
; 445  : 		{
; 446  : 			// Don't reallocate a locked buffer that's shrinking
; 447  : 			SetLength( 0 );
; 448  : 		}
; 449  : 		else
; 450  : 		{
; 451  : 			pOldData->Release();
; 452  : 			CStringData* pNewData = pStringMgr->GetNilString();
; 453  : 			Attach( pNewData );
; 454  : 		}
; 455  : 	}
; 456  : 	void FreeExtra()
; 457  : 	{
; 458  : 		CStringData* pOldData = GetData();
; 459  : 		int nLength = pOldData->nDataLength;
; 460  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
; 461  : 		if( pOldData->nAllocLength == nLength )
; 462  : 		{
; 463  : 			return;
; 464  : 		}
; 465  : 
; 466  : 		if( !pOldData->IsLocked() )  // Don't reallocate a locked buffer that's shrinking
; 467  : 		{
; 468  : 			CStringData* pNewData = pStringMgr->Allocate( nLength, sizeof( XCHAR ) );
; 469  : 			if( pNewData == NULL )
; 470  : 			{
; 471  : 				SetLength( nLength );
; 472  : 				return;
; 473  : 			}
; 474  : 
; 475  : 			CopyChars( PXSTR( pNewData->data() ), nLength,
; 476  : 				PCXSTR( pOldData->data() ), nLength );
; 477  : 
; 478  : 			pOldData->Release();
; 479  : 			Attach( pNewData );
; 480  : 			SetLength( nLength );
; 481  : 		}
; 482  : 	}
; 483  : 
; 484  : 	int GetAllocLength() const throw()
; 485  : 	{
; 486  : 		return( GetData()->nAllocLength );
; 487  : 	}
; 488  : 	XCHAR GetAt(_In_ int iChar) const
; 489  : 	{
; 490  : 		ATLASSERT( (iChar >= 0) && (iChar <= GetLength()) );  // Indexing the '\0' is OK
; 491  : 		if( (iChar < 0) || (iChar > GetLength()) )
; 492  : 			AtlThrow(E_INVALIDARG);
; 493  : 
; 494  : 		return( m_pszData[iChar] );
; 495  : 	}
; 496  : 	PXSTR GetBuffer()
; 497  : 	{
; 498  : 		CStringData* pData = GetData();
; 499  : 		if( pData->IsShared() )

	mov	esi, eax
$LN216@Go:
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 126  : 				pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());

	call	DWORD PTR __imp__GetLastError@0
	push	eax
	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	push	esi
	mov	ecx, DWORD PTR [eax+32]
	call	?MyHandleError@C_Error_Message@@QAEXPA_WH@Z ; C_Error_Message::MyHandleError

; 127  : 				delete pt_Ajust;

	test	ebx, ebx
	je	SHORT $LN223@Go
	push	1
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN223@Go:

; 128  : 				delete pt_time;

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	push	1
	call	DWORD PTR [eax]

; 129  : 				return false;

	xor	bl, bl
$LN29@Go:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	or	eax, -1

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	esi, DWORD PTR _Local$34[ebp]
	add	esi, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [esi+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN232@Go

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [esi]
	push	esi
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+4]
$LN232@Go:
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 129  : 				return false;

	mov	al, bl
	jmp	SHORT $LN1@Go
$LN241@Go:

; 130  : 			}
; 131  : 	}
; 132  : 	delete pt_Ajust;

	test	ebx, ebx
	je	SHORT $LN244@Go
	push	1
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN244@Go:

; 133  : 	return false;

	xor	al, al
$LN1@Go:

; 134  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN250@Go:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 893  : 				ThrowMemoryException();

	call	?ThrowMemoryException@?$CSimpleStringT@_W$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<wchar_t,0>::ThrowMemoryException
$LN251@Go:
	call	?ThrowMemoryException@?$CSimpleStringT@_W$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<wchar_t,0>::ThrowMemoryException
$LN252@Go:
	call	?ThrowMemoryException@?$CSimpleStringT@_W$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<wchar_t,0>::ThrowMemoryException
$LN248@Go:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Go@C_Encode_Interactif@@QAE_NXZ$0:
	push	1
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Go@C_Encode_Interactif@@QAE_NXZ$1:
	mov	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$?Go@C_Encode_Interactif@@QAE_NXZ$4:
	lea	ecx, DWORD PTR _Local$34[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$?Go@C_Encode_Interactif@@QAE_NXZ$6:
	lea	ecx, DWORD PTR $T10[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$?Go@C_Encode_Interactif@@QAE_NXZ$8:
	lea	ecx, DWORD PTR $T14[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__ehhandler$?Go@C_Encode_Interactif@@QAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Go@C_Encode_Interactif@@QAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Go@C_Encode_Interactif@@QAE_NXZ ENDP			; C_Encode_Interactif::Go
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
;	COMDAT ??0C_Encode_Interactif@@QAE@XZ
_TEXT	SEGMENT
$T7 = -20						; size = 4
$T3 = -20						; size = 4
$T1 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0C_Encode_Interactif@@QAE@XZ PROC			; C_Encode_Interactif::C_Encode_Interactif, COMDAT
; _this$ = ecx

; 15   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0C_Encode_Interactif@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN117@C_Encode_I

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	call	eax

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [esi+8], eax
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 15   : {

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN117@C_Encode_I

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	call	eax

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [esi+12], eax
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 15   : {

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN117@C_Encode_I

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	call	eax

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [esi+16], eax
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 15   : {

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN117@C_Encode_I

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	call	eax

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [esi+20], eax
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 16   : 	pt_encode = new C_AES_Encode;

	push	20					; 00000014H
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	test	eax, eax
	je	SHORT $LN3@C_Encode_I
	xorps	xmm0, xmm0
	mov	ecx, eax
	movups	XMMWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+16], 0
	call	??0C_AES_Encode@@QAE@XZ			; C_AES_Encode::C_AES_Encode
	jmp	SHORT $LN4@C_Encode_I
$LN3@C_Encode_I:
	xor	eax, eax
$LN4@C_Encode_I:
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 17   : 	pt_pass = new C_Password;

	push	1
	mov	DWORD PTR [esi+24], eax
	call	??2@YAPAXI@Z				; operator new
	mov	DWORD PTR $T3[ebp], eax

; 18   : 	pt_Erreur = new C_Error_Message;

	push	4
	mov	DWORD PTR [esi+28], eax
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@C_Encode_I
	mov	DWORD PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 1006 : 		CThisSimpleString( StringTraits::GetDefaultManager() )

	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	SHORT $LN117@C_Encode_I

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	call	eax

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [edi], eax
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 18   : 	pt_Erreur = new C_Error_Message;

	jmp	SHORT $LN8@C_Encode_I
$LN7@C_Encode_I:
	xor	edi, edi
$LN8@C_Encode_I:

; 19   : 	pt_fichier = new Manipulation_Fichier;

	push	1
	mov	DWORD PTR [esi+32], edi
	call	??2@YAPAXI@Z				; operator new
	mov	DWORD PTR $T7[ebp], eax
	add	esp, 4
	mov	DWORD PTR [esi+36], eax

; 20   : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN117@C_Encode_I:
	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN119@C_Encode_I:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0C_Encode_Interactif@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$??0C_Encode_Interactif@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$??0C_Encode_Interactif@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$??0C_Encode_Interactif@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$??0C_Encode_Interactif@@QAE@XZ$4:
	push	20					; 00000014H
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0C_Encode_Interactif@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0C_Encode_Interactif@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0C_Encode_Interactif@@QAE@XZ ENDP			; C_Encode_Interactif::C_Encode_Interactif
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
;	COMDAT ?Current_Dir@C_Encode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?Current_Dir@C_Encode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ PROC ; C_Encode_Interactif::Current_Dir, COMDAT
; _this$dead$ = ecx

; 32   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Current_Dir@C_Encode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T1[ebp], 0
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN56@Current_Di

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [esi], eax
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 37   : 	return (Chaine);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 808  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false

	mov	ecx, 1
	sub	ecx, DWORD PTR [eax-4]

; 809  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

	mov	eax, DWORD PTR [eax-8]
	sub	eax, 260				; 00000104H
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 37   : 	return (Chaine);

	mov	DWORD PTR $T1[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 810  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

	or	ecx, eax
	jge	SHORT $LN30@Current_Di

; 811  : 		{
; 812  : 			PrepareWrite2( nLength );

	push	260					; 00000104H
	mov	ecx, esi
	call	?PrepareWrite2@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2
$LN30@Current_Di:
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 35   : 	::GetCurrentDirectory(MAX_PATH, Chaine.GetBuffer(MAX_PATH));

	push	DWORD PTR [esi]
	push	260					; 00000104H
	call	DWORD PTR __imp__GetCurrentDirectoryW@8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 560  : 			int nAlloc = GetData()->nAllocLength;

	mov	eax, DWORD PTR [esi]

; 750  : 		if( psz == NULL )

	test	eax, eax
	je	SHORT $LN52@Current_Di
$LN41@Current_Di:

; 751  : 		{
; 752  : 			return( 0 );
; 753  : 		}
; 754  : 		return( int( wcsnlen( psz, sizeInXChar ) ) );

	push	DWORD PTR [eax-8]
	push	eax
	call	_wcsnlen
	add	esp, 8

; 871  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	test	eax, eax
	js	SHORT $LN45@Current_Di
$LN52@Current_Di:
	mov	ecx, DWORD PTR [esi]
	cmp	eax, DWORD PTR [ecx-8]
	jg	SHORT $LN45@Current_Di

; 873  : 
; 874  : 		GetData()->nDataLength = nLength;

	mov	DWORD PTR [ecx-12], eax

; 875  : 		m_pszData[nLength] = 0;

	xor	edx, edx
	mov	ecx, DWORD PTR [esi]
	mov	WORD PTR [ecx+eax*2], dx
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 37   : 	return (Chaine);

	mov	eax, esi

; 39   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN45@Current_Di:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 872  : 			AtlThrow(E_INVALIDARG);

	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN56@Current_Di:

; 205  : 		ATLENSURE( pStringMgr != NULL );

	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN54@Current_Di:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Current_Dir@C_Encode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ$0:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN4@Current_Di
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
$LN4@Current_Di:
	ret	0
__ehhandler$?Current_Dir@C_Encode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Current_Dir@C_Encode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Current_Dir@C_Encode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ ENDP ; C_Encode_Interactif::Current_Dir
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxwin1.inl
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp
;	COMDAT ?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z
_TEXT	SEGMENT
$T5 = -1292						; size = 4
_this$GSCopy$1$ = -1288					; size = 4
_this$1$ = -1288					; size = 4
$T13 = -1281						; size = 1
_FileOpenDialog$ = -1280				; size = 1256
_local_File$ = -24					; size = 4
_OpenFilter$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_File$ = 8						; size = 4
?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z PROC	; C_Encode_Interactif::Open_File, COMDAT
; _this$ = ecx

; 71   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1280				; 00000500H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], ebx
	mov	esi, DWORD PTR _File$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN140@Open_File

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR _OpenFilter$[ebp], eax
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 72   : 	CString OpenFilter;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN141@Open_File

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR _local_File$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 1044 : 		CThisSimpleString( StringTraits::GetDefaultManager() )

	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2668 : 		if( (pv != NULL) && IS_INTRESOURCE( pv ) )

	test	esi, esi
	je	SHORT $LN134@Open_File
	test	esi, -65536				; ffff0000H
	jne	SHORT $LN63@Open_File

; 2669 : 		{
; 2670 : 			UINT nID = LOWORD( reinterpret_cast< DWORD_PTR >( pv ) );

	movzx	eax, si

; 2671 : 			(nID);
; 2672 : #ifdef _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 2673 : 			if( !LoadString( nID ) )

	lea	ecx, DWORD PTR _local_File$[ebp]
	push	eax
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW

; 1046 : 		if( !CheckImplicitLoad( pszSrc ) )

	jmp	SHORT $LN33@Open_File
$LN63@Open_File:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 734  : 		return( int( wcslen( psz ) ) );

	mov	ecx, esi
	lea	edx, DWORD PTR [ecx+2]
$LL135@Open_File:
	mov	ax, WORD PTR [ecx]
	add	ecx, 2
	test	ax, ax
	jne	SHORT $LL135@Open_File
	sub	ecx, edx
	sar	ecx, 1
	jmp	SHORT $LN62@Open_File
$LN134@Open_File:

; 731  : 		{
; 732  : 			return( 0 );

	xor	ecx, ecx
$LN62@Open_File:

; 602  : 		SetString( pszSrc, StringLength( pszSrc ) );

	push	ecx
	push	esi
	lea	ecx, DWORD PTR _local_File$[ebp]
	call	?SetString@?$CSimpleStringT@_W$0A@@ATL@@QAEXPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::SetString
$LN33@Open_File:
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 75   : 	BOOL status = Mess.LoadString(IDS_STRING186);

	add	ebx, 20					; 00000014H
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	186					; 000000baH
	mov	ecx, ebx
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW

; 76   : 	OpenFilter = Mess;

	push	ebx
	lea	ecx, DWORD PTR _OpenFilter$[ebp]
	call	??4?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::operator=

; 77   : 	status = Mess.LoadString(IDS_STRING187);

	push	187					; 000000bbH
	mov	ecx, ebx
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW

; 78   : 	OpenFilter += Mess;

	push	ebx
	lea	ecx, DWORD PTR _OpenFilter$[ebp]
	call	??Y?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEAAV01@ABV?$CSimpleStringT@_W$0A@@1@@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::operator+=
	push	1256					; 000004e8H
	lea	eax, DWORD PTR _FileOpenDialog$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxwin1.inl

; 33   : 	{ CWinThread* pThread = AfxGetThread();

	call	?AfxGetThread@@YGPAVCWinThread@@XZ	; AfxGetThread

; 34   : 		return pThread != NULL ? pThread->GetMainWnd() : NULL; }

	test	eax, eax
	je	SHORT $LN69@Open_File
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	call	DWORD PTR [edx+116]
	jmp	SHORT $LN70@Open_File
$LN69@Open_File:
	xor	eax, eax
$LN70@Open_File:
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 81   : 	CFileDialog FileOpenDialog(

	mov	esi, DWORD PTR _OpenFilter$[ebp]
	lea	ecx, DWORD PTR _FileOpenDialog$[ebp]
	mov	edi, DWORD PTR _local_File$[ebp]
	push	1
	push	0
	push	eax
	push	esi
	push	6148					; 00001804H
	push	edi
	push	0
	push	1
	call	??0CFileDialog@@QAE@HPB_W0K0PAVCWnd@@KH@Z ; CFileDialog::CFileDialog

; 89   : 	FileOpenDialog.m_ofn.lpstrInitialDir = Current_Dir();

	lea	eax, DWORD PTR $T5[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	eax
	call	?Current_Dir@C_Encode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ ; C_Encode_Interactif::Current_Dir
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _FileOpenDialog$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 377  : 		return( m_pszData );

	mov	ebx, DWORD PTR [eax]
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 89   : 	FileOpenDialog.m_ofn.lpstrInitialDir = Current_Dir();

	call	?GetOFN@CFileDialog@@QAEAAUtagOFNW@@XZ	; CFileDialog::GetOFN
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	DWORD PTR [eax+44], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	or	eax, -1

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR $T5[ebp]
	add	edx, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN84@Open_File

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN84@Open_File:
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 90   : 	status = Mess.LoadString(IDS_STRING191);

	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
	push	191					; 000000bfH
	lea	ecx, DWORD PTR [ebx+20]
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 377  : 		return( m_pszData );

	mov	ebx, DWORD PTR [ebx+20]
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 91   : 	FileOpenDialog.m_ofn.lpstrTitle = Mess;

	lea	ecx, DWORD PTR _FileOpenDialog$[ebp]
	call	?GetOFN@CFileDialog@@QAEAAUtagOFNW@@XZ	; CFileDialog::GetOFN

; 92   : 
; 93   : 	if (FileOpenDialog.DoModal() == IDOK)

	lea	ecx, DWORD PTR _FileOpenDialog$[ebp]
	mov	DWORD PTR [eax+48], ebx
	call	?DoModal@CFileDialog@@UAEHXZ		; CFileDialog::DoModal
	cmp	eax, 1
	jne	SHORT $LN2@Open_File

; 94   : 	{
; 95   : 		pszSource = FileOpenDialog.m_ofn.lpstrFile;

	lea	ecx, DWORD PTR _FileOpenDialog$[ebp]
	call	?GetOFN@CFileDialog@@QAEAAUtagOFNW@@XZ	; CFileDialog::GetOFN
	mov	edx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _this$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 730  : 		if( psz == NULL )

	test	edx, edx
	jne	SHORT $LN95@Open_File

; 731  : 		{
; 732  : 			return( 0 );

	xor	ecx, ecx

; 602  : 		SetString( pszSrc, StringLength( pszSrc ) );

	push	ecx
	push	edx
	mov	ecx, eax
	call	?SetString@?$CSimpleStringT@_W$0A@@ATL@@QAEXPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::SetString
	mov	BYTE PTR $T13[ebp], 1
	jmp	SHORT $LN8@Open_File
$LN95@Open_File:

; 734  : 		return( int( wcslen( psz ) ) );

	mov	ecx, edx
	lea	ebx, DWORD PTR [ecx+2]
$LL136@Open_File:
	mov	ax, WORD PTR [ecx]
	add	ecx, 2
	test	ax, ax
	jne	SHORT $LL136@Open_File
	mov	eax, DWORD PTR _this$1$[ebp]
	sub	ecx, ebx
	sar	ecx, 1

; 602  : 		SetString( pszSrc, StringLength( pszSrc ) );

	push	ecx
	push	edx
	mov	ecx, eax
	call	?SetString@?$CSimpleStringT@_W$0A@@ATL@@QAEXPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::SetString
	mov	BYTE PTR $T13[ebp], 1
	jmp	SHORT $LN8@Open_File
$LN2@Open_File:
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 98   : 	return false;

	mov	BYTE PTR $T13[ebp], 0
$LN8@Open_File:
	lea	ecx, DWORD PTR _FileOpenDialog$[ebp]
	call	??1CFileDialog@@UAE@XZ			; CFileDialog::~CFileDialog
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	or	ebx, -1
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 98   : 	return false;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	add	edi, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, ebx
	lock	 xadd	 DWORD PTR [edi+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN122@Open_File

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edi]
	push	edi
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN122@Open_File:
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 98   : 	return false;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	add	esi, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [esi+12], ebx
	dec	ebx
	test	ebx, ebx
	jg	SHORT $LN131@Open_File

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [esi]
	push	esi
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+4]
$LN131@Open_File:
; File I:\Projets\AES\AES\AES\C_Encode_Interactif.cpp

; 98   : 	return false;

	mov	al, BYTE PTR $T13[ebp]

; 100  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN140@Open_File:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN141@Open_File:
	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN138@Open_File:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z$0:
	lea	ecx, DWORD PTR _OpenFilter$[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z$4:
	lea	ecx, DWORD PTR _local_File$[ebp]
	jmp	??1?$CSimpleStringT@_W$0A@@ATL@@QAE@XZ	; ATL::CSimpleStringT<wchar_t,0>::~CSimpleStringT<wchar_t,0>
__unwindfunclet$?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z$1:
	lea	ecx, DWORD PTR _local_File$[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z$2:
	lea	ecx, DWORD PTR _FileOpenDialog$[ebp]
	jmp	??1CFileDialog@@UAE@XZ			; CFileDialog::~CFileDialog
__unwindfunclet$?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z$3:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__ehhandler$?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1296]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Open_File@C_Encode_Interactif@@AAE_NPA_W@Z ENDP	; C_Encode_Interactif::Open_File
END
