; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28106.4 

	TITLE	i:\projets\aes\aes\aes\c_aes_encode.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp__CryptEncrypt@28:PROC
EXTRN	__imp__CryptExportKey@24:PROC
EXTRN	__imp__CryptGetUserKey@12:PROC
EXTRN	__imp__CryptGenKey@16:PROC
PUBLIC	??0C_AES_Encode@@QAE@XZ				; C_AES_Encode::C_AES_Encode
PUBLIC	??1C_AES_Encode@@QAE@XZ				; C_AES_Encode::~C_AES_Encode
PUBLIC	?MyEncryptFile@C_AES_Encode@@QAE_NPA_W00@Z	; C_AES_Encode::MyEncryptFile
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1C_AES_Encode@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0C_AES_Encode@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0C_AES_Encode@@QAE@XZ$0
__ehfuncinfo$??0C_AES_Encode@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0C_AES_Encode@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp
;	COMDAT ?MyEncryptFile@C_AES_Encode@@QAE_NPA_W00@Z
_TEXT	SEGMENT
_hSourceFile$1$ = -40					; size = 4
_pszDestinationFile$GSCopy$1$ = -36			; size = 4
_pbKeyBlob$1$ = -36					; size = 4
_pbBuffer$1$ = -32					; size = 4
_hDestinationFile$1$ = -28				; size = 4
_fReturn$1$ = -21					; size = 1
_dwKeyBlobLen$ = -20					; size = 4
_hHash$ = -16						; size = 4
_dwCount$ = -12						; size = 4
_hXchgKey$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pszSourceFile$ = 8					; size = 4
_pszDestinationFile$ = 12				; size = 4
_pszPassword$ = 16					; size = 4
?MyEncryptFile@C_AES_Encode@@QAE_NPA_W00@Z PROC		; C_AES_Encode::MyEncryptFile, COMDAT
; _this$ = ecx

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _pszSourceFile$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _pszPassword$[ebp]
	push	esi
	push	edi

; 35   : 	//---------------------------------------------------------------
; 36   : 	// Declare and initialize local variables.
; 37   : 	bool fReturn = false;
; 38   : 	HANDLE hSourceFile = INVALID_HANDLE_VALUE;
; 39   : 	HANDLE hDestinationFile = INVALID_HANDLE_VALUE;
; 40   : 	HCRYPTKEY hXchgKey = NULL;
; 41   : 	HCRYPTHASH hHash = NULL;
; 42   : 	PBYTE pbKeyBlob = NULL;
; 43   : 	DWORD dwKeyBlobLen = 0;
; 44   : 	PBYTE pbBuffer = NULL;
; 45   : 	DWORD dwBlockLen;
; 46   : 	DWORD dwBufferLen;
; 47   : 	DWORD dwCount;
; 48   : 
; 49   : 	//---------------------------------------------------------------
; 50   : 	// Open the source file. 
; 51   : 	hSourceFile = CreateFile(

	mov	edi, DWORD PTR __imp__CreateFileW@28
	mov	esi, ecx
	mov	ecx, DWORD PTR _pszDestinationFile$[ebp]
	push	0
	push	128					; 00000080H
	push	3
	push	0
	push	1
	push	1
	push	eax
	mov	DWORD PTR _pszDestinationFile$GSCopy$1$[ebp], ecx
	mov	BYTE PTR _fReturn$1$[ebp], 0
	mov	DWORD PTR _hDestinationFile$1$[ebp], -1
	mov	DWORD PTR _hXchgKey$[ebp], 0
	mov	DWORD PTR _hHash$[ebp], 0
	mov	DWORD PTR _dwKeyBlobLen$[ebp], 0
	mov	DWORD PTR _pbBuffer$1$[ebp], 0
	call	edi
	mov	DWORD PTR _hSourceFile$1$[ebp], eax

; 52   : 		pszSourceFile,
; 53   : 		FILE_READ_DATA,
; 54   : 		FILE_SHARE_READ,
; 55   : 		NULL,
; 56   : 		OPEN_EXISTING,
; 57   : 		FILE_ATTRIBUTE_NORMAL,
; 58   : 		NULL);
; 59   : 
; 60   : 	if (INVALID_HANDLE_VALUE == hSourceFile)

	cmp	eax, -1
	jne	SHORT $LN5@MyEncryptF

; 61   : 	{
; 62   : 		BOOL status = Mess.LoadString(IDS_STRING132);

	push	132					; 00000084H
	lea	ecx, DWORD PTR [esi+4]
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	ebx, DWORD PTR [esi+4]

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [ebx-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN54@MyEncryptF

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [ebx-12]
	lea	ecx, DWORD PTR [esi+4]
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	ebx, DWORD PTR [esi+4]
$LN54@MyEncryptF:
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp

; 63   : 		pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());

	mov	edi, DWORD PTR __imp__GetLastError@0
	call	edi
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ebx
	call	?MyHandleError@C_Error_Message@@QAEXPA_WH@Z ; C_Error_Message::MyHandleError

; 308  : 
; 309  : 	fReturn = true;
; 310  : 
; 311  : Exit_MyEncryptFile:

	mov	eax, DWORD PTR _hSourceFile$1$[ebp]

; 315  : 	{
; 316  : 		CloseHandle(hSourceFile);

	mov	ebx, DWORD PTR __imp__CloseHandle@4
	push	eax
	call	ebx
	jmp	$LN43@MyEncryptF
$LN5@MyEncryptF:

; 64   : 		goto Exit_MyEncryptFile;
; 65   : 	}
; 66   : 	//---------------------------------------------------------------
; 67   : 	// =====> A VOIR DE PLUS PRES au lieu OPEN_ALWAYS de on peut metre CREATE_ALWAYS
; 68   : 	//
; 69   : 	// Open the destination file. 
; 70   : 	hDestinationFile = CreateFile(

	push	0
	push	128					; 00000080H
	push	2
	push	0
	push	1
	push	2
	push	DWORD PTR _pszDestinationFile$GSCopy$1$[ebp]
	call	edi
	mov	DWORD PTR _hDestinationFile$1$[ebp], eax

; 71   : 		pszDestinationFile,
; 72   : 		FILE_WRITE_DATA,
; 73   : 		FILE_SHARE_READ,
; 74   : 		NULL,
; 75   : 		CREATE_ALWAYS,
; 76   : 		FILE_ATTRIBUTE_NORMAL,
; 77   : 		NULL);
; 78   : 
; 79   : 	if (INVALID_HANDLE_VALUE == hDestinationFile)

	cmp	eax, -1
	jne	SHORT $LN7@MyEncryptF

; 80   : 	{
; 81   : 		BOOL status = Mess.LoadString(IDS_STRING133);

	push	133					; 00000085H

; 308  : 
; 309  : 	fReturn = true;
; 310  : 
; 311  : Exit_MyEncryptFile:

	jmp	$LN162@MyEncryptF
$LN7@MyEncryptF:

; 82   : 		pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());
; 83   : 		goto Exit_MyEncryptFile;
; 84   : 	}
; 85   : 	//---------------------------------------------------------------
; 86   : 	// Get the handle to the default provider. 
; 87   : 
; 88   : 	//---------------------------------------------------------------
; 89   : 	// Create the session key.
; 90   : 	if (!pszPassword || !pszPassword[0])

	mov	edi, DWORD PTR __imp__GetLastError@0
	test	ebx, ebx
	je	SHORT $LN11@MyEncryptF
	cmp	WORD PTR [ebx], 0
	je	SHORT $LN11@MyEncryptF

; 234  : 	}
; 235  : 	else
; 236  : 	{
; 237  : 		//-----------------------------------------------------------
; 238  : 		// The file will be encrypted with a session key derived 
; 239  : 		// from a password.
; 240  : 		// The session key will be recreated when the file is 
; 241  : 		// decrypted only if the password used to create the key is 
; 242  : 		// available. 
; 243  : 
; 244  : 		//-----------------------------------------------------------
; 245  : 		// Create a hash object. 
; 246  : 		CryptCreateHash(hCryptProv, _Hash, 0, 0, &hHash);

	lea	eax, DWORD PTR _hHash$[ebp]
	push	eax
	push	0
	push	0
	push	32772					; 00008004H
	push	DWORD PTR [esi+8]
	call	DWORD PTR __imp__CryptCreateHash@20

; 247  : 		
; 248  : 		//-----------------------------------------------------------
; 249  : 		// Hash the password. 
; 250  : 		CryptHashData(hHash, (BYTE *)pszPassword, lstrlen(pszPassword), 0);

	push	0
	push	ebx
	call	DWORD PTR __imp__lstrlenW@4
	push	eax
	push	ebx
	push	DWORD PTR _hHash$[ebp]
	call	DWORD PTR __imp__CryptHashData@16

; 251  : 
; 252  : 		//-----------------------------------------------------------
; 253  : 		// Derive a session key from the hash object. 
; 254  : 		CryptDeriveKey(hCryptProv, ENCRYPT_ALGORITHM, hHash, KEYLENGTH, &hKey);

	lea	eax, DWORD PTR [esi+12]
	push	eax
	push	4
	push	DWORD PTR _hHash$[ebp]
	push	26625					; 00006801H
	push	DWORD PTR [esi+8]
	call	DWORD PTR __imp__CryptDeriveKey@20
	jmp	$LN10@MyEncryptF
$LN11@MyEncryptF:

; 91   : 	{
; 92   : 		//-----------------------------------------------------------
; 93   : 		// No password was passed.
; 94   : 		// Encrypt the file with a random session key, and write the 
; 95   : 		// key to a file. 
; 96   : 
; 97   : 		//-----------------------------------------------------------
; 98   : 		// Create a random session key. 
; 99   : 		if (CryptGenKey(hCryptProv, ENCRYPT_ALGORITHM, KEYLENGTH | CRYPT_EXPORTABLE, &hKey))

	lea	ebx, DWORD PTR [esi+12]
	push	ebx
	push	5
	push	26625					; 00006801H
	push	DWORD PTR [esi+8]
	call	DWORD PTR __imp__CryptGenKey@16
	test	eax, eax
	je	$LN12@MyEncryptF

; 109  : 			pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());
; 110  : 			goto Exit_MyEncryptFile;
; 111  : 		}
; 112  : 		//-----------------------------------------------------------
; 113  : 		// Get the handle to the exchange public key. 
; 114  : 		if (CryptGetUserKey(hCryptProv, AT_KEYEXCHANGE, &hXchgKey))

	lea	eax, DWORD PTR _hXchgKey$[ebp]
	push	eax
	push	1
	push	DWORD PTR [esi+8]
	call	DWORD PTR __imp__CryptGetUserKey@12
	test	eax, eax
	jne	SHORT $LN19@MyEncryptF

; 115  : 		{
; 116  : #ifdef _DEBUG
; 117  : 			BOOL status =Mess.LoadString(IDS_STRING154);
; 118  : 			pt_Erreur->Print_Message(Mess);
; 119  : #endif
; 120  : 		}
; 121  : 		else
; 122  : 		{
; 123  : 			if (NTE_NO_KEY == GetLastError())

	call	edi
	cmp	eax, -2146893811			; 8009000dH
	jne	SHORT $LN17@MyEncryptF

; 124  : 			{
; 125  : 				// No exchange key exists. Try to create one.
; 126  : 				if (!CryptGenKey(hCryptProv, AT_KEYEXCHANGE, CRYPT_EXPORTABLE, &hXchgKey))

	lea	eax, DWORD PTR _hXchgKey$[ebp]
	push	eax
	push	1
	push	1
	push	DWORD PTR [esi+8]
	call	DWORD PTR __imp__CryptGenKey@16
	test	eax, eax
	jne	SHORT $LN19@MyEncryptF

; 127  : 				{
; 128  : 					BOOL status = Mess.LoadString(IDS_STRING155);

	push	155					; 0000009bH
$LN164@MyEncryptF:

; 312  : 	//---------------------------------------------------------------
; 313  : 	// Close files.
; 314  : 	if (hSourceFile)

	lea	ecx, DWORD PTR [esi+4]
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
	mov	ebx, DWORD PTR [esi+4]
	cmp	DWORD PTR [ebx-4], 1
	jle	$LN75@MyEncryptF
	push	DWORD PTR [ebx-12]
	lea	ecx, DWORD PTR [esi+4]
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	ebx, DWORD PTR [esi+4]
	jmp	$LN75@MyEncryptF
$LN17@MyEncryptF:

; 129  : 					pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());
; 130  : 					goto Exit_MyEncryptFile;
; 131  : 				}
; 132  : 			}
; 133  : 			else
; 134  : 			{
; 135  : 				BOOL status = Mess.LoadString(IDS_STRING156);

	push	156					; 0000009cH

; 308  : 
; 309  : 	fReturn = true;
; 310  : 
; 311  : Exit_MyEncryptFile:

	jmp	SHORT $LN164@MyEncryptF
$LN19@MyEncryptF:

; 136  : 				pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());
; 137  : 				goto Exit_MyEncryptFile;
; 138  : 			}
; 139  : 		}
; 140  : 		//-----------------------------------------------------------
; 141  : 		// Determine size of the key BLOB, and allocate memory. 
; 142  : 		if (CryptExportKey(hKey, hXchgKey, SIMPLEBLOB, 0, NULL, &dwKeyBlobLen))

	lea	eax, DWORD PTR _dwKeyBlobLen$[ebp]
	push	eax
	push	0
	push	0
	push	1
	push	DWORD PTR _hXchgKey$[ebp]
	push	DWORD PTR [ebx]
	call	DWORD PTR __imp__CryptExportKey@24
	test	eax, eax
	je	$LN22@MyEncryptF

; 154  : 			pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());
; 155  : 			goto Exit_MyEncryptFile;
; 156  : 		}
; 157  : 
; 158  : 		if (pbKeyBlob = (BYTE *)malloc(dwKeyBlobLen))

	push	DWORD PTR _dwKeyBlobLen$[ebp]
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbKeyBlob$1$[ebp], eax
	test	eax, eax
	je	$LN25@MyEncryptF

; 169  : 			goto Exit_MyEncryptFile;
; 170  : 		}
; 171  : 		//-----------------------------------------------------------
; 172  : 		// Encrypt and export the session key into a simple key 
; 173  : 		// BLOB. 
; 174  : 		if (CryptExportKey(hKey, hXchgKey, SIMPLEBLOB, 0, pbKeyBlob, &dwKeyBlobLen))

	lea	ecx, DWORD PTR _dwKeyBlobLen$[ebp]
	push	ecx
	push	eax
	push	0
	push	1
	push	DWORD PTR _hXchgKey$[ebp]
	push	DWORD PTR [ebx]
	call	DWORD PTR __imp__CryptExportKey@24
	test	eax, eax
	je	$LN28@MyEncryptF

; 184  : 			pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());
; 185  : 			goto Exit_MyEncryptFile;
; 186  : 		}
; 187  : 		//-----------------------------------------------------------
; 188  : 		// Release the key exchange key handle. 
; 189  : 		if (hXchgKey)

	mov	eax, DWORD PTR _hXchgKey$[ebp]
	test	eax, eax
	je	SHORT $LN31@MyEncryptF

; 190  : 		{
; 191  : 			if (!(CryptDestroyKey(hXchgKey)))

	push	eax
	call	DWORD PTR __imp__CryptDestroyKey@4
	test	eax, eax
	jne	SHORT $LN32@MyEncryptF

; 192  : 			{
; 193  : 				BOOL status = Mess.LoadString(IDS_STRING163);

	push	163					; 000000a3H

; 308  : 
; 309  : 	fReturn = true;
; 310  : 
; 311  : Exit_MyEncryptFile:

	jmp	$LN164@MyEncryptF
$LN32@MyEncryptF:

; 194  : 				pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());
; 195  : 				goto Exit_MyEncryptFile;
; 196  : 			}
; 197  : 
; 198  : 			hXchgKey = 0;

	mov	DWORD PTR _hXchgKey$[ebp], 0
$LN31@MyEncryptF:

; 199  : 		}
; 200  : 		//-----------------------------------------------------------
; 201  : 		// Write the size of the key BLOB to the destination file. 
; 202  : 		if (!WriteFile(hDestinationFile, &dwKeyBlobLen, sizeof(DWORD), &dwCount, NULL))

	push	0
	lea	eax, DWORD PTR _dwCount$[ebp]
	push	eax
	push	4
	lea	eax, DWORD PTR _dwKeyBlobLen$[ebp]
	push	eax
	push	DWORD PTR _hDestinationFile$1$[ebp]
	call	DWORD PTR __imp__WriteFile@20
	test	eax, eax
	jne	SHORT $LN34@MyEncryptF

; 203  : 		{
; 204  : 			BOOL status = Mess.LoadString(IDS_STRING164);

	push	164					; 000000a4H

; 308  : 
; 309  : 	fReturn = true;
; 310  : 
; 311  : Exit_MyEncryptFile:

	jmp	$LN164@MyEncryptF
$LN34@MyEncryptF:

; 205  : 			pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());
; 206  : 			goto Exit_MyEncryptFile;
; 207  : 		}
; 208  : 		else
; 209  : 		{
; 210  : #ifdef _DEBUG
; 211  : 			BOOL status =Mess.LoadString(IDS_STRING165);
; 212  : 			pt_Erreur->Print_Message(Mess);
; 213  : #endif
; 214  : 		}
; 215  : 
; 216  : 		//-----------------------------------------------------------
; 217  : 		// Write the key BLOB to the destination file. 
; 218  : 		if (!WriteFile(hDestinationFile, pbKeyBlob, dwKeyBlobLen, &dwCount, NULL))

	mov	ebx, DWORD PTR _pbKeyBlob$1$[ebp]
	lea	eax, DWORD PTR _dwCount$[ebp]
	push	0
	push	eax
	push	DWORD PTR _dwKeyBlobLen$[ebp]
	push	ebx
	push	DWORD PTR _hDestinationFile$1$[ebp]
	call	DWORD PTR __imp__WriteFile@20
	test	eax, eax
	jne	SHORT $LN37@MyEncryptF

; 219  : 		{
; 220  : 			BOOL status = Mess.LoadString(IDS_STRING166);

	push	166					; 000000a6H

; 221  : 			pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());
; 222  : 			goto Exit_MyEncryptFile;

	jmp	$LN164@MyEncryptF
$LN37@MyEncryptF:

; 223  : 		}
; 224  : 		else
; 225  : 		{
; 226  : #ifdef _DEBUG
; 227  : 			Mess.LoadString(IDS_STRING167);
; 228  : 			pt_Erreur->Print_Message(Mess);
; 229  : #endif
; 230  : 		}
; 231  : 
; 232  : 		// Free memory.
; 233  : 		free(pbKeyBlob);

	push	ebx
	call	_free
	add	esp, 4
$LN10@MyEncryptF:

; 255  : 
; 256  : 	}
; 257  : 	//---------------------------------------------------------------
; 258  : 	// The session key is now ready. If it is not a key derived from 
; 259  : 	// a  password, the session key encrypted with the private key 
; 260  : 	// has been written to the destination file.
; 261  : 
; 262  : 	//---------------------------------------------------------------
; 263  : 	// Determine the number of bytes to encrypt at a time. 
; 264  : 	// This must be a multiple of ENCRYPT_BLOCK_SIZE.
; 265  : 	// ENCRYPT_BLOCK_SIZE is set by a #define statement.
; 266  : 	dwBlockLen = 1000 - 1000 % ENCRYPT_BLOCK_SIZE;
; 267  : 	//---------------------------------------------------------------
; 268  : 	// Determine the block size. If a block cipher is used, 
; 269  : 	// it must have room for an extra block. 
; 270  : 	if (ENCRYPT_BLOCK_SIZE > 1)
; 271  : 	{
; 272  : 		dwBufferLen = dwBlockLen + ENCRYPT_BLOCK_SIZE;
; 273  : 	}
; 274  : 	else
; 275  : 	{
; 276  : 		dwBufferLen = dwBlockLen;
; 277  : 	}
; 278  : 	//---------------------------------------------------------------
; 279  : 	// Allocate memory. 
; 280  : 	pbBuffer = (BYTE *)malloc(dwBufferLen);

	push	1008					; 000003f0H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbBuffer$1$[ebp], eax

; 281  : 	//---------------------------------------------------------------
; 282  : 	// In a do loop, encrypt the source file, 
; 283  : 	// and write to the source file. 
; 284  : 	bool fEOF = FALSE;

	xor	bl, bl

; 302  : 
; 303  : 		//-----------------------------------------------------------
; 304  : 		// End the do loop when the last block of the source file 
; 305  : 		// has been read, encrypted, and written to the destination 
; 306  : 		// file.
; 307  : 	} while (!fEOF);

	jmp	SHORT $LN4@MyEncryptF
$LL158@MyEncryptF:
	mov	eax, DWORD PTR _pbBuffer$1$[ebp]
$LN4@MyEncryptF:

; 285  : 	do
; 286  : 	{
; 287  : 		//-----------------------------------------------------------
; 288  : 		// Read up to dwBlockLen bytes from the source file. 
; 289  : 		BOOL Status = ReadFile(hSourceFile, pbBuffer, dwBlockLen, &dwCount, NULL);

	push	0
	lea	ecx, DWORD PTR _dwCount$[ebp]
	push	ecx
	push	1000					; 000003e8H
	push	eax
	push	DWORD PTR _hSourceFile$1$[ebp]
	call	DWORD PTR __imp__ReadFile@20

; 290  : 
; 291  : 		if (dwCount < dwBlockLen)

	cmp	DWORD PTR _dwCount$[ebp], 1000		; 000003e8H
	mov	eax, 1

; 292  : 		{
; 293  : 			fEOF = TRUE;
; 294  : 		}
; 295  : 		//-----------------------------------------------------------
; 296  : 		// Encrypt data. 
; 297  : 		CryptEncrypt(hKey, NULL, fEOF, 0, pbBuffer, &dwCount, dwBufferLen);

	push	1008					; 000003f0H
	movzx	ebx, bl
	cmovb	ebx, eax
	lea	eax, DWORD PTR _dwCount$[ebp]
	push	eax
	push	DWORD PTR _pbBuffer$1$[ebp]
	movzx	eax, bl
	push	0
	push	eax
	push	0
	push	DWORD PTR [esi+12]
	call	DWORD PTR __imp__CryptEncrypt@28

; 298  : 	
; 299  : 		//-----------------------------------------------------------
; 300  : 		// Write the encrypted data to the destination file. 
; 301  : 		WriteFile(hDestinationFile, pbBuffer, dwCount, &dwCount, NULL);

	push	0
	lea	eax, DWORD PTR _dwCount$[ebp]
	push	eax
	push	DWORD PTR _dwCount$[ebp]
	push	DWORD PTR _pbBuffer$1$[ebp]
	push	DWORD PTR _hDestinationFile$1$[ebp]
	call	DWORD PTR __imp__WriteFile@20

; 302  : 
; 303  : 		//-----------------------------------------------------------
; 304  : 		// End the do loop when the last block of the source file 
; 305  : 		// has been read, encrypted, and written to the destination 
; 306  : 		// file.
; 307  : 	} while (!fEOF);

	test	bl, bl
	je	SHORT $LL158@MyEncryptF

; 308  : 
; 309  : 	fReturn = true;
; 310  : 
; 311  : Exit_MyEncryptFile:

	mov	edi, DWORD PTR __imp__GetLastError@0
	mov	BYTE PTR _fReturn$1$[ebp], 1
	jmp	SHORT $Exit_MyEncryptFile$166
$LN28@MyEncryptF:

; 175  : 		{
; 176  : #ifdef _DEBUG
; 177  : 			BOOL status =Mess.LoadString(IDS_STRING161);
; 178  : 			pt_Erreur->Print_Message(Mess);
; 179  : #endif
; 180  : 		}
; 181  : 		else
; 182  : 		{
; 183  : 			BOOL status = Mess.LoadString(IDS_STRING162);

	push	162					; 000000a2H

; 308  : 
; 309  : 	fReturn = true;
; 310  : 
; 311  : Exit_MyEncryptFile:

	jmp	$LN164@MyEncryptF
$LN25@MyEncryptF:

; 159  : 		{
; 160  : #ifdef _DEBUG
; 161  : 			BOOL status =Mess.LoadString(IDS_STRING159);
; 162  : 			pt_Erreur->Print_Message(Mess);
; 163  : #endif
; 164  : 		}
; 165  : 		else
; 166  : 		{
; 167  : 			BOOL status = Mess.LoadString(IDS_STRING160);

	push	160					; 000000a0H
	lea	ecx, DWORD PTR [esi+4]
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	eax, DWORD PTR [esi+4]

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [eax-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN96@MyEncryptF

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [eax-12]
	lea	ecx, DWORD PTR [esi+4]
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	eax, DWORD PTR [esi+4]
$LN96@MyEncryptF:
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp

; 168  : 			pt_Erreur->MyHandleError(Mess.GetBuffer(), E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	push	eax

; 308  : 
; 309  : 	fReturn = true;
; 310  : 
; 311  : Exit_MyEncryptFile:

	jmp	SHORT $LN163@MyEncryptF
$LN22@MyEncryptF:

; 143  : 		{
; 144  : #ifdef _DEBUG
; 145  : 			CString Local_string;
; 146  : 			BOOL status = Mess.LoadString(IDS_STRING157);
; 147  : 			Local_string.Format(Mess, dwKeyBlobLen);
; 148  : 			pt_Erreur->Print_Message(Local_string);
; 149  : #endif
; 150  : 		}
; 151  : 		else
; 152  : 		{
; 153  : 			BOOL status = Mess.LoadString(IDS_STRING158);

	push	158					; 0000009eH

; 308  : 
; 309  : 	fReturn = true;
; 310  : 
; 311  : Exit_MyEncryptFile:

	jmp	$LN164@MyEncryptF
$LN12@MyEncryptF:

; 100  : 		{
; 101  : #ifdef _DEBUG
; 102  : 			Mess.LoadString(IDS_STRING152);
; 103  : 			pt_Erreur->Print_Message(Mess);
; 104  : #endif
; 105  : 		}
; 106  : 		else
; 107  : 		{
; 108  : 			BOOL status = Mess.LoadString(IDS_STRING153);

	push	153					; 00000099H
$LN162@MyEncryptF:

; 312  : 	//---------------------------------------------------------------
; 313  : 	// Close files.
; 314  : 	if (hSourceFile)

	lea	ecx, DWORD PTR [esi+4]
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
	mov	ebx, DWORD PTR [esi+4]
	cmp	DWORD PTR [ebx-4], 1
	jle	SHORT $LN68@MyEncryptF
	push	DWORD PTR [ebx-12]
	lea	ecx, DWORD PTR [esi+4]
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	ebx, DWORD PTR [esi+4]
$LN68@MyEncryptF:
	mov	edi, DWORD PTR __imp__GetLastError@0
$LN75@MyEncryptF:
	call	edi
	push	eax
	push	ebx
$LN163@MyEncryptF:
	mov	ecx, DWORD PTR [esi]
	call	?MyHandleError@C_Error_Message@@QAEXPA_WH@Z ; C_Error_Message::MyHandleError
$Exit_MyEncryptFile$166:
	mov	eax, DWORD PTR _hSourceFile$1$[ebp]
	test	eax, eax
	je	SHORT $LN159@MyEncryptF

; 315  : 	{
; 316  : 		CloseHandle(hSourceFile);

	mov	ebx, DWORD PTR __imp__CloseHandle@4
	push	eax
	call	ebx
	jmp	SHORT $LN43@MyEncryptF
$LN159@MyEncryptF:

; 312  : 	//---------------------------------------------------------------
; 313  : 	// Close files.
; 314  : 	if (hSourceFile)

	mov	ebx, DWORD PTR __imp__CloseHandle@4
$LN43@MyEncryptF:

; 317  : 	}
; 318  : 	if (hDestinationFile)

	mov	eax, DWORD PTR _hDestinationFile$1$[ebp]
	test	eax, eax
	je	SHORT $LN44@MyEncryptF

; 319  : 	{
; 320  : 		CloseHandle(hDestinationFile);

	push	eax
	call	ebx
$LN44@MyEncryptF:

; 321  : 	}
; 322  : 	//---------------------------------------------------------------
; 323  : 	// Free memory. 
; 324  : 	if (pbBuffer)

	mov	eax, DWORD PTR _pbBuffer$1$[ebp]
	test	eax, eax
	je	SHORT $LN45@MyEncryptF

; 325  : 	{
; 326  : 		free(pbBuffer);

	push	eax
	call	_free
	add	esp, 4
$LN45@MyEncryptF:

; 327  : 	}
; 328  : 	//-----------------------------------------------------------
; 329  : 	// Release the hash object. 
; 330  : 	if (hHash)

	mov	eax, DWORD PTR _hHash$[ebp]
	test	eax, eax
	je	SHORT $LN46@MyEncryptF

; 331  : 	{
; 332  : 		if (!(CryptDestroyHash(hHash)))

	push	eax
	call	DWORD PTR __imp__CryptDestroyHash@4
	test	eax, eax
	jne	SHORT $LN47@MyEncryptF

; 333  : 		{
; 334  : 			BOOL status = Mess.LoadString(IDS_STRING163);

	push	163					; 000000a3H
	lea	ecx, DWORD PTR [esi+4]
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	ebx, DWORD PTR [esi+4]

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [ebx-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN131@MyEncryptF

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [ebx-12]
	lea	ecx, DWORD PTR [esi+4]
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	ebx, DWORD PTR [esi+4]
$LN131@MyEncryptF:
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp

; 335  : 			pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());

	call	edi
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ebx
	call	?MyHandleError@C_Error_Message@@QAEXPA_WH@Z ; C_Error_Message::MyHandleError
$LN47@MyEncryptF:

; 336  : 		}
; 337  : 
; 338  : 		hHash = NULL;

	mov	DWORD PTR _hHash$[ebp], 0
$LN46@MyEncryptF:

; 339  : 	}
; 340  : 	//---------------------------------------------------------------
; 341  : 	// Release the session key. 
; 342  : 	if (hKey)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN49@MyEncryptF

; 343  : 	{
; 344  : 		if (!(CryptDestroyKey(hKey)))

	push	eax
	call	DWORD PTR __imp__CryptDestroyKey@4
	test	eax, eax
	jne	SHORT $LN49@MyEncryptF

; 345  : 		{
; 346  : 			BOOL status = Mess.LoadString(IDS_STRING177);

	push	177					; 000000b1H
	lea	ecx, DWORD PTR [esi+4]
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	ebx, DWORD PTR [esi+4]

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [ebx-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN138@MyEncryptF

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [ebx-12]
	lea	ecx, DWORD PTR [esi+4]
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	ebx, DWORD PTR [esi+4]
$LN138@MyEncryptF:
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp

; 347  : 			pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());

	call	edi
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ebx
	call	?MyHandleError@C_Error_Message@@QAEXPA_WH@Z ; C_Error_Message::MyHandleError
$LN49@MyEncryptF:

; 348  : 		}
; 349  : 	}
; 350  : 	//---------------------------------------------------------------
; 351  : 	// Release the provider handle. 
; 352  : 	if (hCryptProv)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN156@MyEncryptF

; 353  : 	{
; 354  : 		if (!(CryptReleaseContext(hCryptProv, 0)))

	push	0
	push	eax
	call	DWORD PTR __imp__CryptReleaseContext@8
	test	eax, eax
	jne	SHORT $LN156@MyEncryptF

; 355  : 		{
; 356  : 			BOOL status = Mess.LoadString(IDS_STRING178);

	push	178					; 000000b2H
	lea	ecx, DWORD PTR [esi+4]
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	eax, DWORD PTR [esi+4]

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [eax-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN157@MyEncryptF

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [eax-12]
	lea	ecx, DWORD PTR [esi+4]
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	ebx, DWORD PTR [esi+4]
	jmp	SHORT $LN145@MyEncryptF
$LN157@MyEncryptF:

; 74   : 	}
; 75   : 	void Lock() throw()
; 76   : 	{
; 77   : 		ATLASSERT( nRefs <= 1 );
; 78   : 		nRefs--;  // Locked buffers can't be shared, so no interlocked operation necessary
; 79   : 		if( nRefs == 0 )
; 80   : 		{
; 81   : 			nRefs = -1;
; 82   : 		}
; 83   : 	}
; 84   : 	void Release() throw()
; 85   : 	{
; 86   : 		ATLASSERT( nRefs != 0 );
; 87   : 
; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )
; 89   : 		{
; 90   : 			pStringMgr->Free( this );
; 91   : 		}
; 92   : 	}
; 93   : 	void Unlock() throw()
; 94   : 	{
; 95   : 		ATLASSERT( IsLocked() );
; 96   : 
; 97   : 		if(IsLocked())
; 98   : 		{
; 99   : 			nRefs++;  // Locked buffers can't be shared, so no interlocked operation necessary
; 100  : 			if( nRefs == 0 )
; 101  : 			{
; 102  : 				nRefs = 1;
; 103  : 			}
; 104  : 		}
; 105  : 	}
; 106  : };
; 107  : 
; 108  : class CNilStringData :
; 109  : 	public CStringData
; 110  : {
; 111  : public:
; 112  : 	CNilStringData() throw()
; 113  : 	{
; 114  : 		pStringMgr = NULL;
; 115  : 		nRefs = 2;  // Never gets freed by IAtlStringMgr
; 116  : 		nDataLength = 0;
; 117  : 		nAllocLength = 0;
; 118  : 		achNil[0] = 0;
; 119  : 		achNil[1] = 0;
; 120  : 	}
; 121  : 
; 122  : 	void SetManager(_In_ IAtlStringMgr* pMgr) throw()
; 123  : 	{
; 124  : 		ATLASSERT( pStringMgr == NULL );
; 125  : 		pStringMgr = pMgr;
; 126  : 	}
; 127  : 
; 128  : public:
; 129  : 	wchar_t achNil[2];
; 130  : };
; 131  : 
; 132  : template< typename BaseType, const int t_nSize >
; 133  : class CStaticString
; 134  : {
; 135  : public:
; 136  : 	CStaticString(_In_z_ const BaseType* psz) :
; 137  : 		m_psz( psz )
; 138  : 	{
; 139  : 	}
; 140  : 
; 141  : 	operator const BaseType*() const
; 142  : 	{
; 143  : 		return m_psz;
; 144  : 	}
; 145  : 
; 146  : 	static int __cdecl GetLength()
; 147  : 	{
; 148  : 		return (t_nSize/sizeof( BaseType ))-1;
; 149  : 	}
; 150  : 
; 151  : private:
; 152  : 	const BaseType* m_psz;
; 153  : 
; 154  : private:
; 155  : 	CStaticString(_In_ const CStaticString& str) throw();
; 156  : 	CStaticString& operator=(_In_ const CStaticString& str) throw();
; 157  : };
; 158  : 
; 159  : #define _ST( psz ) ATL::CStaticString< TCHAR, sizeof( _T( psz ) ) >( _T( psz ) )
; 160  : #define _SA( psz ) ATL::CStaticString< char, sizeof( psz ) >( psz )
; 161  : #define _SW( psz ) ATL::CStaticString< wchar_t, sizeof( L##psz ) >( L##psz )
; 162  : #define _SO( psz ) _SW( psz )
; 163  : 
; 164  : template< typename BaseType = char >
; 165  : class ChTraitsBase
; 166  : {
; 167  : public:
; 168  : 	typedef char XCHAR;
; 169  : 	typedef LPSTR PXSTR;
; 170  : 	typedef LPCSTR PCXSTR;
; 171  : 	typedef wchar_t YCHAR;
; 172  : 	typedef LPWSTR PYSTR;
; 173  : 	typedef LPCWSTR PCYSTR;
; 174  : };
; 175  : 
; 176  : template<>
; 177  : class ChTraitsBase< wchar_t >
; 178  : {
; 179  : public:
; 180  : 	typedef wchar_t XCHAR;
; 181  : 	typedef LPWSTR PXSTR;
; 182  : 	typedef LPCWSTR PCXSTR;
; 183  : 	typedef char YCHAR;
; 184  : 	typedef LPSTR PYSTR;
; 185  : 	typedef LPCSTR PCYSTR;
; 186  : };
; 187  : 
; 188  : template< typename TCharType, bool t_bMFCDLL = false >
; 189  : class CStrBufT;
; 190  : 
; 191  : template< typename BaseType , bool t_bMFCDLL = false>
; 192  : class CSimpleStringT
; 193  : {
; 194  : public:
; 195  : 	typedef typename ChTraitsBase< BaseType >::XCHAR XCHAR;
; 196  : 	typedef typename ChTraitsBase< BaseType >::PXSTR PXSTR;
; 197  : 	typedef typename ChTraitsBase< BaseType >::PCXSTR PCXSTR;
; 198  : 	typedef typename ChTraitsBase< BaseType >::YCHAR YCHAR;
; 199  : 	typedef typename ChTraitsBase< BaseType >::PYSTR PYSTR;
; 200  : 	typedef typename ChTraitsBase< BaseType >::PCYSTR PCYSTR;
; 201  : 
; 202  : public:
; 203  : 	explicit CSimpleStringT(_Inout_ IAtlStringMgr* pStringMgr)
; 204  : 	{
; 205  : 		ATLENSURE( pStringMgr != NULL );
; 206  : 		CStringData* pData = pStringMgr->GetNilString();
; 207  : 		Attach( pData );
; 208  : 	}
; 209  : 
; 210  : 	CSimpleStringT(_In_ const CSimpleStringT& strSrc)
; 211  : 	{
; 212  : 		CStringData* pSrcData = strSrc.GetData();
; 213  : 		CStringData* pNewData = CloneData( pSrcData );
; 214  : 		Attach( pNewData );
; 215  : 	}
; 216  : 
; 217  : 	CSimpleStringT(_In_ const CSimpleStringT<BaseType, !t_bMFCDLL>& strSrc)
; 218  : 	{
; 219  : 		CStringData* pSrcData = strSrc.GetData();
; 220  : 		CStringData* pNewData = CloneData( pSrcData );
; 221  : 		Attach( pNewData );
; 222  : 	}
; 223  : 
; 224  : 	CSimpleStringT(
; 225  : 		_In_z_ PCXSTR pszSrc,
; 226  : 		_Inout_ IAtlStringMgr* pStringMgr)
; 227  : 	{
; 228  : 		ATLENSURE( pStringMgr != NULL );
; 229  : 
; 230  : 		int nLength = StringLength( pszSrc );
; 231  : 		CStringData* pData = pStringMgr->Allocate( nLength, sizeof( XCHAR ) );
; 232  : 		if( pData == NULL )
; 233  : 		{
; 234  : 			ThrowMemoryException();
; 235  : 		}
; 236  : 		Attach( pData );
; 237  : 		SetLength( nLength );
; 238  : 		CopyChars( m_pszData, nLength, pszSrc, nLength );
; 239  : 	}
; 240  : 	CSimpleStringT(
; 241  : 		_In_reads_(nLength) const XCHAR* pchSrc,
; 242  : 		_In_ int nLength,
; 243  : 		_Inout_ IAtlStringMgr* pStringMgr)
; 244  : 	{
; 245  : 		ATLENSURE( pStringMgr != NULL );
; 246  : 
; 247  : 		if(pchSrc == NULL && nLength != 0)
; 248  : 			AtlThrow(E_INVALIDARG);
; 249  : 
; 250  : 		CStringData* pData = pStringMgr->Allocate( nLength, sizeof( XCHAR ) );
; 251  : 		if( pData == NULL )
; 252  : 		{
; 253  : 			ThrowMemoryException();
; 254  : 		}
; 255  : 		Attach( pData );
; 256  : 		SetLength( nLength );
; 257  : 		CopyChars( m_pszData, nLength, pchSrc, nLength );
; 258  : 	}
; 259  : 	~CSimpleStringT() throw()
; 260  : 	{
; 261  : 		CStringData* pData = GetData();
; 262  : 		pData->Release();
; 263  : 	}
; 264  : 
; 265  : 	operator CSimpleStringT<BaseType, !t_bMFCDLL>&()
; 266  : 	{
; 267  : 		return *(CSimpleStringT<BaseType, !t_bMFCDLL>*)this;
; 268  : 	}
; 269  : 
; 270  : 	CSimpleStringT& operator=(_In_ const CSimpleStringT& strSrc)
; 271  : 	{
; 272  : 		CStringData* pSrcData = strSrc.GetData();
; 273  : 		CStringData* pOldData = GetData();
; 274  : 		if( pSrcData != pOldData)
; 275  : 		{
; 276  : 			if( pOldData->IsLocked() || pSrcData->pStringMgr != pOldData->pStringMgr )
; 277  : 			{
; 278  : 				SetString( strSrc.GetString(), strSrc.GetLength() );
; 279  : 			}
; 280  : 			else
; 281  : 			{
; 282  : 				CStringData* pNewData = CloneData( pSrcData );
; 283  : 				pOldData->Release();
; 284  : 				Attach( pNewData );
; 285  : 			}
; 286  : 		}
; 287  : 
; 288  : 		return( *this );
; 289  : 	}
; 290  : 
; 291  : 	CSimpleStringT& operator=(_In_ const CSimpleStringT<BaseType, !t_bMFCDLL>& strSrc)
; 292  : 	{
; 293  : 		CStringData* pSrcData = strSrc.GetData();
; 294  : 		CStringData* pOldData = GetData();
; 295  : 		if( pSrcData != pOldData)
; 296  : 		{
; 297  : 			if( pOldData->IsLocked() || pSrcData->pStringMgr != pOldData->pStringMgr )
; 298  : 			{
; 299  : 				SetString( strSrc.GetString(), strSrc.GetLength() );
; 300  : 			}
; 301  : 			else
; 302  : 			{
; 303  : 				CStringData* pNewData = CloneData( pSrcData );
; 304  : 				pOldData->Release();
; 305  : 				Attach( pNewData );
; 306  : 			}
; 307  : 		}
; 308  : 
; 309  : 		return( *this );
; 310  : 	}
; 311  : 
; 312  : 	CSimpleStringT& operator=(_In_opt_z_ PCXSTR pszSrc)
; 313  : 	{
; 314  : 		SetString( pszSrc );
; 315  : 
; 316  : 		return( *this );
; 317  : 	}
; 318  : 
; 319  : 	CSimpleStringT& operator+=(_In_ const CSimpleStringT& strSrc)
; 320  : 	{
; 321  : 		Append( strSrc );
; 322  : 
; 323  : 		return( *this );
; 324  : 	}
; 325  : 	template <bool bMFCDLL>
; 326  : 	CSimpleStringT& operator+=(_In_ const CSimpleStringT<BaseType, bMFCDLL>& strSrc)
; 327  : 	{
; 328  : 		Append( strSrc );
; 329  : 
; 330  : 		return( *this );
; 331  : 	}
; 332  : 
; 333  : 	CSimpleStringT& operator+=(_In_z_ PCXSTR pszSrc)
; 334  : 	{
; 335  : 		Append( pszSrc );
; 336  : 
; 337  : 		return( *this );
; 338  : 	}
; 339  : 	template< int t_nSize >
; 340  : 	CSimpleStringT& operator+=(_In_ const CStaticString< XCHAR, t_nSize >& strSrc)
; 341  : 	{
; 342  : 		Append( static_cast<const XCHAR *>(strSrc), strSrc.GetLength() );
; 343  : 
; 344  : 		return( *this );
; 345  : 	}
; 346  : 	CSimpleStringT& operator+=(_In_ char ch)
; 347  : 	{
; 348  : 		AppendChar( XCHAR( ch ) );
; 349  : 
; 350  : 		return( *this );
; 351  : 	}
; 352  : 	CSimpleStringT& operator+=(_In_ unsigned char ch)
; 353  : 	{
; 354  : 		AppendChar( XCHAR( ch ) );
; 355  : 
; 356  : 		return( *this );
; 357  : 	}
; 358  : 	CSimpleStringT& operator+=(_In_ wchar_t ch)
; 359  : 	{
; 360  : 		AppendChar( XCHAR( ch ) );
; 361  : 
; 362  : 		return( *this );
; 363  : 	}
; 364  : 
; 365  : 	XCHAR operator[](_In_ int iChar) const
; 366  : 	{
; 367  : 		ATLASSERT( (iChar >= 0) && (iChar <= GetLength()) );  // Indexing the '\0' is OK
; 368  : 
; 369  : 		if( (iChar < 0) || (iChar > GetLength()) )
; 370  : 			AtlThrow(E_INVALIDARG);
; 371  : 
; 372  : 		return( m_pszData[iChar] );
; 373  : 	}
; 374  : 
; 375  : 	operator PCXSTR() const throw()
; 376  : 	{
; 377  : 		return( m_pszData );
; 378  : 	}
; 379  : 
; 380  : 	void Append(_In_z_ PCXSTR pszSrc)
; 381  : 	{
; 382  : 		Append( pszSrc, StringLength( pszSrc ) );
; 383  : 	}
; 384  : 	void Append(
; 385  : 		_In_reads_(nLength) PCXSTR pszSrc,
; 386  : 		_In_ int nLength)
; 387  : 	{
; 388  : 		// See comment in SetString() about why we do this
; 389  : 		UINT_PTR nOffset = pszSrc-GetString();
; 390  : 
; 391  : 		UINT nOldLength = GetLength();
; 392  : 		if (nOldLength < 0)
; 393  : 		{
; 394  : 			// protects from underflow
; 395  : 			nOldLength = 0;
; 396  : 		}
; 397  : 
; 398  : 		//Make sure the nLength is greater than zero
; 399  : 		ATLENSURE_THROW(nLength >=0, E_INVALIDARG);
; 400  : 
; 401  : 		//Make sure we don't read pass end of the terminating NULL
; 402  : 		nLength = StringLengthN(pszSrc, nLength);
; 403  : 
; 404  : 		//Make sure after the string doesn't exceed INT_MAX after appending
; 405  : 		ATLENSURE_THROW(INT_MAX - nLength >= static_cast<int>(nOldLength), E_INVALIDARG);
; 406  : 
; 407  : 		int nNewLength = nOldLength+nLength;
; 408  : 		PXSTR pszBuffer = GetBuffer( nNewLength );
; 409  : 		if( nOffset <= nOldLength )
; 410  : 		{
; 411  : 			pszSrc = pszBuffer+nOffset;
; 412  : 			// No need to call CopyCharsOverlapped, since the destination is
; 413  : 			// beyond the end of the original buffer
; 414  : 		}
; 415  : 		CopyChars( pszBuffer+nOldLength, nLength, pszSrc, nLength );
; 416  : 		ReleaseBufferSetLength( nNewLength );
; 417  : 	}
; 418  : 	void AppendChar(_In_ XCHAR ch)
; 419  : 	{
; 420  : 		UINT nOldLength = GetLength();
; 421  : 		int nNewLength = nOldLength+1;
; 422  : 		PXSTR pszBuffer = GetBuffer( nNewLength );
; 423  : 		pszBuffer[nOldLength] = ch;
; 424  : 		ReleaseBufferSetLength( nNewLength );
; 425  : 	}
; 426  : 	void Append(_In_ const CSimpleStringT& strSrc)
; 427  : 	{
; 428  : 		Append( strSrc.GetString(), strSrc.GetLength() );
; 429  : 	}
; 430  : 	template <bool bMFCDLL>
; 431  : 	void Append(_In_ const CSimpleStringT<BaseType, bMFCDLL>& strSrc)
; 432  : 	{
; 433  : 		Append( strSrc.GetString(), strSrc.GetLength() );
; 434  : 	}
; 435  : 	void Empty() throw()
; 436  : 	{
; 437  : 		CStringData* pOldData = GetData();
; 438  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
; 439  : 		if( pOldData->nDataLength == 0 )
; 440  : 		{
; 441  : 			return;
; 442  : 		}
; 443  : 
; 444  : 		if( pOldData->IsLocked() )
; 445  : 		{
; 446  : 			// Don't reallocate a locked buffer that's shrinking
; 447  : 			SetLength( 0 );
; 448  : 		}
; 449  : 		else
; 450  : 		{
; 451  : 			pOldData->Release();
; 452  : 			CStringData* pNewData = pStringMgr->GetNilString();
; 453  : 			Attach( pNewData );
; 454  : 		}
; 455  : 	}
; 456  : 	void FreeExtra()
; 457  : 	{
; 458  : 		CStringData* pOldData = GetData();
; 459  : 		int nLength = pOldData->nDataLength;
; 460  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
; 461  : 		if( pOldData->nAllocLength == nLength )
; 462  : 		{
; 463  : 			return;
; 464  : 		}
; 465  : 
; 466  : 		if( !pOldData->IsLocked() )  // Don't reallocate a locked buffer that's shrinking
; 467  : 		{
; 468  : 			CStringData* pNewData = pStringMgr->Allocate( nLength, sizeof( XCHAR ) );
; 469  : 			if( pNewData == NULL )
; 470  : 			{
; 471  : 				SetLength( nLength );
; 472  : 				return;
; 473  : 			}
; 474  : 
; 475  : 			CopyChars( PXSTR( pNewData->data() ), nLength,
; 476  : 				PCXSTR( pOldData->data() ), nLength );
; 477  : 
; 478  : 			pOldData->Release();
; 479  : 			Attach( pNewData );
; 480  : 			SetLength( nLength );
; 481  : 		}
; 482  : 	}
; 483  : 
; 484  : 	int GetAllocLength() const throw()
; 485  : 	{
; 486  : 		return( GetData()->nAllocLength );
; 487  : 	}
; 488  : 	XCHAR GetAt(_In_ int iChar) const
; 489  : 	{
; 490  : 		ATLASSERT( (iChar >= 0) && (iChar <= GetLength()) );  // Indexing the '\0' is OK
; 491  : 		if( (iChar < 0) || (iChar > GetLength()) )
; 492  : 			AtlThrow(E_INVALIDARG);
; 493  : 
; 494  : 		return( m_pszData[iChar] );
; 495  : 	}
; 496  : 	PXSTR GetBuffer()
; 497  : 	{
; 498  : 		CStringData* pData = GetData();
; 499  : 		if( pData->IsShared() )

	mov	ebx, eax
$LN145@MyEncryptF:
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp

; 357  : 			pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());

	call	edi
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ebx
	call	?MyHandleError@C_Error_Message@@QAEXPA_WH@Z ; C_Error_Message::MyHandleError
$LN156@MyEncryptF:

; 358  : 		}
; 359  : 	}
; 360  : 	return fReturn;
; 361  : } // End Encryptfile.

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	al, BYTE PTR _fReturn$1$[ebp]
	xor	ecx, ebp
	pop	edi
	pop	esi
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MyEncryptFile@C_AES_Encode@@QAE_NPA_W00@Z ENDP		; C_AES_Encode::MyEncryptFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp
;	COMDAT ??1C_AES_Encode@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1C_AES_Encode@@QAE@XZ PROC				; C_AES_Encode::~C_AES_Encode, COMDAT
; _this$ = ecx

; 19   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1C_AES_Encode@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx

; 20   : 	delete pt_Erreur;

	mov	edi, DWORD PTR [ebx]
	or	esi, -1
	test	edi, edi
	je	SHORT $LN6@C_AES_Enco
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [edi]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, esi

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN18@C_AES_Enco

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN18@C_AES_Enco:
	push	4
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@C_AES_Enco:

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [ebx+4]
	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], esi
	dec	esi
	test	esi, esi
	jg	SHORT $LN27@C_AES_Enco

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN27@C_AES_Enco:
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp

; 22   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1C_AES_Encode@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1C_AES_Encode@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1C_AES_Encode@@QAE@XZ ENDP				; C_AES_Encode::~C_AES_Encode
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp
; File I:\Projets\AES\AES\AES\C_AES_Encode.h
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp
;	COMDAT ??0C_AES_Encode@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0C_AES_Encode@@QAE@XZ PROC				; C_AES_Encode::C_AES_Encode, COMDAT
; _this$ = ecx

; 11   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0C_AES_Encode@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN52@C_AES_Enco

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [esi+4], eax
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp

; 11   : {

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File I:\Projets\AES\AES\AES\C_AES_Encode.h

; 15   : 		HCRYPTPROV hCryptProv = NULL;

	lea	ebx, DWORD PTR [esi+8]
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp

; 12   : 	pt_Erreur = new C_Error_Message;

	push	4
	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	SHORT $LN3@C_AES_Enco
	mov	DWORD PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 1006 : 		CThisSimpleString( StringTraits::GetDefaultManager() )

	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	SHORT $LN53@C_AES_Enco

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [edi], eax
; File I:\Projets\AES\AES\AES\C_AES_Encode.cpp

; 12   : 	pt_Erreur = new C_Error_Message;

	jmp	SHORT $LN4@C_AES_Enco
$LN3@C_AES_Enco:
	xor	edi, edi
$LN4@C_AES_Enco:

; 13   : 	CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0);

	push	0
	push	1
	push	OFFSET ??_C@_1FO@GBKEFGLF@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAE?$AAn?$AAh?$AAa?$AAn@
	push	0
	push	ebx
	mov	DWORD PTR [esi], edi
	call	DWORD PTR __imp__CryptAcquireContextW@20

; 15   : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@C_AES_Enco:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN53@C_AES_Enco:
	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN50@C_AES_Enco:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0C_AES_Encode@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__ehhandler$??0C_AES_Encode@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0C_AES_Encode@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0C_AES_Encode@@QAE@XZ ENDP				; C_AES_Encode::C_AES_Encode
END
