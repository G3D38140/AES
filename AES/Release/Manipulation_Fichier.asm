; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28106.4 

	TITLE	i:\projets\aes\aes\aes\manipulation_fichier.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_01LFCBOECM@?4@				; `string'
EXTRN	__wcslwr_s:PROC
EXTRN	?ConvertStringToBSTR@_com_util@@YGPA_WPBD@Z:PROC ; _com_util::ConvertStringToBSTR
EXTRN	__imp__SysAllocString@4:PROC
EXTRN	__imp__SysStringLen@4:PROC
EXTRN	__imp__SysAllocStringByteLen@8:PROC
EXTRN	?_com_issue_error@@YGXJ@Z:PROC			; _com_issue_error
EXTRN	__imp__SysFreeString@4:PROC
EXTRN	?GetFileTitle@CFile@@UBE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ:PROC ; CFile::GetFileTitle
EXTRN	??0CFile@@QAE@PB_WI@Z:PROC			; CFile::CFile
EXTRN	?GetFileName@CFile@@UBE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ:PROC ; CFile::GetFileName
EXTRN	__imp__PathFileExistsW@4:PROC
;	COMDAT ??_C@_01LFCBOECM@?4@
CONST	SEGMENT
??_C@_01LFCBOECM@?4@ DB '.', 00H			; `string'
PUBLIC	??8ATL@@YA_NABV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@0@0@Z ; ATL::operator==
PUBLIC	??HATL@@YA?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@0@PB_WABV10@@Z ; ATL::operator+
PUBLIC	??B_bstr_t@@QBEPB_WXZ				; _bstr_t::operator wchar_t const *
PUBLIC	?GetWString@Data_t@_bstr_t@@QAEAAPA_WXZ		; _bstr_t::Data_t::GetWString
PUBLIC	??H@YA?AV_bstr_t@@PB_WABV0@@Z			; operator+
PUBLIC	??1_bstr_t@@QAE@XZ				; _bstr_t::~_bstr_t
PUBLIC	?_Free@_bstr_t@@AAEXXZ				; _bstr_t::_Free
PUBLIC	?Release@Data_t@_bstr_t@@QAEKXZ			; _bstr_t::Data_t::Release
PUBLIC	??_GData_t@_bstr_t@@AAEPAXI@Z			; _bstr_t::Data_t::`scalar deleting destructor'
PUBLIC	??1Data_t@_bstr_t@@AAE@XZ			; _bstr_t::Data_t::~Data_t
PUBLIC	?_Free@Data_t@_bstr_t@@AAEXXZ			; _bstr_t::Data_t::_Free
PUBLIC	??0_bstr_t@@QAE@ABV0@@Z				; _bstr_t::_bstr_t
PUBLIC	?_AddRef@_bstr_t@@AAEXXZ			; _bstr_t::_AddRef
PUBLIC	?AddRef@Data_t@_bstr_t@@QAEKXZ			; _bstr_t::Data_t::AddRef
PUBLIC	??Y_bstr_t@@QAEAAV0@ABV0@@Z			; _bstr_t::operator+=
PUBLIC	??0Data_t@_bstr_t@@QAE@ABV1@0@Z			; _bstr_t::Data_t::Data_t
PUBLIC	?length@_bstr_t@@QBEIXZ				; _bstr_t::length
PUBLIC	?Length@Data_t@_bstr_t@@QBEIXZ			; _bstr_t::Data_t::Length
PUBLIC	?__autoclassinit2@Data_t@_bstr_t@@QAEXI@Z	; _bstr_t::Data_t::__autoclassinit2
PUBLIC	??2Data_t@_bstr_t@@SAPAXI@Z			; _bstr_t::Data_t::operator new
PUBLIC	??0_bstr_t@@QAE@PB_W@Z				; _bstr_t::_bstr_t
PUBLIC	??0Data_t@_bstr_t@@QAE@PB_W@Z			; _bstr_t::Data_t::Data_t
PUBLIC	?__autoclassinit2@_bstr_t@@QAEXI@Z		; _bstr_t::__autoclassinit2
PUBLIC	??0_bstr_t@@QAE@PBD@Z				; _bstr_t::_bstr_t
PUBLIC	??0Data_t@_bstr_t@@QAE@PBD@Z			; _bstr_t::Data_t::Data_t
PUBLIC	?StringLowercase@?$ChTraitsCRT@_W@ATL@@SAPA_WPA_WI@Z ; ATL::ChTraitsCRT<wchar_t>::StringLowercase
PUBLIC	?MakeLower@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEAAV12@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::MakeLower
PUBLIC	?Extraction_Extension@Manipulation_Fichier@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z ; Manipulation_Fichier::Extraction_Extension
PUBLIC	??0Manipulation_Fichier@@QAE@XZ			; Manipulation_Fichier::Manipulation_Fichier
PUBLIC	??1Manipulation_Fichier@@QAE@XZ			; Manipulation_Fichier::~Manipulation_Fichier
PUBLIC	?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z ; Manipulation_Fichier::Test_Extention
PUBLIC	?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z ; Manipulation_Fichier::Ajoute_Extension
PUBLIC	?Supprime_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z ; Manipulation_Fichier::Supprime_Extension
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Supprime_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Supprime_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z$0
__ehfuncinfo$?Supprime_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Supprime_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z$7
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z$7
	DD	03H
	DD	FLAT:__unwindfunclet$?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z$8
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Extraction_Extension@Manipulation_Fichier@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Extraction_Extension@Manipulation_Fichier@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?Extraction_Extension@Manipulation_Fichier@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?Extraction_Extension@Manipulation_Fichier@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z$2
__ehfuncinfo$?Extraction_Extension@Manipulation_Fichier@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?Extraction_Extension@Manipulation_Fichier@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0_bstr_t@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_bstr_t@@QAE@PBD@Z$0
__ehfuncinfo$??0_bstr_t@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0_bstr_t@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0_bstr_t@@QAE@PB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_bstr_t@@QAE@PB_W@Z$0
__ehfuncinfo$??0_bstr_t@@QAE@PB_W@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0_bstr_t@@QAE@PB_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??Y_bstr_t@@QAEAAV0@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??Y_bstr_t@@QAEAAV0@ABV0@@Z$0
__ehfuncinfo$??Y_bstr_t@@QAEAAV0@ABV0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??Y_bstr_t@@QAEAAV0@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??H@YA?AV_bstr_t@@PB_WABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??H@YA?AV_bstr_t@@PB_WABV0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??H@YA?AV_bstr_t@@PB_WABV0@@Z$1
__ehfuncinfo$??H@YA?AV_bstr_t@@PB_WABV0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??H@YA?AV_bstr_t@@PB_WABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??HATL@@YA?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@0@PB_WABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??HATL@@YA?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@0@PB_WABV10@@Z$0
__ehfuncinfo$??HATL@@YA?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@0@PB_WABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??HATL@@YA?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@0@PB_WABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
;	COMDAT ?Supprime_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_chaine$ = 12						; size = 4
?Supprime_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z PROC ; Manipulation_Fichier::Supprime_Extension, COMDAT
; _this$dead$ = ecx

; 101  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Supprime_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 613  : 		return wcsrchr( psz, ch );

	push	46					; 0000002eH
	push	DWORD PTR _chaine$[ebp]
	mov	DWORD PTR [esi], 0
	call	_wcsrchr
	add	esp, 8

; 1814 : 		return( (psz == NULL) ? -1 : int( psz - this->GetString() ) );

	test	eax, eax
	jne	SHORT $LN10@Supprime_E
	or	eax, -1
	jmp	SHORT $LN11@Supprime_E
$LN10@Supprime_E:
	sub	eax, DWORD PTR _chaine$[ebp]
	sar	eax, 1
$LN11@Supprime_E:
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 102  : 	CString local  = chaine.Left(chaine.ReverseFind((wchar_t)'.'));

	push	eax
	push	esi
	lea	ecx, DWORD PTR _chaine$[ebp]
	call	?Left@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QBE?AV12@H@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::Left

; 103  : 	return (local);

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	or	ecx, -1

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	eax, DWORD PTR _chaine$[ebp]
	add	eax, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [eax+12], ecx
	dec	ecx
	test	ecx, ecx
	jg	SHORT $LN27@Supprime_E

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [eax]
	push	eax
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+4]
$LN27@Supprime_E:
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 105  : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Supprime_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z$0:
	lea	ecx, DWORD PTR _chaine$[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__ehhandler$?Supprime_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Supprime_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Supprime_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z ENDP ; Manipulation_Fichier::Supprime_Extension
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
;	COMDAT ?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -36				; size = 4
$T1 = -32						; size = 4
$T7 = -28						; size = 4
$T17 = -24						; size = 4
___$ReturnUdt$GSCopy$ = -20				; size = 4
$T2 = -20						; size = 4
$T4 = -20						; size = 4
$T6 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_chaine$ = 12						; size = 4
_ext$ = 16						; size = 4
?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z PROC ; Manipulation_Fichier::Ajoute_Extension, COMDAT
; _this$dead$ = ecx

; 95   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$[ebp], ebx
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], ebx
	mov	DWORD PTR $T1[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h

; 915  :     return ::operator new(sz);

	push	12					; 0000000cH
	mov	DWORD PTR [ebx], 0
	call	??2@YAPAXI@Z				; operator new

; 311  :     : m_Data(new Data_t(s))

	mov	esi, eax

; 915  :     return ::operator new(sz);

	add	esp, 4

; 311  :     : m_Data(new Data_t(s))

	mov	DWORD PTR $T2[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	test	esi, esi
	je	SHORT $LN14@Ajoute_Ext
	xorps	xmm0, xmm0
	movq	QWORD PTR [esi], xmm0
	mov	DWORD PTR [esi+8], 0

; 683  :     m_wstr = _com_util::ConvertStringToBSTR(s);

	push	OFFSET ??_C@_01LFCBOECM@?4@
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 1
	call	?ConvertStringToBSTR@_com_util@@YGPA_WPBD@Z ; _com_util::ConvertStringToBSTR
	mov	DWORD PTR [esi], eax

; 311  :     : m_Data(new Data_t(s))

	jmp	SHORT $LN15@Ajoute_Ext
$LN14@Ajoute_Ext:
	xor	esi, esi
$LN15@Ajoute_Ext:
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T4[ebp], esi
	test	esi, esi

; 312  : {
; 313  :     if (m_Data == NULL) {

	je	$LN110@Ajoute_Ext
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 377  : 		return( m_pszData );

	mov	eax, DWORD PTR _chaine$[ebp]
	mov	DWORD PTR $T17[ebp], eax
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 96   : 	CString local = chaine + "." + ext;

	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h

; 915  :     return ::operator new(sz);

	push	12					; 0000000cH
	mov	DWORD PTR $T6[ebp], 0
	call	??2@YAPAXI@Z				; operator new

; 321  :     : m_Data(new Data_t(s))

	mov	edi, eax

; 915  :     return ::operator new(sz);

	add	esp, 4

; 321  :     : m_Data(new Data_t(s))

	mov	DWORD PTR $T7[ebp], edi
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	test	edi, edi
	je	SHORT $LN35@Ajoute_Ext

; 691  :     m_wstr = ::SysAllocString(s);

	push	DWORD PTR $T17[ebp]
	xorps	xmm0, xmm0
	movq	QWORD PTR [edi], xmm0
	mov	DWORD PTR [edi+8], 0

; 684  : }
; 685  : 
; 686  : // Construct a Data_t from a const wchar_t*
; 687  : //
; 688  : inline _bstr_t::Data_t::Data_t(const wchar_t* s)
; 689  :     : m_str(NULL), m_RefCount(1)

	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 1

; 690  : {
; 691  :     m_wstr = ::SysAllocString(s);

	call	DWORD PTR __imp__SysAllocString@4
	mov	DWORD PTR [edi], eax

; 692  : 
; 693  :     if (m_wstr == NULL && s != NULL) {

	test	eax, eax
	jne	SHORT $LN36@Ajoute_Ext
	cmp	DWORD PTR $T17[ebp], eax
	jne	$LN111@Ajoute_Ext
	jmp	SHORT $LN36@Ajoute_Ext
$LN35@Ajoute_Ext:

; 321  :     : m_Data(new Data_t(s))

	xor	edi, edi
$LN36@Ajoute_Ext:
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	DWORD PTR $T6[ebp], edi
	test	edi, edi

; 322  : {
; 323  :     if (m_Data == NULL) {

	je	$LN112@Ajoute_Ext

; 459  :     return b;

	lea	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T1[ebp], 2
	push	eax
	lea	ecx, DWORD PTR $T6[ebp]
	call	??Y_bstr_t@@QAEAAV0@ABV0@@Z		; _bstr_t::operator+=

; 472  :     return (m_Data != NULL) ? m_Data->GetWString() : NULL;

	mov	edi, DWORD PTR $T6[ebp]
	test	edi, edi
	je	SHORT $LN49@Ajoute_Ext
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN50@Ajoute_Ext
$LN49@Ajoute_Ext:
	xor	eax, eax
	xor	edi, edi
$LN50@Ajoute_Ext:
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 96   : 	CString local = chaine + "." + ext;

	lea	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	push	eax
	push	ebx
	call	??HATL@@YA?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@0@PB_WABV10@@Z ; ATL::operator+
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h

; 637  :     if (m_Data != NULL) {

	mov	ecx, DWORD PTR __imp__SysFreeString@4
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 96   : 	CString local = chaine + "." + ext;

	add	esp, 12					; 0000000cH
	or	ebx, -1
	test	edi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h

; 637  :     if (m_Data != NULL) {

	je	SHORT $LN62@Ajoute_Ext

; 773  :     unsigned long cRef = InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount));

	mov	eax, ebx
	lock	 xadd	 DWORD PTR [edi+8], eax
	dec	eax

; 774  :     if (cRef == 0) {

	jne	SHORT $LN62@Ajoute_Ext

; 930  :     if (m_wstr != NULL) {

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN67@Ajoute_Ext

; 931  :         ::SysFreeString(m_wstr);

	push	eax
	call	ecx

; 932  :         m_wstr = NULL;

	mov	DWORD PTR [edi], 0
$LN67@Ajoute_Ext:

; 933  :     }
; 934  : 
; 935  :     if (m_str != NULL) {

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN68@Ajoute_Ext

; 936  :         delete [] m_str;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 937  :         m_str = NULL;

	mov	DWORD PTR [edi+4], 0
$LN68@Ajoute_Ext:
	push	12					; 0000000cH
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	mov	ecx, DWORD PTR __imp__SysFreeString@4
	add	esp, 8
$LN62@Ajoute_Ext:

; 773  :     unsigned long cRef = InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount));

	mov	eax, ebx
	lock	 xadd	 DWORD PTR [esi+8], eax
	dec	eax

; 774  :     if (cRef == 0) {

	jne	SHORT $LN81@Ajoute_Ext

; 930  :     if (m_wstr != NULL) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN86@Ajoute_Ext

; 931  :         ::SysFreeString(m_wstr);

	push	eax
	call	ecx

; 932  :         m_wstr = NULL;

	mov	DWORD PTR [esi], 0
$LN86@Ajoute_Ext:

; 933  :     }
; 934  : 
; 935  :     if (m_str != NULL) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN87@Ajoute_Ext

; 936  :         delete [] m_str;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 937  :         m_str = NULL;

	mov	DWORD PTR [esi+4], 0
$LN87@Ajoute_Ext:
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN81@Ajoute_Ext:
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 97   : 	return (local);

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, ebx

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR _chaine$[ebp]
	add	edx, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN96@Ajoute_Ext

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN96@Ajoute_Ext:
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 97   : 	return (local);

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	eax, DWORD PTR _ext$[ebp]
	add	eax, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [eax+12], ebx
	dec	ebx
	test	ebx, ebx
	jg	SHORT $LN105@Ajoute_Ext

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [eax]
	push	eax
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+4]
$LN105@Ajoute_Ext:
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 97   : 	return (local);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]

; 98   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN110@Ajoute_Ext:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h

; 314  :         _com_issue_error(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?_com_issue_error@@YGXJ@Z		; _com_issue_error
$LN111@Ajoute_Ext:

; 694  :         _com_issue_error(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?_com_issue_error@@YGXJ@Z		; _com_issue_error
$LN112@Ajoute_Ext:

; 324  :         _com_issue_error(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?_com_issue_error@@YGXJ@Z		; _com_issue_error
$LN108@Ajoute_Ext:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z$0:
	lea	ecx, DWORD PTR _ext$[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z$1:
	lea	ecx, DWORD PTR _chaine$[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z$5:
	push	12					; 0000000cH
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z$2:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__unwindfunclet$?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z$6:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 2
	je	$LN29@Ajoute_Ext
	and	DWORD PTR $T1[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
$LN29@Ajoute_Ext:
	ret	0
__unwindfunclet$?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z$7:
	push	12					; 0000000cH
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z ENDP ; Manipulation_Fichier::Ajoute_Extension
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
;	COMDAT ?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z
_TEXT	SEGMENT
$T6 = -36						; size = 4
$T2 = -32						; size = 4
tv1006 = -28						; size = 4
$T1 = -28						; size = 4
$T3 = -24						; size = 4
_local_chaine$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_chaine$ = 8						; size = 4
_ext$ = 12						; size = 4
?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z PROC ; Manipulation_Fichier::Test_Extention, COMDAT
; _this$dead$ = ecx

; 61   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T1[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN292@Test_Exten

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR _local_chaine$[ebp], eax
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 63   : 	CString local_chaine;

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	esi, DWORD PTR _chaine$[ebp]

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	ecx, DWORD PTR [esi-16]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+16]

; 69   : 		return nRefs < 0;

	cmp	DWORD PTR [esi-4], 0

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	ecx, eax

; 69   : 		return nRefs < 0;

	lea	eax, DWORD PTR [esi-4]

; 883  : 		if( !pData->IsLocked() && (pNewStringMgr == pData->pStringMgr) )

	jl	SHORT $LN40@Test_Exten
	cmp	ecx, DWORD PTR [esi-16]
	jne	SHORT $LN40@Test_Exten

; 884  : 		{
; 885  : 			pNewData = pData;

	lea	edi, DWORD PTR [esi-16]

; 65   : 		_InterlockedIncrement(&nRefs);

	lock	 inc	 DWORD PTR [eax]

; 887  : 		}

	jmp	SHORT $LN41@Test_Exten
$LN40@Test_Exten:

; 888  : 		else
; 889  : 		{
; 890  : 			pNewData = pNewStringMgr->Allocate( pData->nDataLength, sizeof( XCHAR ) );

	mov	eax, DWORD PTR [ecx]
	push	2
	push	DWORD PTR [esi-12]
	call	DWORD PTR [eax]
	mov	edi, eax

; 891  : 			if( pNewData == NULL )

	test	edi, edi
	je	$LN293@Test_Exten

; 894  : 			}
; 895  : 			pNewData->nDataLength = pData->nDataLength;

	mov	eax, DWORD PTR [esi-12]

; 59   : 		return (this+1);

	lea	edx, DWORD PTR [edi+16]

; 895  : 			pNewData->nDataLength = pData->nDataLength;

	mov	DWORD PTR [edi+4], eax

; 896  : 			CopyChars( PXSTR( pNewData->data() ), pData->nDataLength+1,

	mov	ecx, DWORD PTR [esi-12]
	inc	ecx
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	?CopyChars@?$CSimpleStringT@_W$0A@@ATL@@SAXPA_WIPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::CopyChars
	add	esp, 16					; 00000010H
$LN41@Test_Exten:

; 59   : 		return (this+1);

	add	edi, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR $T2[ebp], edi
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 46   : {

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	DWORD PTR $T3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN294@Test_Exten

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 519  : 		return( GetData()->nDataLength );

	mov	esi, DWORD PTR [edi-12]

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 613  : 		return wcsrchr( psz, ch );

	push	46					; 0000002eH
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR $T3[ebp], eax
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 55   : 	return (local);

	mov	DWORD PTR $T1[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 613  : 		return wcsrchr( psz, ch );

	call	_wcsrchr
	add	esp, 8

; 1814 : 		return( (psz == NULL) ? -1 : int( psz - this->GetString() ) );

	test	eax, eax
	jne	SHORT $LN91@Test_Exten
	or	eax, -1
	jmp	SHORT $LN92@Test_Exten
$LN91@Test_Exten:
	sub	eax, edi
	sar	eax, 1
$LN92@Test_Exten:
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 51   : 	int lg_point = chaine.ReverseFind((wchar_t)'.') + 1;

	inc	eax

; 52   : 	int lg_ext = lg_total - lg_point;
; 53   : 
; 54   : 	local = chaine.Mid(lg_point, lg_ext);

	lea	ecx, DWORD PTR $T2[ebp]
	sub	esi, eax
	push	esi
	push	eax
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	call	?Mid@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QBE?AV12@HH@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::Mid
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	call	??4?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	or	ebx, -1

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR $T6[ebp]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, ebx

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	add	edx, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN106@Test_Exten

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN106@Test_Exten:
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 55   : 	return (local);

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	add	edi, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, ebx
	lock	 xadd	 DWORD PTR [edi+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN115@Test_Exten

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edi]
	push	edi
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN115@Test_Exten:
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 65   : 	local_chaine = Extraction_Extension(chaine);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR _local_chaine$[ebp]
	call	??4?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, ebx

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR $T3[ebp]
	add	edx, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN124@Test_Exten

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN124@Test_Exten:

; 519  : 		return( GetData()->nDataLength );

	mov	eax, DWORD PTR _ext$[ebp]
	mov	esi, DWORD PTR [eax-12]

; 804  : 		if (nLength < 0)

	test	esi, esi
	js	$LN148@Test_Exten

; 805  : 			AtlThrow(E_INVALIDARG);
; 806  : 
; 807  : 		CStringData* pOldData = GetData();
; 808  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false
; 809  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

	mov	ecx, DWORD PTR [eax-8]
	mov	edx, 1
	sub	edx, DWORD PTR [eax-4]
	sub	ecx, esi

; 810  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

	or	ecx, edx
	jge	SHORT $LN136@Test_Exten

; 811  : 		{
; 812  : 			PrepareWrite2( nLength );

	push	esi
	lea	ecx, DWORD PTR _ext$[ebp]
	call	?PrepareWrite2@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2
	mov	eax, DWORD PTR _ext$[ebp]
$LN136@Test_Exten:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 1835 : 		StringTraits::StringLowercase( pszBuffer, nLength+1 );

	lea	ecx, DWORD PTR [esi+1]

; 667  : 		errno_t err = _wcslwr_s( psz, size );

	push	ecx
	push	eax
	call	__wcslwr_s
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 871  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	mov	eax, DWORD PTR _ext$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 667  : 		errno_t err = _wcslwr_s( psz, size );

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 871  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	cmp	esi, DWORD PTR [eax-8]
	jg	$LN148@Test_Exten

; 873  : 
; 874  : 		GetData()->nDataLength = nLength;

	mov	DWORD PTR [eax-12], esi

; 875  : 		m_pszData[nLength] = 0;

	xor	ecx, ecx
	mov	eax, DWORD PTR _ext$[ebp]
	mov	WORD PTR [eax+esi*2], cx

; 519  : 		return( GetData()->nDataLength );

	mov	esi, DWORD PTR _local_chaine$[ebp]
	mov	edi, DWORD PTR [esi-12]

; 804  : 		if (nLength < 0)

	test	edi, edi
	js	$LN148@Test_Exten

; 805  : 			AtlThrow(E_INVALIDARG);
; 806  : 
; 807  : 		CStringData* pOldData = GetData();
; 808  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false
; 809  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

	mov	eax, DWORD PTR [esi-8]
	mov	ecx, 1
	sub	ecx, DWORD PTR [esi-4]
	sub	eax, edi

; 810  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

	or	eax, ecx
	jge	SHORT $LN165@Test_Exten

; 811  : 		{
; 812  : 			PrepareWrite2( nLength );

	push	edi
	lea	ecx, DWORD PTR _local_chaine$[ebp]
	call	?PrepareWrite2@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2
	mov	esi, DWORD PTR _local_chaine$[ebp]
$LN165@Test_Exten:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 1835 : 		StringTraits::StringLowercase( pszBuffer, nLength+1 );

	lea	eax, DWORD PTR [edi+1]

; 667  : 		errno_t err = _wcslwr_s( psz, size );

	push	eax
	push	esi
	call	__wcslwr_s
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 871  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	cmp	edi, DWORD PTR [esi-8]
	jg	$LN148@Test_Exten

; 875  : 		m_pszData[nLength] = 0;

	xor	eax, eax
	mov	DWORD PTR [esi-12], edi
	mov	WORD PTR [esi+edi*2], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 1444 : 		ATLENSURE( AtlIsValidString( psz ) );

	mov	eax, DWORD PTR _ext$[ebp]
	test	eax, eax
	je	$LN295@Test_Exten

; 564  : 		return wcscmp( pszA, pszB );

	mov	ecx, esi
	npad	2
$LL285@Test_Exten:
	mov	dx, WORD PTR [ecx]
	cmp	dx, WORD PTR [eax]
	jne	SHORT $LN286@Test_Exten
	test	dx, dx
	je	SHORT $LN287@Test_Exten
	mov	dx, WORD PTR [ecx+2]
	cmp	dx, WORD PTR [eax+2]
	jne	SHORT $LN286@Test_Exten
	add	ecx, 4
	add	eax, 4
	test	dx, dx
	jne	SHORT $LL285@Test_Exten
$LN287@Test_Exten:
	xor	eax, eax
	jmp	SHORT $LN288@Test_Exten
$LN286@Test_Exten:
	sbb	eax, eax
	or	eax, 1
$LN288@Test_Exten:
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 73   : 		return FALSE;

	xor	ecx, ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	test	eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, ebx
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 73   : 		return FALSE;

	sete	cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	add	esi, -16				; fffffff0H
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 73   : 		return FALSE;

	mov	DWORD PTR tv1006[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [esi+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN238@Test_Exten

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [esi]
	push	esi
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN238@Test_Exten:
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 73   : 		return FALSE;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, ebx

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR _chaine$[ebp]
	add	edx, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN247@Test_Exten

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN247@Test_Exten:
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 73   : 		return FALSE;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	eax, DWORD PTR _ext$[ebp]
	add	eax, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [eax+12], ebx
	dec	ebx
	test	ebx, ebx
	jg	SHORT $LN256@Test_Exten

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [eax]
	push	eax
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+4]
$LN256@Test_Exten:
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 73   : 		return FALSE;

	mov	eax, DWORD PTR tv1006[ebp]

; 76   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
$LN148@Test_Exten:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 872  : 			AtlThrow(E_INVALIDARG);

	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN292@Test_Exten:

; 205  : 		ATLENSURE( pStringMgr != NULL );

	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN293@Test_Exten:

; 893  : 				ThrowMemoryException();

	call	?ThrowMemoryException@?$CSimpleStringT@_W$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<wchar_t,0>::ThrowMemoryException
$LN294@Test_Exten:

; 205  : 		ATLENSURE( pStringMgr != NULL );

	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN295@Test_Exten:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 1444 : 		ATLENSURE( AtlIsValidString( psz ) );

	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN290@Test_Exten:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z$0:
	lea	ecx, DWORD PTR _ext$[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z$1:
	lea	ecx, DWORD PTR _chaine$[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z$2:
	lea	ecx, DWORD PTR _local_chaine$[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z$7:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN62@Test_Exten
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
$LN62@Test_Exten:
	ret	0
__unwindfunclet$?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z$6:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z$8:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__ehhandler$?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Test_Extention@Manipulation_Fichier@@QAEHV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@0@Z ENDP ; Manipulation_Fichier::Test_Extention
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
;	COMDAT ??1Manipulation_Fichier@@QAE@XZ
_TEXT	SEGMENT
??1Manipulation_Fichier@@QAE@XZ PROC			; Manipulation_Fichier::~Manipulation_Fichier, COMDAT
; _this$dead$ = ecx

; 16   : }

	ret	0
??1Manipulation_Fichier@@QAE@XZ ENDP			; Manipulation_Fichier::~Manipulation_Fichier
_TEXT	ENDS
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
;	COMDAT ??0Manipulation_Fichier@@QAE@XZ
_TEXT	SEGMENT
??0Manipulation_Fichier@@QAE@XZ PROC			; Manipulation_Fichier::Manipulation_Fichier, COMDAT
; _this$ = ecx

; 11   : }

	mov	eax, ecx
	ret	0
??0Manipulation_Fichier@@QAE@XZ ENDP			; Manipulation_Fichier::Manipulation_Fichier
_TEXT	ENDS
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp
;	COMDAT ?Extraction_Extension@Manipulation_Fichier@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -24				; size = 4
$T4 = -20						; size = 4
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_chaine$ = 12						; size = 4
?Extraction_Extension@Manipulation_Fichier@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z PROC ; Manipulation_Fichier::Extraction_Extension, COMDAT
; _this$dead$ = ecx

; 46   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Extraction_Extension@Manipulation_Fichier@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi
	mov	DWORD PTR $T1[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN63@Extraction

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [esi], eax

; 519  : 		return( GetData()->nDataLength );

	mov	eax, DWORD PTR _chaine$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 613  : 		return wcsrchr( psz, ch );

	push	46					; 0000002eH
	push	eax
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 55   : 	return (local);

	mov	DWORD PTR $T1[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

	mov	edi, DWORD PTR [eax-12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 613  : 		return wcsrchr( psz, ch );

	call	_wcsrchr
	add	esp, 8

; 1814 : 		return( (psz == NULL) ? -1 : int( psz - this->GetString() ) );

	test	eax, eax
	jne	SHORT $LN34@Extraction
	or	eax, -1
	jmp	SHORT $LN35@Extraction
$LN34@Extraction:
	sub	eax, DWORD PTR _chaine$[ebp]
	sar	eax, 1
$LN35@Extraction:
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 51   : 	int lg_point = chaine.ReverseFind((wchar_t)'.') + 1;

	inc	eax

; 52   : 	int lg_ext = lg_total - lg_point;
; 53   : 
; 54   : 	local = chaine.Mid(lg_point, lg_ext);

	lea	ecx, DWORD PTR _chaine$[ebp]
	sub	edi, eax
	push	edi
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?Mid@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QBE?AV12@HH@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::Mid
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??4?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	or	edi, -1

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR $T4[ebp]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, edi

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	add	edx, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN49@Extraction

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN49@Extraction:
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 55   : 	return (local);

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	eax, DWORD PTR _chaine$[ebp]
	add	eax, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [eax+12], edi
	dec	edi
	test	edi, edi
	jg	SHORT $LN58@Extraction

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [eax]
	push	eax
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+4]
$LN58@Extraction:
; File I:\Projets\AES\AES\AES\Manipulation_Fichier.cpp

; 55   : 	return (local);

	mov	eax, esi

; 56   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
$LN63@Extraction:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN61@Extraction:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Extraction_Extension@Manipulation_Fichier@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z$0:
	lea	ecx, DWORD PTR _chaine$[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$?Extraction_Extension@Manipulation_Fichier@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z$1:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN5@Extraction
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
$LN5@Extraction:
	ret	0
__unwindfunclet$?Extraction_Extension@Manipulation_Fichier@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z$2:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__ehhandler$?Extraction_Extension@Manipulation_Fichier@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Extraction_Extension@Manipulation_Fichier@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Extraction_Extension@Manipulation_Fichier@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z ENDP ; Manipulation_Fichier::Extraction_Extension
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
;	COMDAT ?MakeLower@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEAAV12@XZ
_TEXT	SEGMENT
?MakeLower@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEAAV12@XZ PROC ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::MakeLower, COMDAT
; _this$ = ecx

; 1832 : 	{

	push	esi
	push	edi
	mov	edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

	mov	ecx, DWORD PTR [edi]
	mov	esi, DWORD PTR [ecx-12]

; 804  : 		if (nLength < 0)

	test	esi, esi
	js	SHORT $LN23@MakeLower

; 805  : 			AtlThrow(E_INVALIDARG);
; 806  : 
; 807  : 		CStringData* pOldData = GetData();
; 808  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false
; 809  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

	mov	eax, DWORD PTR [ecx-8]
	mov	edx, 1
	sub	edx, DWORD PTR [ecx-4]
	sub	eax, esi

; 810  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

	or	edx, eax
	jge	SHORT $LN11@MakeLower

; 811  : 		{
; 812  : 			PrepareWrite2( nLength );

	push	esi
	mov	ecx, edi
	call	?PrepareWrite2@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2
	mov	ecx, DWORD PTR [edi]
$LN11@MakeLower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 1835 : 		StringTraits::StringLowercase( pszBuffer, nLength+1 );

	lea	eax, DWORD PTR [esi+1]

; 667  : 		errno_t err = _wcslwr_s( psz, size );

	push	eax
	push	ecx
	call	__wcslwr_s
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 871  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	mov	eax, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 667  : 		errno_t err = _wcslwr_s( psz, size );

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 871  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	cmp	esi, DWORD PTR [eax-8]
	jg	SHORT $LN23@MakeLower

; 873  : 
; 874  : 		GetData()->nDataLength = nLength;

	mov	DWORD PTR [eax-12], esi

; 875  : 		m_pszData[nLength] = 0;

	xor	ecx, ecx
	mov	eax, DWORD PTR [edi]
	mov	WORD PTR [eax+esi*2], cx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 1838 : 		return( *this );

	mov	eax, edi
	pop	edi
	pop	esi

; 1839 : 	}

	ret	0
$LN23@MakeLower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 872  : 			AtlThrow(E_INVALIDARG);

	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN30@MakeLower:
	int	3
?MakeLower@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEAAV12@XZ ENDP ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::MakeLower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
;	COMDAT ?StringLowercase@?$ChTraitsCRT@_W@ATL@@SAPA_WPA_WI@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
_size$ = 12						; size = 4
?StringLowercase@?$ChTraitsCRT@_W@ATL@@SAPA_WPA_WI@Z PROC ; ATL::ChTraitsCRT<wchar_t>::StringLowercase, COMDAT

; 666  : 	{

	push	ebp
	mov	ebp, esp

; 667  : 		errno_t err = _wcslwr_s( psz, size );

	push	DWORD PTR _size$[ebp]
	push	DWORD PTR _psz$[ebp]
	call	__wcslwr_s

; 668  : 		return (err == 0) ? psz : NULL;

	xor	ecx, ecx
	add	esp, 8
	test	eax, eax
	cmove	ecx, DWORD PTR _psz$[ebp]
	mov	eax, ecx

; 669  : 	}

	pop	ebp
	ret	0
?StringLowercase@?$ChTraitsCRT@_W@ATL@@SAPA_WPA_WI@Z ENDP ; ATL::ChTraitsCRT<wchar_t>::StringLowercase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ??0Data_t@_bstr_t@@QAE@PBD@Z
_TEXT	SEGMENT
_s$dead$ = 8						; size = 4
??0Data_t@_bstr_t@@QAE@PBD@Z PROC			; _bstr_t::Data_t::Data_t, COMDAT
; _this$ = ecx

; 682  : {

	push	esi
	mov	esi, ecx

; 683  :     m_wstr = _com_util::ConvertStringToBSTR(s);

	push	OFFSET ??_C@_01LFCBOECM@?4@
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 1
	call	?ConvertStringToBSTR@_com_util@@YGPA_WPBD@Z ; _com_util::ConvertStringToBSTR
	mov	DWORD PTR [esi], eax

; 684  : }

	mov	eax, esi
	pop	esi
	ret	4
??0Data_t@_bstr_t@@QAE@PBD@Z ENDP			; _bstr_t::Data_t::Data_t
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ??0_bstr_t@@QAE@PBD@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_s$dead$ = 8						; size = 4
??0_bstr_t@@QAE@PBD@Z PROC				; _bstr_t::_bstr_t, COMDAT
; _this$ = ecx

; 312  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_bstr_t@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 915  :     return ::operator new(sz);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new

; 311  :     : m_Data(new Data_t(s))

	mov	esi, eax

; 915  :     return ::operator new(sz);

	add	esp, 4

; 311  :     : m_Data(new Data_t(s))

	mov	DWORD PTR $T1[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	esi, esi
	je	SHORT $LN4@bstr_t
	xorps	xmm0, xmm0
	movq	QWORD PTR [esi], xmm0
	mov	DWORD PTR [esi+8], 0

; 683  :     m_wstr = _com_util::ConvertStringToBSTR(s);

	push	OFFSET ??_C@_01LFCBOECM@?4@
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 1
	call	?ConvertStringToBSTR@_com_util@@YGPA_WPBD@Z ; _com_util::ConvertStringToBSTR
	mov	DWORD PTR [esi], eax

; 311  :     : m_Data(new Data_t(s))

	jmp	SHORT $LN5@bstr_t
$LN4@bstr_t:
	xor	esi, esi
$LN5@bstr_t:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [edi], esi

; 313  :     if (m_Data == NULL) {

	test	esi, esi
	je	SHORT $LN16@bstr_t

; 315  :     }
; 316  : }

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN16@bstr_t:

; 314  :         _com_issue_error(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?_com_issue_error@@YGXJ@Z		; _com_issue_error
$LN14@bstr_t:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_bstr_t@@QAE@PBD@Z$0:
	push	12					; 0000000cH
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0_bstr_t@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_bstr_t@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_bstr_t@@QAE@PBD@Z ENDP				; _bstr_t::_bstr_t
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@_bstr_t@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@_bstr_t@@QAEXI@Z PROC			; _bstr_t::__autoclassinit2, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	ret	4
?__autoclassinit2@_bstr_t@@QAEXI@Z ENDP			; _bstr_t::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ??0Data_t@_bstr_t@@QAE@PB_W@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0Data_t@_bstr_t@@QAE@PB_W@Z PROC			; _bstr_t::Data_t::Data_t, COMDAT
; _this$ = ecx

; 690  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 691  :     m_wstr = ::SysAllocString(s);

	push	DWORD PTR _s$[ebp]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 1
	call	DWORD PTR __imp__SysAllocString@4
	mov	DWORD PTR [esi], eax

; 692  : 
; 693  :     if (m_wstr == NULL && s != NULL) {

	test	eax, eax
	jne	SHORT $LN2@Data_t
	cmp	DWORD PTR _s$[ebp], eax
	jne	SHORT $LN6@Data_t
$LN2@Data_t:

; 695  :     }
; 696  : }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
$LN6@Data_t:

; 694  :         _com_issue_error(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?_com_issue_error@@YGXJ@Z		; _com_issue_error
$LN4@Data_t:
	int	3
??0Data_t@_bstr_t@@QAE@PB_W@Z ENDP			; _bstr_t::Data_t::Data_t
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ??0_bstr_t@@QAE@PB_W@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_s$ = 8							; size = 4
??0_bstr_t@@QAE@PB_W@Z PROC				; _bstr_t::_bstr_t, COMDAT
; _this$ = ecx

; 322  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_bstr_t@@QAE@PB_W@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 915  :     return ::operator new(sz);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new

; 321  :     : m_Data(new Data_t(s))

	mov	esi, eax

; 915  :     return ::operator new(sz);

	add	esp, 4

; 321  :     : m_Data(new Data_t(s))

	mov	DWORD PTR $T1[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	esi, esi
	je	SHORT $LN4@bstr_t

; 691  :     m_wstr = ::SysAllocString(s);

	push	DWORD PTR _s$[ebp]
	xorps	xmm0, xmm0
	movq	QWORD PTR [esi], xmm0
	mov	DWORD PTR [esi+8], 0

; 327  : 
; 328  : // Construct a _bstr_t from a BSTR.  If fCopy is FALSE, give control of
; 329  : // data to the _bstr_t without making a new copy.
; 330  : //
; 331  : inline _bstr_t::_bstr_t(BSTR bstr, bool fCopy)
; 332  :     : m_Data(new Data_t(bstr, fCopy))
; 333  : {
; 334  :     if (m_Data == NULL) {
; 335  :         _com_issue_error(E_OUTOFMEMORY);
; 336  :     }
; 337  : }
; 338  : 
; 339  : // Destructor
; 340  : //
; 341  : inline _bstr_t::~_bstr_t() throw()
; 342  : {
; 343  :     _Free();
; 344  : }
; 345  : 
; 346  : //////////////////////////////////////////////////////////////////////////////
; 347  : //
; 348  : // Assignment operators
; 349  : //
; 350  : //////////////////////////////////////////////////////////////////////////////
; 351  : 
; 352  : // Default assign operator
; 353  : //
; 354  : inline _bstr_t& _bstr_t::operator=(const _bstr_t& s) throw()
; 355  : {
; 356  :     if (this != &s) {
; 357  :         _Free();
; 358  : 
; 359  :         m_Data = s.m_Data;
; 360  :         _AddRef();
; 361  :     }
; 362  : 
; 363  :     return *this;
; 364  : }
; 365  : 
; 366  : // Assign a const char* to a _bstr_t
; 367  : //
; 368  : inline _bstr_t& _bstr_t::operator=(const char* s)
; 369  : {
; 370  :     _COM_ASSERT(s == NULL || static_cast<const char*>(*this) != s);
; 371  : 
; 372  :     if (s == NULL || static_cast<const char*>(*this) != s)
; 373  :     {
; 374  :         _Free();
; 375  : 
; 376  :         m_Data = new Data_t(s);
; 377  :         if (m_Data == NULL) {
; 378  :             _com_issue_error(E_OUTOFMEMORY);
; 379  :         }
; 380  :     }
; 381  : 
; 382  :     return *this;
; 383  : }
; 384  : 
; 385  : // Assign a const wchar_t* to a _bstr_t
; 386  : //
; 387  : inline _bstr_t& _bstr_t::operator=(const wchar_t* s)
; 388  : {
; 389  :     _COM_ASSERT(s == NULL || static_cast<const wchar_t*>(*this) != s);
; 390  : 
; 391  :     if (s == NULL || static_cast<const wchar_t*>(*this) != s)
; 392  :     {
; 393  :         _Free();
; 394  : 
; 395  :         m_Data = new Data_t(s);
; 396  :         if (m_Data == NULL) {
; 397  :             _com_issue_error(E_OUTOFMEMORY);
; 398  :         }
; 399  :     }
; 400  : 
; 401  :     return *this;
; 402  : }
; 403  : 
; 404  : //////////////////////////////////////////////////////////////////////////////
; 405  : //
; 406  : // Operators
; 407  : //
; 408  : //////////////////////////////////////////////////////////////////////////////
; 409  : 
; 410  : // Concatenate a _bstr_t onto this _bstr_t
; 411  : //
; 412  : inline _bstr_t& _bstr_t::operator+=(const _bstr_t& s)
; 413  : {
; 414  :     Data_t* newData = new Data_t(*this, s);
; 415  :     if (newData == NULL) {
; 416  :         _com_issue_error(E_OUTOFMEMORY);
; 417  :     }
; 418  :     else {
; 419  :         _Free();
; 420  :         m_Data = newData;
; 421  :     }
; 422  : 
; 423  :     return *this;
; 424  : }
; 425  : 
; 426  : // Return the concatenation of this _bstr_t with another _bstr_t
; 427  : //
; 428  : inline _bstr_t _bstr_t::operator+(const _bstr_t& s) const
; 429  : {
; 430  :     _bstr_t b = *this;
; 431  :     b += s;
; 432  : 
; 433  :     return b;
; 434  : }
; 435  : 
; 436  : //////////////////////////////////////////////////////////////////////////////
; 437  : //
; 438  : // Friend Operators
; 439  : //
; 440  : //////////////////////////////////////////////////////////////////////////////
; 441  : 
; 442  : // Return the concatenation of a const char* with a _bstr_t
; 443  : //
; 444  : inline _bstr_t operator+(const char* s1, const _bstr_t& s2)
; 445  : {
; 446  :     _bstr_t b = s1;
; 447  :     b += s2;
; 448  : 
; 449  :     return b;
; 450  : }
; 451  : 
; 452  : // Return the concatenation of a const char* with a _bstr_t
; 453  : //
; 454  : inline _bstr_t operator+(const wchar_t* s1, const _bstr_t& s2)
; 455  : {
; 456  :     _bstr_t b = s1;
; 457  :     b += s2;
; 458  : 
; 459  :     return b;
; 460  : }
; 461  : 
; 462  : //////////////////////////////////////////////////////////////////////////////
; 463  : //
; 464  : // Extractors
; 465  : //
; 466  : //////////////////////////////////////////////////////////////////////////////
; 467  : 
; 468  : // Extract a const wchar_t*
; 469  : //
; 470  : inline _bstr_t::operator const wchar_t*() const throw()
; 471  : {
; 472  :     return (m_Data != NULL) ? m_Data->GetWString() : NULL;
; 473  : }
; 474  : 
; 475  : // Extract a wchar_t*
; 476  : //
; 477  : inline _bstr_t::operator wchar_t*() const throw()
; 478  : {
; 479  :     return const_cast<wchar_t*>((m_Data != NULL) ? m_Data->GetWString() : NULL);
; 480  : }
; 481  : 
; 482  : // Extract a const char_t*
; 483  : //
; 484  : inline _bstr_t::operator const char*() const
; 485  : {
; 486  :     return (m_Data != NULL) ? m_Data->GetString() : NULL;
; 487  : }
; 488  : 
; 489  : // Extract a char_t*
; 490  : //
; 491  : inline _bstr_t::operator char*() const
; 492  : {
; 493  :     return const_cast<char*>((m_Data != NULL) ? m_Data->GetString() : NULL);
; 494  : }
; 495  : 
; 496  : //////////////////////////////////////////////////////////////////////////////
; 497  : //
; 498  : // Comparison operators
; 499  : //
; 500  : //////////////////////////////////////////////////////////////////////////////
; 501  : 
; 502  : inline bool _bstr_t::operator!() const throw()
; 503  : {
; 504  :     return (m_Data != NULL) ? !m_Data->GetWString() : true;
; 505  : }
; 506  : 
; 507  : inline bool _bstr_t::operator==(const _bstr_t& str) const throw()
; 508  : {
; 509  :     return _Compare(str) == 0;
; 510  : }
; 511  : 
; 512  : inline bool _bstr_t::operator!=(const _bstr_t& str) const throw()
; 513  : {
; 514  :     return _Compare(str) != 0;
; 515  : }
; 516  : 
; 517  : inline bool _bstr_t::operator<(const _bstr_t& str) const throw()
; 518  : {
; 519  :     return _Compare(str) < 0;
; 520  : }
; 521  : 
; 522  : inline bool _bstr_t::operator>(const _bstr_t& str) const throw()
; 523  : {
; 524  :     return _Compare(str) > 0;
; 525  : }
; 526  : 
; 527  : inline bool _bstr_t::operator<=(const _bstr_t& str) const throw()
; 528  : {
; 529  :     return _Compare(str) <= 0;
; 530  : }
; 531  : 
; 532  : inline bool _bstr_t::operator>=(const _bstr_t& str) const throw()
; 533  : {
; 534  :     return _Compare(str) >= 0;
; 535  : }
; 536  : 
; 537  : //////////////////////////////////////////////////////////////////////////////
; 538  : //
; 539  : // Low-level help functions
; 540  : //
; 541  : //////////////////////////////////////////////////////////////////////////////
; 542  : 
; 543  : // Extract a copy of the wrapped BSTR
; 544  : //
; 545  : inline BSTR _bstr_t::copy(bool fCopy) const
; 546  : {
; 547  :     return (m_Data != NULL) ? (fCopy ? m_Data->Copy() : m_Data->GetWString()) : NULL;
; 548  : }
; 549  : 
; 550  : // Return the length of the wrapped BSTR
; 551  : //
; 552  : inline unsigned int _bstr_t::length() const throw()
; 553  : {
; 554  :     return (m_Data != NULL) ? m_Data->Length() : 0;
; 555  : }
; 556  : 
; 557  : // Binary string assign
; 558  : //
; 559  : inline void _bstr_t::Assign(BSTR s)
; 560  : {
; 561  :     _COM_ASSERT(s == NULL || m_Data == NULL || m_Data->GetWString() != s);
; 562  : 
; 563  :     if (s == NULL || m_Data == NULL || m_Data->GetWString() != s)
; 564  :     {
; 565  :         _Free();
; 566  : 
; 567  :         m_Data = new Data_t(s, TRUE);
; 568  :         if (m_Data == NULL) {
; 569  :             _com_issue_error(E_OUTOFMEMORY);
; 570  :         }
; 571  :     }
; 572  : }
; 573  : 
; 574  : // Get the physical BSTR
; 575  : //
; 576  : inline BSTR& _bstr_t::GetBSTR()
; 577  : {
; 578  :     if (m_Data == NULL) {
; 579  :         m_Data = new Data_t(0, FALSE);
; 580  :         if (m_Data == NULL) {
; 581  :             _com_issue_error(E_OUTOFMEMORY);
; 582  :         }
; 583  :     }
; 584  :     return m_Data->GetWString();
; 585  : }
; 586  : 
; 587  : // Get the address of the physical BSTR to pass as an 'out'-parameter
; 588  : //
; 589  : inline BSTR* _bstr_t::GetAddress()
; 590  : {
; 591  :     Attach(0);
; 592  :     return &m_Data->GetWString();
; 593  : }
; 594  : 
; 595  : // Attach to the internal BSTR w/o copying
; 596  : //
; 597  : inline void _bstr_t::Attach(BSTR s)
; 598  : {
; 599  :     _Free();
; 600  : 
; 601  :     m_Data = new Data_t(s, FALSE);
; 602  :     if (m_Data == NULL) {
; 603  :         _com_issue_error(E_OUTOFMEMORY);
; 604  :     }
; 605  : }
; 606  : 
; 607  : // Detach the internal BSTR
; 608  : //
; 609  : inline BSTR _bstr_t::Detach()
; 610  : {
; 611  :     _COM_ASSERT(m_Data != NULL && m_Data->RefCount() == 1);
; 612  : 
; 613  :     if (m_Data != NULL && m_Data->RefCount() == 1) {
; 614  :         BSTR b = m_Data->GetWString();
; 615  :         m_Data->GetWString() = NULL;
; 616  :         _Free();
; 617  :         return b;
; 618  :     }
; 619  :     else {
; 620  :         _com_issue_error(E_POINTER);
; 621  :     }
; 622  : }
; 623  : 
; 624  : // AddRef the BSTR
; 625  : //
; 626  : inline void _bstr_t::_AddRef() throw()
; 627  : {
; 628  :     if (m_Data != NULL) {
; 629  :         m_Data->AddRef();
; 630  :     }
; 631  : }
; 632  : 
; 633  : // Free the BSTR
; 634  : //
; 635  : inline void _bstr_t::_Free() throw()
; 636  : {
; 637  :     if (m_Data != NULL) {
; 638  :         m_Data->Release();
; 639  :         m_Data = NULL;
; 640  :     }
; 641  : }
; 642  : 
; 643  : // Compare two _bstr_t objects
; 644  : //
; 645  : inline int _bstr_t::_Compare(const _bstr_t& str) const throw()
; 646  : {
; 647  :     if (m_Data == str.m_Data) {
; 648  :         return 0;
; 649  :     }
; 650  : 
; 651  :     if (m_Data == NULL) {
; 652  :         if (str.length() == 0) {
; 653  :             return 0;
; 654  :         }
; 655  :         else {
; 656  :             return -1;
; 657  :         }
; 658  :     }
; 659  : 
; 660  :     if (str.m_Data == NULL){
; 661  :         if (this->length() == 0) {
; 662  :             return 0;
; 663  :         }
; 664  :         else {
; 665  :             return 1;
; 666  :         }
; 667  :     }
; 668  : 
; 669  :     return m_Data->Compare(*str.m_Data);
; 670  : }
; 671  : 
; 672  : //////////////////////////////////////////////////////////////////////////////
; 673  : //
; 674  : // Reference counted wrapper - Constructors
; 675  : //
; 676  : //////////////////////////////////////////////////////////////////////////////
; 677  : 
; 678  : // Construct a Data_t from a const char*
; 679  : //
; 680  : inline _bstr_t::Data_t::Data_t(const char* s)
; 681  :     : m_str(NULL), m_RefCount(1)
; 682  : {
; 683  :     m_wstr = _com_util::ConvertStringToBSTR(s);
; 684  : }
; 685  : 
; 686  : // Construct a Data_t from a const wchar_t*
; 687  : //
; 688  : inline _bstr_t::Data_t::Data_t(const wchar_t* s)
; 689  :     : m_str(NULL), m_RefCount(1)

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 1

; 690  : {
; 691  :     m_wstr = ::SysAllocString(s);

	call	DWORD PTR __imp__SysAllocString@4
	mov	DWORD PTR [esi], eax

; 692  : 
; 693  :     if (m_wstr == NULL && s != NULL) {

	test	eax, eax
	jne	SHORT $LN5@bstr_t
	cmp	DWORD PTR _s$[ebp], eax
	jne	SHORT $LN18@bstr_t
	jmp	SHORT $LN5@bstr_t
$LN4@bstr_t:

; 321  :     : m_Data(new Data_t(s))

	xor	esi, esi
$LN5@bstr_t:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [edi], esi

; 323  :     if (m_Data == NULL) {

	test	esi, esi
	je	SHORT $LN19@bstr_t

; 325  :     }
; 326  : }

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN18@bstr_t:

; 694  :         _com_issue_error(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?_com_issue_error@@YGXJ@Z		; _com_issue_error
$LN19@bstr_t:

; 324  :         _com_issue_error(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?_com_issue_error@@YGXJ@Z		; _com_issue_error
$LN16@bstr_t:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_bstr_t@@QAE@PB_W@Z$0:
	push	12					; 0000000cH
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0_bstr_t@@QAE@PB_W@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_bstr_t@@QAE@PB_W@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_bstr_t@@QAE@PB_W@Z ENDP				; _bstr_t::_bstr_t
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ??2Data_t@_bstr_t@@SAPAXI@Z
_TEXT	SEGMENT
??2Data_t@_bstr_t@@SAPAXI@Z PROC			; _bstr_t::Data_t::operator new, COMDAT
; _sz$dead$ = ecx

; 915  :     return ::operator new(sz);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 916  : }

	ret	0
??2Data_t@_bstr_t@@SAPAXI@Z ENDP			; _bstr_t::Data_t::operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@Data_t@_bstr_t@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@Data_t@_bstr_t@@QAEXI@Z PROC		; _bstr_t::Data_t::__autoclassinit2, COMDAT
; _this$ = ecx
	xorps	xmm0, xmm0
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], 0
	ret	4
?__autoclassinit2@Data_t@_bstr_t@@QAEXI@Z ENDP		; _bstr_t::Data_t::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ?Length@Data_t@_bstr_t@@QBEIXZ
_TEXT	SEGMENT
?Length@Data_t@_bstr_t@@QBEIXZ PROC			; _bstr_t::Data_t::Length, COMDAT
; _this$ = ecx

; 871  :     return m_wstr ? ::SysStringLen(m_wstr) : 0;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@Length
	push	eax
	call	DWORD PTR __imp__SysStringLen@4

; 872  : }

	ret	0
$LN3@Length:

; 871  :     return m_wstr ? ::SysStringLen(m_wstr) : 0;

	xor	eax, eax

; 872  : }

	ret	0
?Length@Data_t@_bstr_t@@QBEIXZ ENDP			; _bstr_t::Data_t::Length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ?length@_bstr_t@@QBEIXZ
_TEXT	SEGMENT
?length@_bstr_t@@QBEIXZ PROC				; _bstr_t::length, COMDAT
; _this$ = ecx

; 554  :     return (m_Data != NULL) ? m_Data->Length() : 0;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@length

; 871  :     return m_wstr ? ::SysStringLen(m_wstr) : 0;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN3@length
	push	eax
	call	DWORD PTR __imp__SysStringLen@4

; 555  : }

	ret	0
$LN3@length:
	xor	eax, eax
	ret	0
?length@_bstr_t@@QBEIXZ ENDP				; _bstr_t::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ?UIntAdd@_com_util@@YAJIIPAI@Z
_TEXT	SEGMENT
_puResult$ = 8						; size = 4
?UIntAdd@_com_util@@YAJIIPAI@Z PROC			; _com_util::UIntAdd, COMDAT
; _uAugend$ = ecx
; _uAddend$ = edx

; 101  : 	{

	push	ebp
	mov	ebp, esp

; 102  : 		if((uAugend + uAddend) < uAddend)

	add	ecx, edx
	cmp	ecx, edx
	jae	SHORT $LN2@UIntAdd

; 103  : 		{
; 104  : 			return INTSAFE_E_ARITHMETIC_OVERFLOW;

	mov	eax, -2147024362			; 80070216H

; 108  : 	}

	pop	ebp
	ret	0
$LN2@UIntAdd:

; 105  : 		}
; 106  : 		*puResult = uAugend + uAddend;

	mov	eax, DWORD PTR _puResult$[ebp]
	mov	DWORD PTR [eax], ecx

; 107  : 		return S_OK;

	xor	eax, eax

; 108  : 	}

	pop	ebp
	ret	0
?UIntAdd@_com_util@@YAJIIPAI@Z ENDP			; _com_util::UIntAdd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ?UIntMult@_com_util@@YAJIIPAI@Z
_TEXT	SEGMENT
_puResult$ = 8						; size = 4
?UIntMult@_com_util@@YAJIIPAI@Z PROC			; _com_util::UIntMult, COMDAT
; _uMultiplicand$ = ecx
; _uMultiplier$dead$ = edx

; 111  : 	{

	push	ebp
	mov	ebp, esp

; 112  : 		ULONGLONG ull64Result = UInt32x32To64(uMultiplicand, uMultiplier);

	mov	eax, ecx
	mov	ecx, 2
	mul	ecx
	mov	ecx, eax

; 113  : 		if(ull64Result <= INTSAFE_UINT_MAX)

	test	edx, edx
	ja	SHORT $LN2@UIntMult
	jb	SHORT $LN4@UIntMult
	cmp	ecx, -1
	ja	SHORT $LN2@UIntMult
$LN4@UIntMult:

; 114  : 		{
; 115  : 			*puResult = (UINT)ull64Result;

	mov	eax, DWORD PTR _puResult$[ebp]
	mov	DWORD PTR [eax], ecx

; 116  : 			return S_OK;

	xor	eax, eax

; 119  : 	}

	pop	ebp
	ret	0
$LN2@UIntMult:

; 117  : 		}
; 118  : 		return INTSAFE_E_ARITHMETIC_OVERFLOW;

	mov	eax, -2147024362			; 80070216H

; 119  : 	}

	pop	ebp
	ret	0
?UIntMult@_com_util@@YAJIIPAI@Z ENDP			; _com_util::UIntMult
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ??0Data_t@_bstr_t@@QAE@ABV1@0@Z
_TEXT	SEGMENT
tv330 = -8						; size = 4
_l3$1$ = -4						; size = 4
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
??0Data_t@_bstr_t@@QAE@ABV1@0@Z PROC			; _bstr_t::Data_t::Data_t, COMDAT
; _this$ = ecx

; 721  : {

	push	ebp
	mov	ebp, esp

; 554  :     return (m_Data != NULL) ? m_Data->Length() : 0;

	mov	eax, DWORD PTR _s1$[ebp]

; 721  : {

	sub	esp, 8
	push	ebx
	push	esi

; 554  :     return (m_Data != NULL) ? m_Data->Length() : 0;

	mov	esi, DWORD PTR __imp__SysStringLen@4

; 721  : {

	push	edi
	mov	edi, ecx

; 555  : }
; 556  : 
; 557  : // Binary string assign
; 558  : //
; 559  : inline void _bstr_t::Assign(BSTR s)
; 560  : {
; 561  :     _COM_ASSERT(s == NULL || m_Data == NULL || m_Data->GetWString() != s);
; 562  : 
; 563  :     if (s == NULL || m_Data == NULL || m_Data->GetWString() != s)
; 564  :     {
; 565  :         _Free();
; 566  : 
; 567  :         m_Data = new Data_t(s, TRUE);
; 568  :         if (m_Data == NULL) {
; 569  :             _com_issue_error(E_OUTOFMEMORY);
; 570  :         }
; 571  :     }
; 572  : }
; 573  : 
; 574  : // Get the physical BSTR
; 575  : //
; 576  : inline BSTR& _bstr_t::GetBSTR()
; 577  : {
; 578  :     if (m_Data == NULL) {
; 579  :         m_Data = new Data_t(0, FALSE);
; 580  :         if (m_Data == NULL) {
; 581  :             _com_issue_error(E_OUTOFMEMORY);
; 582  :         }
; 583  :     }
; 584  :     return m_Data->GetWString();
; 585  : }
; 586  : 
; 587  : // Get the address of the physical BSTR to pass as an 'out'-parameter
; 588  : //
; 589  : inline BSTR* _bstr_t::GetAddress()
; 590  : {
; 591  :     Attach(0);
; 592  :     return &m_Data->GetWString();
; 593  : }
; 594  : 
; 595  : // Attach to the internal BSTR w/o copying
; 596  : //
; 597  : inline void _bstr_t::Attach(BSTR s)
; 598  : {
; 599  :     _Free();
; 600  : 
; 601  :     m_Data = new Data_t(s, FALSE);
; 602  :     if (m_Data == NULL) {
; 603  :         _com_issue_error(E_OUTOFMEMORY);
; 604  :     }
; 605  : }
; 606  : 
; 607  : // Detach the internal BSTR
; 608  : //
; 609  : inline BSTR _bstr_t::Detach()
; 610  : {
; 611  :     _COM_ASSERT(m_Data != NULL && m_Data->RefCount() == 1);
; 612  : 
; 613  :     if (m_Data != NULL && m_Data->RefCount() == 1) {
; 614  :         BSTR b = m_Data->GetWString();
; 615  :         m_Data->GetWString() = NULL;
; 616  :         _Free();
; 617  :         return b;
; 618  :     }
; 619  :     else {
; 620  :         _com_issue_error(E_POINTER);
; 621  :     }
; 622  : }
; 623  : 
; 624  : // AddRef the BSTR
; 625  : //
; 626  : inline void _bstr_t::_AddRef() throw()
; 627  : {
; 628  :     if (m_Data != NULL) {
; 629  :         m_Data->AddRef();
; 630  :     }
; 631  : }
; 632  : 
; 633  : // Free the BSTR
; 634  : //
; 635  : inline void _bstr_t::_Free() throw()
; 636  : {
; 637  :     if (m_Data != NULL) {
; 638  :         m_Data->Release();
; 639  :         m_Data = NULL;
; 640  :     }
; 641  : }
; 642  : 
; 643  : // Compare two _bstr_t objects
; 644  : //
; 645  : inline int _bstr_t::_Compare(const _bstr_t& str) const throw()
; 646  : {
; 647  :     if (m_Data == str.m_Data) {
; 648  :         return 0;
; 649  :     }
; 650  : 
; 651  :     if (m_Data == NULL) {
; 652  :         if (str.length() == 0) {
; 653  :             return 0;
; 654  :         }
; 655  :         else {
; 656  :             return -1;
; 657  :         }
; 658  :     }
; 659  : 
; 660  :     if (str.m_Data == NULL){
; 661  :         if (this->length() == 0) {
; 662  :             return 0;
; 663  :         }
; 664  :         else {
; 665  :             return 1;
; 666  :         }
; 667  :     }
; 668  : 
; 669  :     return m_Data->Compare(*str.m_Data);
; 670  : }
; 671  : 
; 672  : //////////////////////////////////////////////////////////////////////////////
; 673  : //
; 674  : // Reference counted wrapper - Constructors
; 675  : //
; 676  : //////////////////////////////////////////////////////////////////////////////
; 677  : 
; 678  : // Construct a Data_t from a const char*
; 679  : //
; 680  : inline _bstr_t::Data_t::Data_t(const char* s)
; 681  :     : m_str(NULL), m_RefCount(1)
; 682  : {
; 683  :     m_wstr = _com_util::ConvertStringToBSTR(s);
; 684  : }
; 685  : 
; 686  : // Construct a Data_t from a const wchar_t*
; 687  : //
; 688  : inline _bstr_t::Data_t::Data_t(const wchar_t* s)
; 689  :     : m_str(NULL), m_RefCount(1)
; 690  : {
; 691  :     m_wstr = ::SysAllocString(s);
; 692  : 
; 693  :     if (m_wstr == NULL && s != NULL) {
; 694  :         _com_issue_error(E_OUTOFMEMORY);
; 695  :     }
; 696  : }
; 697  : 
; 698  : // Construct a Data_t from a BSTR.  If fCopy is FALSE, give control of
; 699  : // data to the Data_t without doing a SysAllocStringByteLen.
; 700  : //
; 701  : inline _bstr_t::Data_t::Data_t(BSTR bstr, bool fCopy)
; 702  :     : m_str(NULL), m_RefCount(1)
; 703  : {
; 704  :     if (fCopy && bstr != NULL) {
; 705  :         m_wstr = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
; 706  :                                          ::SysStringByteLen(bstr));
; 707  : 
; 708  :         if (m_wstr == NULL) {
; 709  :             _com_issue_error(E_OUTOFMEMORY);
; 710  :         }
; 711  :     }
; 712  :     else {
; 713  :         m_wstr = bstr;
; 714  :     }
; 715  : }
; 716  : 
; 717  : // Construct a Data_t from the concatenation of two _bstr_t objects
; 718  : //
; 719  : inline _bstr_t::Data_t::Data_t(const _bstr_t& s1, const _bstr_t& s2)
; 720  :     : m_str(NULL), m_RefCount(1)

	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 1

; 554  :     return (m_Data != NULL) ? m_Data->Length() : 0;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN11@Data_t

; 871  :     return m_wstr ? ::SysStringLen(m_wstr) : 0;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN11@Data_t
	push	eax
	call	esi
	mov	ebx, eax
	jmp	SHORT $LN12@Data_t
$LN11@Data_t:

; 554  :     return (m_Data != NULL) ? m_Data->Length() : 0;

	xor	ebx, ebx
$LN12@Data_t:
	mov	eax, DWORD PTR _s2$[ebp]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN19@Data_t

; 871  :     return m_wstr ? ::SysStringLen(m_wstr) : 0;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN19@Data_t
	push	eax
	call	esi
	mov	esi, eax
	jmp	SHORT $LN20@Data_t
$LN19@Data_t:

; 102  : 		if((uAugend + uAddend) < uAddend)

	xor	esi, esi
$LN20@Data_t:
	lea	ecx, DWORD PTR [esi+ebx]
	mov	DWORD PTR _l3$1$[ebp], ecx
	cmp	ecx, esi
	jb	$LN3@Data_t

; 112  : 		ULONGLONG ull64Result = UInt32x32To64(uMultiplicand, uMultiplier);

	mov	eax, ecx
	mov	edx, 2
	mul	edx

; 113  : 		if(ull64Result <= INTSAFE_UINT_MAX)

	test	edx, edx
	ja	SHORT $LN3@Data_t
	jb	SHORT $LN41@Data_t
	cmp	eax, -1
	ja	SHORT $LN3@Data_t
$LN41@Data_t:

; 730  : 		return;
; 731  : 	}
; 732  : 
; 733  : 	m_wstr = ::SysAllocStringByteLen(NULL, (l1 + l2) * sizeof(wchar_t));

	lea	eax, DWORD PTR [ecx+ecx]
	push	eax
	push	0
	mov	DWORD PTR tv330[ebp], eax
	call	DWORD PTR __imp__SysAllocStringByteLen@8
	mov	ecx, eax
	mov	DWORD PTR [edi], ecx

; 734  : 	if (m_wstr == NULL)

	test	ecx, ecx
	jne	SHORT $LN4@Data_t

; 735  : 	{
; 736  : 		if (l1 + l2 == 0)

	cmp	DWORD PTR _l3$1$[ebp], eax
	jne	SHORT $LN3@Data_t
	jmp	SHORT $LN7@Data_t
$LN4@Data_t:

; 472  :     return (m_Data != NULL) ? m_Data->GetWString() : NULL;

	mov	eax, DWORD PTR _s1$[ebp]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Data_t
	mov	edx, DWORD PTR [eax]

; 737  : 		{
; 738  : 			return;
; 739  : 		}
; 740  : 		_com_issue_error(E_OUTOFMEMORY);
; 741  : 		return;
; 742  : 	}
; 743  : 
; 744  : 	const wchar_t* wstr1 = static_cast<const wchar_t*>(s1);
; 745  : 
; 746  : 	if (wstr1 != NULL)

	test	edx, edx
	je	SHORT $LN6@Data_t

; 747  : 	{
; 748  : 		_COM_MEMCPY_S(m_wstr, (l1 + l2 + 1) * sizeof(wchar_t), wstr1, (l1 + 1) * sizeof(wchar_t));

	lea	eax, DWORD PTR [ebx*2+2]
	push	eax
	push	edx
	mov	edx, DWORD PTR tv330[ebp]
	add	edx, 2
	call	_memcpy_s
	add	esp, 8
$LN6@Data_t:

; 472  :     return (m_Data != NULL) ? m_Data->GetWString() : NULL;

	mov	eax, DWORD PTR _s2$[ebp]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN7@Data_t
	mov	eax, DWORD PTR [eax]

; 749  : 	}
; 750  : 
; 751  : 	const wchar_t* wstr2 = static_cast<const wchar_t*>(s2);
; 752  : 
; 753  : 	if (wstr2 != NULL)

	test	eax, eax
	je	SHORT $LN7@Data_t

; 754  : 	{
; 755  : 		_COM_MEMCPY_S(m_wstr + l1, (l2 + 1) * sizeof(wchar_t), wstr2, (l2 + 1) * sizeof(wchar_t));

	lea	edx, DWORD PTR [esi*2+2]
	push	edx
	push	eax
	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax+ebx*2]
	call	_memcpy_s
	add	esp, 8
$LN7@Data_t:

; 756  : 	}
; 757  : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN3@Data_t:

; 722  : 	const unsigned int l1 = s1.length();
; 723  : 	const unsigned int l2 = s2.length();
; 724  : 	unsigned int l3;
; 725  : 
; 726  : 	if (FAILED(_com_util::UIntAdd(l1, l2, &l3)) ||
; 727  : 		FAILED(_com_util::UIntMult(l3, sizeof(wchar_t), &l3)))
; 728  : 	{
; 729  : 		_com_issue_error(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?_com_issue_error@@YGXJ@Z		; _com_issue_error
$LN42@Data_t:
	int	3
??0Data_t@_bstr_t@@QAE@ABV1@0@Z ENDP			; _bstr_t::Data_t::Data_t
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ??Y_bstr_t@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
tv448 = -24						; size = 4
_l3$1$ = -20						; size = 4
_l1$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_s$ = 8							; size = 4
??Y_bstr_t@@QAEAAV0@ABV0@@Z PROC			; _bstr_t::operator+=, COMDAT
; _this$ = ecx

; 413  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??Y_bstr_t@@QAEAAV0@ABV0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx

; 915  :     return ::operator new(sz);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new

; 414  :     Data_t* newData = new Data_t(*this, s);

	mov	esi, eax

; 915  :     return ::operator new(sz);

	add	esp, 4

; 414  :     Data_t* newData = new Data_t(*this, s);

	mov	DWORD PTR $T1[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	esi, esi
	je	$LN5@operator

; 554  :     return (m_Data != NULL) ? m_Data->Length() : 0;

	mov	edi, DWORD PTR __imp__SysStringLen@4
	xorps	xmm0, xmm0
	movq	QWORD PTR [esi], xmm0
	mov	DWORD PTR [esi+8], 0

; 720  :     : m_str(NULL), m_RefCount(1)

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 1

; 554  :     return (m_Data != NULL) ? m_Data->Length() : 0;

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN22@operator

; 871  :     return m_wstr ? ::SysStringLen(m_wstr) : 0;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN22@operator
	push	eax
	call	edi
	mov	DWORD PTR _l1$1$[ebp], eax
	jmp	SHORT $LN23@operator
$LN22@operator:

; 554  :     return (m_Data != NULL) ? m_Data->Length() : 0;

	mov	DWORD PTR _l1$1$[ebp], 0
$LN23@operator:
	mov	eax, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN30@operator

; 871  :     return m_wstr ? ::SysStringLen(m_wstr) : 0;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN30@operator
	push	eax
	call	edi
	mov	edi, eax
	jmp	SHORT $LN31@operator
$LN30@operator:

; 102  : 		if((uAugend + uAddend) < uAddend)

	xor	edi, edi
$LN31@operator:
	mov	ecx, DWORD PTR _l1$1$[ebp]
	add	ecx, edi
	mov	DWORD PTR _l3$1$[ebp], ecx
	cmp	ecx, edi
	jb	$LN14@operator

; 112  : 		ULONGLONG ull64Result = UInt32x32To64(uMultiplicand, uMultiplier);

	mov	eax, ecx
	mov	edx, 2
	mul	edx

; 113  : 		if(ull64Result <= INTSAFE_UINT_MAX)

	test	edx, edx
	ja	$LN14@operator
	jb	SHORT $LN70@operator
	cmp	eax, -1
	ja	$LN14@operator
$LN70@operator:

; 733  : 	m_wstr = ::SysAllocStringByteLen(NULL, (l1 + l2) * sizeof(wchar_t));

	lea	eax, DWORD PTR [ecx+ecx]
	push	eax
	push	0
	mov	DWORD PTR tv448[ebp], eax
	call	DWORD PTR __imp__SysAllocStringByteLen@8
	mov	ecx, eax
	mov	DWORD PTR [esi], ecx

; 734  : 	if (m_wstr == NULL)

	test	ecx, ecx
	jne	SHORT $LN15@operator

; 735  : 	{
; 736  : 		if (l1 + l2 == 0)

	cmp	DWORD PTR _l3$1$[ebp], eax
	je	SHORT $LN6@operator
	jmp	$LN14@operator
$LN15@operator:

; 472  :     return (m_Data != NULL) ? m_Data->GetWString() : NULL;

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN17@operator
	mov	edx, DWORD PTR [eax]

; 746  : 	if (wstr1 != NULL)

	test	edx, edx
	je	SHORT $LN17@operator

; 747  : 	{
; 748  : 		_COM_MEMCPY_S(m_wstr, (l1 + l2 + 1) * sizeof(wchar_t), wstr1, (l1 + 1) * sizeof(wchar_t));

	mov	eax, DWORD PTR _l1$1$[ebp]
	lea	eax, DWORD PTR [eax*2+2]
	push	eax
	push	edx
	mov	edx, DWORD PTR tv448[ebp]
	add	edx, 2
	call	_memcpy_s
	add	esp, 8
$LN17@operator:

; 472  :     return (m_Data != NULL) ? m_Data->GetWString() : NULL;

	mov	eax, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN6@operator
	mov	eax, DWORD PTR [eax]

; 753  : 	if (wstr2 != NULL)

	test	eax, eax
	je	SHORT $LN6@operator

; 754  : 	{
; 755  : 		_COM_MEMCPY_S(m_wstr + l1, (l2 + 1) * sizeof(wchar_t), wstr2, (l2 + 1) * sizeof(wchar_t));

	mov	ecx, DWORD PTR _l1$1$[ebp]
	lea	edx, DWORD PTR [edi*2+2]
	push	edx
	push	eax
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+ecx*2]
	call	_memcpy_s
	add	esp, 8

; 414  :     Data_t* newData = new Data_t(*this, s);

	jmp	SHORT $LN6@operator
$LN5@operator:
	xor	esi, esi
$LN6@operator:
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 415  :     if (newData == NULL) {

	test	esi, esi
	je	SHORT $LN14@operator

; 637  :     if (m_Data != NULL) {

	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	SHORT $LN60@operator

; 773  :     unsigned long cRef = InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount));

	or	eax, -1
	lock	 xadd	 DWORD PTR [edi+8], eax
	dec	eax

; 774  :     if (cRef == 0) {

	jne	SHORT $LN60@operator

; 930  :     if (m_wstr != NULL) {

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN65@operator

; 931  :         ::SysFreeString(m_wstr);

	push	eax
	call	DWORD PTR __imp__SysFreeString@4

; 932  :         m_wstr = NULL;

	mov	DWORD PTR [edi], 0
$LN65@operator:

; 933  :     }
; 934  : 
; 935  :     if (m_str != NULL) {

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN66@operator

; 936  :         delete [] m_str;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 937  :         m_str = NULL;

	mov	DWORD PTR [edi+4], 0
$LN66@operator:
	push	12					; 0000000cH
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN60@operator:

; 416  :         _com_issue_error(E_OUTOFMEMORY);
; 417  :     }
; 418  :     else {
; 419  :         _Free();
; 420  :         m_Data = newData;

	mov	DWORD PTR [ebx], esi

; 421  :     }
; 422  : 
; 423  :     return *this;

	mov	eax, ebx

; 424  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN14@operator:
	push	-2147024882				; 8007000eH
	call	?_com_issue_error@@YGXJ@Z		; _com_issue_error
$LN72@operator:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??Y_bstr_t@@QAEAAV0@ABV0@@Z$0:
	push	12					; 0000000cH
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??Y_bstr_t@@QAEAAV0@ABV0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??Y_bstr_t@@QAEAAV0@ABV0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??Y_bstr_t@@QAEAAV0@ABV0@@Z ENDP			; _bstr_t::operator+=
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ?AddRef@Data_t@_bstr_t@@QAEKXZ
_TEXT	SEGMENT
?AddRef@Data_t@_bstr_t@@QAEKXZ PROC			; _bstr_t::Data_t::AddRef, COMDAT
; _this$ = ecx

; 767  :     InterlockedIncrement(reinterpret_cast<long*>(&m_RefCount));

	lea	eax, DWORD PTR [ecx+8]
	lock	 inc	 DWORD PTR [eax]

; 768  :     return m_RefCount;

	mov	eax, DWORD PTR [eax]

; 769  : }

	ret	0
?AddRef@Data_t@_bstr_t@@QAEKXZ ENDP			; _bstr_t::Data_t::AddRef
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ?_AddRef@_bstr_t@@AAEXXZ
_TEXT	SEGMENT
?_AddRef@_bstr_t@@AAEXXZ PROC				; _bstr_t::_AddRef, COMDAT
; _this$ = ecx

; 628  :     if (m_Data != NULL) {

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN2@AddRef

; 767  :     InterlockedIncrement(reinterpret_cast<long*>(&m_RefCount));

	lock	 inc	 DWORD PTR [eax+8]
$LN2@AddRef:

; 629  :         m_Data->AddRef();
; 630  :     }
; 631  : }

	ret	0
?_AddRef@_bstr_t@@AAEXXZ ENDP				; _bstr_t::_AddRef
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ??0_bstr_t@@QAE@ABV0@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0_bstr_t@@QAE@ABV0@@Z PROC				; _bstr_t::_bstr_t, COMDAT
; _this$ = ecx

; 304  : {

	push	ebp
	mov	ebp, esp

; 303  :     : m_Data(s.m_Data)

	mov	eax, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 628  :     if (m_Data != NULL) {

	test	eax, eax
	je	SHORT $LN8@bstr_t

; 767  :     InterlockedIncrement(reinterpret_cast<long*>(&m_RefCount));

	lock	 inc	 DWORD PTR [eax+8]
$LN8@bstr_t:

; 305  :     _AddRef();
; 306  : }

	mov	eax, ecx
	pop	ebp
	ret	4
??0_bstr_t@@QAE@ABV0@@Z ENDP				; _bstr_t::_bstr_t
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ?_Free@Data_t@_bstr_t@@AAEXXZ
_TEXT	SEGMENT
?_Free@Data_t@_bstr_t@@AAEXXZ PROC			; _bstr_t::Data_t::_Free, COMDAT
; _this$ = ecx

; 929  : {

	push	esi
	mov	esi, ecx

; 930  :     if (m_wstr != NULL) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Free

; 931  :         ::SysFreeString(m_wstr);

	push	eax
	call	DWORD PTR __imp__SysFreeString@4

; 932  :         m_wstr = NULL;

	mov	DWORD PTR [esi], 0
$LN2@Free:

; 933  :     }
; 934  : 
; 935  :     if (m_str != NULL) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN3@Free

; 936  :         delete [] m_str;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 937  :         m_str = NULL;

	mov	DWORD PTR [esi+4], 0
$LN3@Free:

; 938  :     }
; 939  : }

	pop	esi
	ret	0
?_Free@Data_t@_bstr_t@@AAEXXZ ENDP			; _bstr_t::Data_t::_Free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ??1Data_t@_bstr_t@@AAE@XZ
_TEXT	SEGMENT
??1Data_t@_bstr_t@@AAE@XZ PROC				; _bstr_t::Data_t::~Data_t, COMDAT
; _this$ = ecx

; 922  : {

	push	esi
	mov	esi, ecx

; 930  :     if (m_wstr != NULL) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@Data_t

; 931  :         ::SysFreeString(m_wstr);

	push	eax
	call	DWORD PTR __imp__SysFreeString@4

; 932  :         m_wstr = NULL;

	mov	DWORD PTR [esi], 0
$LN4@Data_t:

; 933  :     }
; 934  : 
; 935  :     if (m_str != NULL) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN5@Data_t

; 936  :         delete [] m_str;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 937  :         m_str = NULL;

	mov	DWORD PTR [esi+4], 0
$LN5@Data_t:
	pop	esi

; 923  :     _Free();
; 924  : }

	ret	0
??1Data_t@_bstr_t@@AAE@XZ ENDP				; _bstr_t::Data_t::~Data_t
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ??_GData_t@_bstr_t@@AAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GData_t@_bstr_t@@AAEPAXI@Z PROC			; _bstr_t::Data_t::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 930  :     if (m_wstr != NULL) {

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@scalar

; 931  :         ::SysFreeString(m_wstr);

	push	eax
	call	DWORD PTR __imp__SysFreeString@4

; 932  :         m_wstr = NULL;

	mov	DWORD PTR [esi], 0
$LN7@scalar:

; 933  :     }
; 934  : 
; 935  :     if (m_str != NULL) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN8@scalar

; 936  :         delete [] m_str;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 937  :         m_str = NULL;

	mov	DWORD PTR [esi+4], 0
$LN8@scalar:
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	mov	eax, esi
	pop	esi
	ret	4
??_GData_t@_bstr_t@@AAEPAXI@Z ENDP			; _bstr_t::Data_t::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ?Release@Data_t@_bstr_t@@QAEKXZ
_TEXT	SEGMENT
?Release@Data_t@_bstr_t@@QAEKXZ PROC			; _bstr_t::Data_t::Release, COMDAT
; _this$ = ecx

; 772  : {

	push	esi
	push	edi
	mov	esi, ecx

; 773  :     unsigned long cRef = InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount));

	or	edi, -1
	lock	 xadd	 DWORD PTR [esi+8], edi
	dec	edi

; 774  :     if (cRef == 0) {

	jne	SHORT $LN16@Release

; 775  :         delete this;

	test	esi, esi
	je	SHORT $LN16@Release

; 930  :     if (m_wstr != NULL) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN12@Release

; 931  :         ::SysFreeString(m_wstr);

	push	eax
	call	DWORD PTR __imp__SysFreeString@4

; 932  :         m_wstr = NULL;

	mov	DWORD PTR [esi], 0
$LN12@Release:

; 933  :     }
; 934  : 
; 935  :     if (m_str != NULL) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN13@Release

; 936  :         delete [] m_str;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 937  :         m_str = NULL;

	mov	DWORD PTR [esi+4], 0
$LN13@Release:
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN16@Release:

; 776  :     }
; 777  : 
; 778  :     return cRef;
; 779  : }

	mov	eax, edi
	pop	edi
	pop	esi
	ret	0
?Release@Data_t@_bstr_t@@QAEKXZ ENDP			; _bstr_t::Data_t::Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ?_Free@_bstr_t@@AAEXXZ
_TEXT	SEGMENT
?_Free@_bstr_t@@AAEXXZ PROC				; _bstr_t::_Free, COMDAT
; _this$ = ecx

; 636  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 637  :     if (m_Data != NULL) {

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN2@Free

; 773  :     unsigned long cRef = InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount));

	or	eax, -1
	lock	 xadd	 DWORD PTR [esi+8], eax
	dec	eax

; 774  :     if (cRef == 0) {

	jne	SHORT $LN10@Free

; 930  :     if (m_wstr != NULL) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN15@Free

; 931  :         ::SysFreeString(m_wstr);

	push	eax
	call	DWORD PTR __imp__SysFreeString@4

; 932  :         m_wstr = NULL;

	mov	DWORD PTR [esi], 0
$LN15@Free:

; 933  :     }
; 934  : 
; 935  :     if (m_str != NULL) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN16@Free

; 936  :         delete [] m_str;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 937  :         m_str = NULL;

	mov	DWORD PTR [esi+4], 0
$LN16@Free:
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@Free:

; 638  :         m_Data->Release();
; 639  :         m_Data = NULL;

	mov	DWORD PTR [edi], 0
$LN2@Free:
	pop	edi

; 640  :     }
; 641  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?_Free@_bstr_t@@AAEXXZ ENDP				; _bstr_t::_Free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ??1_bstr_t@@QAE@XZ
_TEXT	SEGMENT
??1_bstr_t@@QAE@XZ PROC					; _bstr_t::~_bstr_t, COMDAT
; _this$ = ecx

; 342  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 637  :     if (m_Data != NULL) {

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN4@bstr_t

; 773  :     unsigned long cRef = InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount));

	or	eax, -1
	lock	 xadd	 DWORD PTR [esi+8], eax
	dec	eax

; 774  :     if (cRef == 0) {

	jne	SHORT $LN12@bstr_t

; 930  :     if (m_wstr != NULL) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN17@bstr_t

; 931  :         ::SysFreeString(m_wstr);

	push	eax
	call	DWORD PTR __imp__SysFreeString@4

; 932  :         m_wstr = NULL;

	mov	DWORD PTR [esi], 0
$LN17@bstr_t:

; 933  :     }
; 934  : 
; 935  :     if (m_str != NULL) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN18@bstr_t

; 936  :         delete [] m_str;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 937  :         m_str = NULL;

	mov	DWORD PTR [esi+4], 0
$LN18@bstr_t:
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@bstr_t:

; 639  :         m_Data = NULL;

	mov	DWORD PTR [edi], 0
$LN4@bstr_t:
	pop	edi

; 343  :     _Free();
; 344  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??1_bstr_t@@QAE@XZ ENDP					; _bstr_t::~_bstr_t
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ??H@YA?AV_bstr_t@@PB_WABV0@@Z
_TEXT	SEGMENT
$T2 = -24						; size = 4
___$ReturnUdt$ = -20					; size = 4
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_s2$ = 8						; size = 4
??H@YA?AV_bstr_t@@PB_WABV0@@Z PROC			; operator+, COMDAT
; ___$ReturnUdt$ = ecx
; _s1$ = edx

; 455  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??H@YA?AV_bstr_t@@PB_WABV0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, edx
	mov	edi, ecx
	mov	DWORD PTR ___$ReturnUdt$[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T1[ebp], 0

; 915  :     return ::operator new(sz);

	push	12					; 0000000cH
	mov	DWORD PTR [edi], 0
	call	??2@YAPAXI@Z				; operator new

; 321  :     : m_Data(new Data_t(s))

	mov	esi, eax

; 915  :     return ::operator new(sz);

	add	esp, 4

; 321  :     : m_Data(new Data_t(s))

	mov	DWORD PTR $T2[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	esi, esi
	je	SHORT $LN10@operator
	xorps	xmm0, xmm0
	movq	QWORD PTR [esi], xmm0
	mov	DWORD PTR [esi+8], 0

; 691  :     m_wstr = ::SysAllocString(s);

	push	ebx
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 1
	call	DWORD PTR __imp__SysAllocString@4
	mov	DWORD PTR [esi], eax

; 692  : 
; 693  :     if (m_wstr == NULL && s != NULL) {

	test	eax, eax
	jne	SHORT $LN11@operator
	test	ebx, ebx
	jne	SHORT $LN25@operator
	jmp	SHORT $LN11@operator
$LN10@operator:

; 321  :     : m_Data(new Data_t(s))

	xor	esi, esi
$LN11@operator:
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [edi], esi

; 322  : {
; 323  :     if (m_Data == NULL) {

	test	esi, esi
	je	SHORT $LN26@operator

; 456  :     _bstr_t b = s1;
; 457  :     b += s2;

	push	DWORD PTR _s2$[ebp]

; 458  : 
; 459  :     return b;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, edi
	mov	DWORD PTR $T1[ebp], 1
	call	??Y_bstr_t@@QAEAAV0@ABV0@@Z		; _bstr_t::operator+=
	mov	eax, edi

; 460  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@operator:

; 694  :         _com_issue_error(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?_com_issue_error@@YGXJ@Z		; _com_issue_error
$LN26@operator:

; 324  :         _com_issue_error(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?_com_issue_error@@YGXJ@Z		; _com_issue_error
$LN23@operator:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??H@YA?AV_bstr_t@@PB_WABV0@@Z$1:
	push	12					; 0000000cH
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??H@YA?AV_bstr_t@@PB_WABV0@@Z$0:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN4@operator
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
$LN4@operator:
	ret	0
__ehhandler$??H@YA?AV_bstr_t@@PB_WABV0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??H@YA?AV_bstr_t@@PB_WABV0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??H@YA?AV_bstr_t@@PB_WABV0@@Z ENDP			; operator+
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ?GetWString@Data_t@_bstr_t@@QAEAAPA_WXZ
_TEXT	SEGMENT
?GetWString@Data_t@_bstr_t@@QAEAAPA_WXZ PROC		; _bstr_t::Data_t::GetWString, COMDAT
; _this$ = ecx

; 819  :     return m_wstr;

	mov	eax, ecx

; 820  : }

	ret	0
?GetWString@Data_t@_bstr_t@@QAEAAPA_WXZ ENDP		; _bstr_t::Data_t::GetWString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\include\comutil.h
;	COMDAT ??B_bstr_t@@QBEPB_WXZ
_TEXT	SEGMENT
??B_bstr_t@@QBEPB_WXZ PROC				; _bstr_t::operator wchar_t const *, COMDAT
; _this$ = ecx

; 472  :     return (m_Data != NULL) ? m_Data->GetWString() : NULL;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR [eax]

; 473  : }

	ret	0
$LN3@operator:

; 472  :     return (m_Data != NULL) ? m_Data->GetWString() : NULL;

	xor	eax, eax

; 473  : }

	ret	0
??B_bstr_t@@QBEPB_WXZ ENDP				; _bstr_t::operator wchar_t const *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
;	COMDAT ??HATL@@YA?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@0@PB_WABV10@@Z
_TEXT	SEGMENT
$T8 = -20						; size = 4
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_psz1$ = 12						; size = 4
$T9 = 16						; size = 4
_str2$ = 16						; size = 4
??HATL@@YA?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@0@PB_WABV10@@Z PROC ; ATL::operator+, COMDAT

; 2405 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??HATL@@YA?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@0@PB_WABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 523  : 		IAtlStringMgr* pStringMgr = GetData()->pStringMgr;

	mov	edi, DWORD PTR _str2$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 2405 : 	{

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T1[ebp], 0
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 523  : 		IAtlStringMgr* pStringMgr = GetData()->pStringMgr;

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax-16]

; 524  : 		return pStringMgr ? pStringMgr->Clone() : NULL;

	test	ecx, ecx
	je	SHORT $LN67@operator
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+16]
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 1434 : 		if(pStringMgr) { return pStringMgr; }

	test	ecx, ecx
	jne	SHORT $LN21@operator
$LN67@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 1437 : 		return pStringMgr->Clone();

	mov	ecx, eax
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+16]
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN73@operator
$LN21@operator:

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 59   : 		return (this+1);

	lea	edx, DWORD PTR [eax+16]

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [esi], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 2410 : 		return( strResult );

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 2410 : 		return( strResult );

	mov	DWORD PTR $T1[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

	mov	ecx, DWORD PTR [eax-12]

; 730  : 		if( psz == NULL )

	mov	eax, DWORD PTR _psz1$[ebp]

; 519  : 		return( GetData()->nDataLength );

	mov	DWORD PTR $T9[ebp], ecx

; 730  : 		if( psz == NULL )

	test	eax, eax
	jne	SHORT $LN42@operator

; 731  : 		{
; 732  : 			return( 0 );

	xor	edi, edi
	jmp	SHORT $LN41@operator
$LN42@operator:

; 733  : 		}
; 734  : 		return( int( wcslen( psz ) ) );

	mov	edi, eax
	lea	ebx, DWORD PTR [edi+2]
	npad	1
$LL68@operator:
	mov	ax, WORD PTR [edi]
	add	edi, 2
	test	ax, ax
	jne	SHORT $LL68@operator
	sub	edi, ebx
	sar	edi, 1
$LN41@operator:

; 765  : 		int nNewLength = nLength1+nLength2;

	lea	ebx, DWORD PTR [edi+ecx]

; 804  : 		if (nLength < 0)

	test	ebx, ebx
	js	SHORT $LN60@operator

; 805  : 			AtlThrow(E_INVALIDARG);
; 806  : 
; 807  : 		CStringData* pOldData = GetData();
; 808  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false
; 809  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

	mov	eax, DWORD PTR [edx-8]
	mov	ecx, 1
	sub	ecx, DWORD PTR [edx-4]
	sub	eax, ebx

; 810  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

	or	ecx, eax
	jge	SHORT $LN50@operator

; 811  : 		{
; 812  : 			PrepareWrite2( nLength );

	push	ebx
	mov	ecx, esi
	call	?PrepareWrite2@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2
$LN50@operator:

; 508  : 		return( PrepareWrite( nMinBufferLength ) );

	mov	esi, DWORD PTR [esi]

; 767  : 		CopyChars( pszBuffer, nLength1, psz1, nLength1 );

	push	edi
	push	DWORD PTR _psz1$[ebp]
	push	edi
	push	esi
	call	?CopyChars@?$CSimpleStringT@_W$0A@@ATL@@SAXPA_WIPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::CopyChars

; 768  : 		CopyChars( pszBuffer+nLength1, nLength2, psz2, nLength2 );

	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	push	DWORD PTR $T8[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+edi*2]
	push	eax
	call	?CopyChars@?$CSimpleStringT@_W$0A@@ATL@@SAXPA_WIPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::CopyChars

; 871  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 768  : 		CopyChars( pszBuffer+nLength1, nLength2, psz2, nLength2 );

	add	esp, 32					; 00000020H

; 871  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	mov	ecx, DWORD PTR [eax]
	cmp	ebx, DWORD PTR [ecx-8]
	jg	SHORT $LN60@operator

; 873  : 
; 874  : 		GetData()->nDataLength = nLength;

	mov	DWORD PTR [ecx-12], ebx

; 875  : 		m_pszData[nLength] = 0;

	xor	edx, edx
	mov	ecx, DWORD PTR [eax]
	mov	WORD PTR [ecx+ebx*2], dx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 2411 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN60@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 872  : 			AtlThrow(E_INVALIDARG);

	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN73@operator:

; 205  : 		ATLENSURE( pStringMgr != NULL );

	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN70@operator:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??HATL@@YA?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@0@PB_WABV10@@Z$0:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN4@operator
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
$LN4@operator:
	ret	0
__ehhandler$??HATL@@YA?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@0@PB_WABV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??HATL@@YA?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@0@PB_WABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??HATL@@YA?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@0@PB_WABV10@@Z ENDP ; ATL::operator+
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
;	COMDAT ??8ATL@@YA_NABV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@0@0@Z
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
??8ATL@@YA_NABV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@0@0@Z PROC ; ATL::operator==, COMDAT

; 2472 : 	{

	push	ebp
	mov	ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 377  : 		return( m_pszData );

	mov	eax, DWORD PTR _str2$[ebp]
	mov	ecx, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlcore.h

; 81   : 	return (psz != NULL);

	test	ecx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 1444 : 		ATLENSURE( AtlIsValidString( psz ) );

	je	SHORT $LN27@operator

; 564  : 		return wcscmp( pszA, pszB );

	mov	eax, DWORD PTR _str1$[ebp]
	mov	eax, DWORD PTR [eax]
$LL21@operator:
	mov	dx, WORD PTR [eax]
	cmp	dx, WORD PTR [ecx]
	jne	SHORT $LN22@operator
	test	dx, dx
	je	SHORT $LN23@operator
	mov	dx, WORD PTR [eax+2]
	cmp	dx, WORD PTR [ecx+2]
	jne	SHORT $LN22@operator
	add	eax, 4
	add	ecx, 4
	test	dx, dx
	jne	SHORT $LL21@operator
$LN23@operator:
	xor	eax, eax

; 2473 : 		return( str1.Compare( str2 ) == 0 );

	test	eax, eax
	sete	al

; 2474 : 	}

	pop	ebp
	ret	0
$LN22@operator:

; 564  : 		return wcscmp( pszA, pszB );

	sbb	eax, eax
	or	eax, 1

; 2473 : 		return( str1.Compare( str2 ) == 0 );

	test	eax, eax
	sete	al

; 2474 : 	}

	pop	ebp
	ret	0
$LN27@operator:

; 1444 : 		ATLENSURE( AtlIsValidString( psz ) );

	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN25@operator:
	int	3
??8ATL@@YA_NABV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@0@0@Z ENDP ; ATL::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_memcpy_s.h
;	COMDAT _memcpy_s
_TEXT	SEGMENT
__Source$ = 8						; size = 4
__SourceSize$ = 12					; size = 4
_memcpy_s PROC						; COMDAT
; __Destination$ = ecx
; __DestinationSize$ = edx

; 41   :     {

	push	ebp
	mov	ebp, esp
	push	esi

; 42   :         if (_SourceSize == 0)

	mov	esi, DWORD PTR __SourceSize$[ebp]
	push	edi
	mov	edi, edx
	test	esi, esi
	jne	SHORT $LN2@memcpy_s

; 43   :         {
; 44   :             return 0;

	pop	edi
	xor	eax, eax

; 61   :     }

	pop	esi
	pop	ebp
	ret	0
$LN2@memcpy_s:

; 45   :         }
; 46   : 
; 47   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

	test	ecx, ecx
	jne	SHORT $LN3@memcpy_s
	call	__errno
	mov	DWORD PTR [eax], 22			; 00000016H
	call	__invalid_parameter_noinfo
	pop	edi
	mov	eax, 22					; 00000016H

; 61   :     }

	pop	esi
	pop	ebp
	ret	0
$LN3@memcpy_s:
	push	ebx

; 48   :         if (_Source == NULL || _DestinationSize < _SourceSize)

	mov	ebx, DWORD PTR __Source$[ebp]
	test	ebx, ebx
	je	SHORT $LN5@memcpy_s
	cmp	edi, esi
	jb	SHORT $LN5@memcpy_s

; 57   :         }
; 58   : #pragma warning(suppress:4996) // Deprecation
; 59   :         memcpy(_Destination, _Source, _SourceSize);

	push	esi
	push	ebx
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 60   :         return 0;

	xor	eax, eax
	pop	ebx
	pop	edi

; 61   :     }

	pop	esi
	pop	ebp
	ret	0
$LN5@memcpy_s:

; 49   :         {
; 50   :             memset(_Destination, 0, _DestinationSize);

	push	edi
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 51   : 
; 52   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

	test	ebx, ebx
	jne	SHORT $LN6@memcpy_s
	call	__errno
	mov	DWORD PTR [eax], 22			; 00000016H
	call	__invalid_parameter_noinfo
$LN7@memcpy_s:

; 54   : 
; 55   :             // Unreachable, but required to suppress /analyze warnings:
; 56   :             return EINVAL;

	pop	ebx
	pop	edi
	mov	eax, 22					; 00000016H

; 61   :     }

	pop	esi
	pop	ebp
	ret	0
$LN6@memcpy_s:

; 53   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

	cmp	edi, esi
	jae	SHORT $LN7@memcpy_s
	call	__errno
	mov	DWORD PTR [eax], 34			; 00000022H
	call	__invalid_parameter_noinfo
	pop	ebx
	pop	edi
	mov	eax, 34					; 00000022H

; 61   :     }

	pop	esi
	pop	ebp
	ret	0
_memcpy_s ENDP
_TEXT	ENDS
END
