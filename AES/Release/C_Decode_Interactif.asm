; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28106.4 

	TITLE	i:\projets\aes\aes\aes\c_decode_interactif.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp__GetLastError@0:PROC
EXTRN	?DoModal@CFileDialog@@UAEHXZ:PROC		; CFileDialog::DoModal
EXTRN	?GetOFN@CFileDialog@@QAEAAUtagOFNW@@XZ:PROC	; CFileDialog::GetOFN
EXTRN	??1CFileDialog@@UAE@XZ:PROC			; CFileDialog::~CFileDialog
EXTRN	?AfxGetThread@@YGPAVCWinThread@@XZ:PROC		; AfxGetThread
EXTRN	??0CFileDialog@@QAE@HPB_W0K0PAVCWnd@@KH@Z:PROC	; CFileDialog::CFileDialog
EXTRN	_wcsnlen:PROC
EXTRN	__imp__GetCurrentDirectoryW@8:PROC
PUBLIC	?ReleaseBuffer@?$CSimpleStringT@_W$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::ReleaseBuffer
PUBLIC	?StringLengthN@?$CSimpleStringT@_W$0A@@ATL@@SAHPB_WI@Z ; ATL::CSimpleStringT<wchar_t,0>::StringLengthN
PUBLIC	??Y?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEAAV01@ABV?$CSimpleStringT@_W$0A@@1@@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::operator+=
PUBLIC	??Y?$CSimpleStringT@_W$0A@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CSimpleStringT<wchar_t,0>::operator+=
PUBLIC	?Append@?$CSimpleStringT@_W$0A@@ATL@@QAEXABV12@@Z ; ATL::CSimpleStringT<wchar_t,0>::Append
PUBLIC	?Append@?$CSimpleStringT@_W$0A@@ATL@@QAEXPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::Append
PUBLIC	?AfxGetMainWnd@@YGPAVCWnd@@XZ			; AfxGetMainWnd
PUBLIC	?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z	; C_Decode_Interactif::Open_File
PUBLIC	?__autoclassinit2@CFileDialog@@QAEXI@Z		; CFileDialog::__autoclassinit2
PUBLIC	?Current_Dir@C_Decode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ ; C_Decode_Interactif::Current_Dir
PUBLIC	??1C_Error_Message@@QAE@XZ			; C_Error_Message::~C_Error_Message
PUBLIC	??_GC_Error_Message@@QAEPAXI@Z			; C_Error_Message::`scalar deleting destructor'
PUBLIC	?__autoclassinit2@C_Error_Message@@QAEXI@Z	; C_Error_Message::__autoclassinit2
PUBLIC	??0C_Error_Message@@QAE@XZ			; C_Error_Message::C_Error_Message
PUBLIC	??0C_Decode_Interactif@@QAE@XZ			; C_Decode_Interactif::C_Decode_Interactif
PUBLIC	?Go@C_Decode_Interactif@@QAE_NXZ		; C_Decode_Interactif::Go
PUBLIC	??1C_Decode_Interactif@@QAE@XZ			; C_Decode_Interactif::~C_Decode_Interactif
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1C_Decode_Interactif@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Go@C_Decode_Interactif@@QAE_NXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Go@C_Decode_Interactif@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Go@C_Decode_Interactif@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Go@C_Decode_Interactif@@QAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Go@C_Decode_Interactif@@QAE_NXZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$?Go@C_Decode_Interactif@@QAE_NXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?Go@C_Decode_Interactif@@QAE_NXZ$6
	DD	03H
	DD	FLAT:__unwindfunclet$?Go@C_Decode_Interactif@@QAE_NXZ$8
	DD	04H
	DD	FLAT:__unwindfunclet$?Go@C_Decode_Interactif@@QAE_NXZ$10
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0C_Decode_Interactif@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0C_Decode_Interactif@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0C_Decode_Interactif@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0C_Decode_Interactif@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0C_Decode_Interactif@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0C_Decode_Interactif@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0C_Decode_Interactif@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0C_Decode_Interactif@@QAE@XZ$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0C_Error_Message@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_GC_Error_Message@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1C_Error_Message@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Current_Dir@C_Decode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Current_Dir@C_Decode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ$0
__ehfuncinfo$?Current_Dir@C_Decode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Current_Dir@C_Decode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z$3
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
;	COMDAT ??1C_Decode_Interactif@@QAE@XZ
_TEXT	SEGMENT
$T12 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1C_Decode_Interactif@@QAE@XZ PROC			; C_Decode_Interactif::~C_Decode_Interactif, COMDAT
; _this$ = ecx

; 20   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1C_Decode_Interactif@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 21   : 	delete pt_decode;

	mov	ebx, DWORD PTR [esi+20]
	or	edi, -1
	test	ebx, ebx
	je	SHORT $LN12@C_Decode_I
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp

; 19   : 	delete pt_Erreur;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR $T12[ebp], eax
	test	eax, eax
	je	SHORT $LN20@C_Decode_I
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [eax]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, edi

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN32@C_Decode_I

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN32@C_Decode_I:
	push	4
	push	DWORD PTR $T12[ebp]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN20@C_Decode_I:

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [ebx+4]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, edi

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN41@C_Decode_I

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN41@C_Decode_I:
	push	24					; 00000018H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@C_Decode_I:
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 22   : 	delete pt_pass;

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN44@C_Decode_I
	push	1
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN44@C_Decode_I:

; 23   : 	delete pt_Erreur;

	mov	ebx, DWORD PTR [esi+28]
	test	ebx, ebx
	je	SHORT $LN47@C_Decode_I
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [ebx]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, edi

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN59@C_Decode_I

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN59@C_Decode_I:
	push	4
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN47@C_Decode_I:
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 24   : 	delete pt_fichier;

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN62@C_Decode_I
	push	1
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN62@C_Decode_I:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [esi+36]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, edi

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN71@C_Decode_I

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN71@C_Decode_I:

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [esi+16]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, edi

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN80@C_Decode_I

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN80@C_Decode_I:

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [esi+12]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, edi

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN89@C_Decode_I

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN89@C_Decode_I:

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [esi+8]
	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], edi
	dec	edi
	test	edi, edi
	jg	SHORT $LN98@C_Decode_I

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN98@C_Decode_I:
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 25   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1C_Decode_Interactif@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1C_Decode_Interactif@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1C_Decode_Interactif@@QAE@XZ ENDP			; C_Decode_Interactif::~C_Decode_Interactif
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxcoll.inl
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
;	COMDAT ?Go@C_Decode_Interactif@@QAE_NXZ
_TEXT	SEGMENT
$T32 = -72						; size = 4
_this$1$ = -68						; size = 4
_this$GSCopy$1$ = -64					; size = 4
tv1672 = -60						; size = 4
tv1659 = -60						; size = 4
$T15 = -60						; size = 4
$T11 = -56						; size = 4
$T9 = -56						; size = 4
$T6 = -56						; size = 4
$T2 = -56						; size = 4
tv1669 = -52						; size = 4
_this$ = -52						; size = 4
_this$ = -52						; size = 4
_this$ = -52						; size = 4
_pNewData$1$ = -48					; size = 4
tv1670 = -48						; size = 4
tv1668 = -48						; size = 4
tv1667 = -48						; size = 4
_this$ = -48						; size = 4
$T33 = -41						; size = 1
$T34 = -41						; size = 1
_timebuffer$35 = -40					; size = 16
_timebuffer$36 = -40					; size = 16
_timebuffer$37 = -40					; size = 16
_tt$38 = -24						; size = 4
_Local$39 = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Go@C_Decode_Interactif@@QAE_NXZ PROC			; C_Decode_Interactif::Go, COMDAT
; _this$ = ecx

; 99   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Go@C_Decode_Interactif@@QAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], esi

; 101  : 	AjustFileName *pt_Ajust = new AjustFileName;

	push	1
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	mov	DWORD PTR $T32[ebp], eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	edi, edi
	je	SHORT $LN6@Go
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxcoll.inl

; 286  : 	{ SetSize(0); }

	push	-1
	push	0
	mov	ecx, OFFSET ?List@@3VCStringArray@@A	; List
	call	?SetSize@CStringArray@@QAEXHH@Z		; CStringArray::SetSize
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 101  : 	AjustFileName *pt_Ajust = new AjustFileName;

	jmp	SHORT $LN7@Go
$LN6@Go:
	xor	edi, edi
	mov	DWORD PTR $T32[ebp], edi
$LN7@Go:

; 102  : 
; 103  : 	// Call EncryptFile to do the actual encryption.
; 104  : 	BOOL status = Mess.LoadString(IDS_STRING182);

	lea	ebx, DWORD PTR [esi+36]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	push	182					; 000000b6H
	mov	ecx, ebx
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	eax, DWORD PTR [ebx]

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [eax-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN37@Go

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [eax-12]
	mov	ecx, ebx
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	eax, DWORD PTR [ebx]
$LN37@Go:
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 106  : 	if (Open_File(Mess.GetBuffer()) == true)

	push	eax
	mov	ecx, esi
	call	?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z ; C_Decode_Interactif::Open_File
	cmp	al, 1
	jne	$LN324@Go
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	lea	eax, DWORD PTR [esi+12]
	mov	DWORD PTR _tt$38[ebp], 0
	mov	DWORD PTR _this$1$[ebp], eax
	mov	eax, DWORD PTR [eax]
	lea	esi, DWORD PTR [eax-16]
	mov	DWORD PTR tv1669[ebp], eax
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 108  : 		CString tt = pt_fichier->Supprime_Extension(pszSource);

	push	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	ecx, DWORD PTR [esi]
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 108  : 		CString tt = pt_fichier->Supprime_Extension(pszSource);

	mov	DWORD PTR _this$[ebp], esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+16]

; 69   : 		return nRefs < 0;

	cmp	DWORD PTR [esi+12], 0

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	edx, eax

; 69   : 		return nRefs < 0;

	lea	eax, DWORD PTR [esi+12]

; 883  : 		if( !pData->IsLocked() && (pNewStringMgr == pData->pStringMgr) )

	jl	SHORT $LN53@Go
	cmp	edx, DWORD PTR [esi]
	jne	SHORT $LN53@Go

; 65   : 		_InterlockedIncrement(&nRefs);

	lock	 inc	 DWORD PTR [eax]

; 887  : 		}

	jmp	SHORT $LN54@Go
$LN53@Go:

; 888  : 		else
; 889  : 		{
; 890  : 			pNewData = pNewStringMgr->Allocate( pData->nDataLength, sizeof( XCHAR ) );

	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [esi+4]
	push	2
	push	DWORD PTR [ecx]
	mov	DWORD PTR tv1659[ebp], ecx
	mov	ecx, edx
	call	DWORD PTR [eax]
	mov	esi, eax

; 891  : 			if( pNewData == NULL )

	test	esi, esi
	je	$LN333@Go

; 894  : 			}
; 895  : 			pNewData->nDataLength = pData->nDataLength;

	mov	ecx, DWORD PTR tv1659[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+4], eax

; 896  : 			CopyChars( PXSTR( pNewData->data() ), pData->nDataLength+1,

	mov	eax, DWORD PTR [ecx]
	inc	eax
	push	eax
	push	DWORD PTR tv1669[ebp]
	push	eax

; 59   : 		return (this+1);

	lea	eax, DWORD PTR [esi+16]

; 896  : 			CopyChars( PXSTR( pNewData->data() ), pData->nDataLength+1,

	push	eax
	call	?CopyChars@?$CSimpleStringT@_W$0A@@ATL@@SAXPA_WIPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::CopyChars
	add	esp, 16					; 00000010H
$LN54@Go:

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	ecx, DWORD PTR _this$[ebp]

; 59   : 		return (this+1);

	lea	eax, DWORD PTR [esi+16]

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [ecx], eax
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 108  : 		CString tt = pt_fichier->Supprime_Extension(pszSource);

	lea	eax, DWORD PTR _tt$38[ebp]
	push	eax
	call	?Supprime_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z ; Manipulation_Fichier::Supprime_Extension

; 109  : 		status =  Mess.LoadString(IDS_STRING206);

	push	206					; 000000ceH
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	eax, DWORD PTR [ebx]
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 110  : 		CString  Local = pt_fichier->Ajoute_Extension (pt_fichier->Supprime_Extension(pszSource),Mess);

	push	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	lea	esi, DWORD PTR [eax-16]
	mov	DWORD PTR _Local$39[ebp], 0

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	ecx, DWORD PTR [esi]

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	DWORD PTR tv1668[ebp], eax
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 110  : 		CString  Local = pt_fichier->Ajoute_Extension (pt_fichier->Supprime_Extension(pszSource),Mess);

	mov	DWORD PTR $T6[ebp], esp
	mov	DWORD PTR _this$[ebp], esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+16]

; 69   : 		return nRefs < 0;

	cmp	DWORD PTR [esi+12], 0

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	ecx, eax

; 69   : 		return nRefs < 0;

	lea	eax, DWORD PTR [esi+12]

; 883  : 		if( !pData->IsLocked() && (pNewStringMgr == pData->pStringMgr) )

	jl	SHORT $LN108@Go
	cmp	ecx, DWORD PTR [esi]
	jne	SHORT $LN108@Go

; 65   : 		_InterlockedIncrement(&nRefs);

	lock	 inc	 DWORD PTR [eax]

; 887  : 		}

	jmp	SHORT $LN109@Go
$LN108@Go:

; 888  : 		else
; 889  : 		{
; 890  : 			pNewData = pNewStringMgr->Allocate( pData->nDataLength, sizeof( XCHAR ) );

	mov	eax, DWORD PTR [ecx]
	lea	ebx, DWORD PTR [esi+4]
	push	2
	push	DWORD PTR [ebx]
	call	DWORD PTR [eax]
	mov	esi, eax

; 891  : 			if( pNewData == NULL )

	test	esi, esi
	je	$LN334@Go

; 894  : 			}
; 895  : 			pNewData->nDataLength = pData->nDataLength;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi+4], eax

; 896  : 			CopyChars( PXSTR( pNewData->data() ), pData->nDataLength+1,

	mov	eax, DWORD PTR [ebx]
	inc	eax
	push	eax
	push	DWORD PTR tv1668[ebp]
	push	eax

; 59   : 		return (this+1);

	lea	eax, DWORD PTR [esi+16]

; 896  : 			CopyChars( PXSTR( pNewData->data() ), pData->nDataLength+1,

	push	eax
	call	?CopyChars@?$CSimpleStringT@_W$0A@@ATL@@SAXPA_WIPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::CopyChars
	add	esp, 16					; 00000010H
$LN109@Go:

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	ecx, DWORD PTR _this$[ebp]

; 59   : 		return (this+1);

	lea	eax, DWORD PTR [esi+16]

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [ecx], eax
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 110  : 		CString  Local = pt_fichier->Ajoute_Extension (pt_fichier->Supprime_Extension(pszSource),Mess);

	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR tv1672[ebp], esp
	push	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	ecx, DWORD PTR _this$1$[ebp]
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 110  : 		CString  Local = pt_fichier->Ajoute_Extension (pt_fichier->Supprime_Extension(pszSource),Mess);

	mov	DWORD PTR _this$[ebp], esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	eax, DWORD PTR [ecx]

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	ecx, DWORD PTR [eax-16]

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	DWORD PTR tv1667[ebp], eax
	lea	esi, DWORD PTR [eax-16]

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+16]

; 69   : 		return nRefs < 0;

	cmp	DWORD PTR [esi+12], 0

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	ecx, eax

; 69   : 		return nRefs < 0;

	lea	eax, DWORD PTR [esi+12]

; 883  : 		if( !pData->IsLocked() && (pNewStringMgr == pData->pStringMgr) )

	jl	SHORT $LN134@Go
	cmp	ecx, DWORD PTR [esi]
	jne	SHORT $LN134@Go

; 65   : 		_InterlockedIncrement(&nRefs);

	lock	 inc	 DWORD PTR [eax]

; 887  : 		}

	jmp	SHORT $LN135@Go
$LN134@Go:

; 888  : 		else
; 889  : 		{
; 890  : 			pNewData = pNewStringMgr->Allocate( pData->nDataLength, sizeof( XCHAR ) );

	mov	eax, DWORD PTR [ecx]
	lea	ebx, DWORD PTR [esi+4]
	push	2
	push	DWORD PTR [ebx]
	call	DWORD PTR [eax]
	mov	esi, eax

; 891  : 			if( pNewData == NULL )

	test	esi, esi
	je	$LN335@Go

; 894  : 			}
; 895  : 			pNewData->nDataLength = pData->nDataLength;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi+4], eax

; 896  : 			CopyChars( PXSTR( pNewData->data() ), pData->nDataLength+1,

	mov	eax, DWORD PTR [ebx]
	inc	eax
	push	eax
	push	DWORD PTR tv1667[ebp]
	push	eax

; 59   : 		return (this+1);

	lea	eax, DWORD PTR [esi+16]

; 896  : 			CopyChars( PXSTR( pNewData->data() ), pData->nDataLength+1,

	push	eax
	call	?CopyChars@?$CSimpleStringT@_W$0A@@ATL@@SAXPA_WIPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::CopyChars
	add	esp, 16					; 00000010H
$LN135@Go:

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	ecx, DWORD PTR _this$[ebp]

; 59   : 		return (this+1);

	lea	eax, DWORD PTR [esi+16]
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 110  : 		CString  Local = pt_fichier->Ajoute_Extension (pt_fichier->Supprime_Extension(pszSource),Mess);

	push	DWORD PTR tv1672[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [ecx], eax
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 110  : 		CString  Local = pt_fichier->Ajoute_Extension (pt_fichier->Supprime_Extension(pszSource),Mess);

	call	?Supprime_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z ; Manipulation_Fichier::Supprime_Extension
	lea	eax, DWORD PTR _Local$39[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	eax
	call	?Ajoute_Extension@Manipulation_Fichier@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@0@Z ; Manipulation_Fichier::Ajoute_Extension

; 111  : 		Calcul_temps *pt_time = new Calcul_temps;

	push	24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR $T9[ebp], ebx
	test	ebx, ebx
	je	SHORT $LN8@Go
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp

; 13   : {

	mov	DWORD PTR [ebx], OFFSET ??_7Calcul_temps@@6B@

; 14   : 
; 15   : 	Start = Stop = 0;

	mov	DWORD PTR [ebx+16], 0
	mov	DWORD PTR [ebx+20], 0
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [ebx+12], 0
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 111  : 		Calcul_temps *pt_time = new Calcul_temps;

	jmp	SHORT $LN9@Go
$LN8@Go:
	xor	ebx, ebx
$LN9@Go:
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp

; 37   : 	errno_t erreur = _ftime_s(&timebuffer);

	lea	eax, DWORD PTR _timebuffer$37[ebp]
	push	eax
	call	__ftime64_s

; 38   : 	return (uint64_t)(((timebuffer.time * 1000) + timebuffer.millitm));

	mov	eax, DWORD PTR _timebuffer$37[ebp+4]
	mov	ecx, 1000				; 000003e8H
	mul	ecx
	mov	esi, eax
	mov	eax, DWORD PTR _timebuffer$37[ebp]
	mul	ecx
	mov	ecx, eax
	add	esi, edx
	movzx	eax, WORD PTR _timebuffer$37[ebp+8]
	cdq
	add	ecx, eax
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 113  : 		if (pt_decode->MyDecryptFile(pszSource.GetBuffer(), pt_Ajust->Do(Local).GetBuffer(), pt_pass->Get_Ressource_huff(IDR_MYFILE).GetBuffer()))

	lea	eax, DWORD PTR $T11[ebp]
	push	eax
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp

; 38   : 	return (uint64_t)(((timebuffer.time * 1000) + timebuffer.millitm));

	adc	esi, edx

; 20   : 	Start = Build();

	mov	DWORD PTR [ebx+8], ecx
	mov	DWORD PTR [ebx+12], esi
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 113  : 		if (pt_decode->MyDecryptFile(pszSource.GetBuffer(), pt_Ajust->Do(Local).GetBuffer(), pt_pass->Get_Ressource_huff(IDR_MYFILE).GetBuffer()))

	call	?Get_Ressource_huff@C_Password@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@H@Z ; C_Password::Get_Ressource_huff
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	ecx, DWORD PTR [esi]

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [ecx-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN185@Go

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [ecx-12]
	mov	ecx, esi
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	ecx, DWORD PTR [esi]
$LN185@Go:

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	esi, DWORD PTR _Local$39[ebp]
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 113  : 		if (pt_decode->MyDecryptFile(pszSource.GetBuffer(), pt_Ajust->Do(Local).GetBuffer(), pt_pass->Get_Ressource_huff(IDR_MYFILE).GetBuffer()))

	push	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	add	esi, -16				; fffffff0H
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 113  : 		if (pt_decode->MyDecryptFile(pszSource.GetBuffer(), pt_Ajust->Do(Local).GetBuffer(), pt_pass->Get_Ressource_huff(IDR_MYFILE).GetBuffer()))

	push	ecx
	mov	DWORD PTR _this$[ebp], esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+16]

; 69   : 		return nRefs < 0;

	cmp	DWORD PTR [esi+12], 0

; 882  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	ecx, eax

; 69   : 		return nRefs < 0;

	lea	eax, DWORD PTR [esi+12]

; 883  : 		if( !pData->IsLocked() && (pNewStringMgr == pData->pStringMgr) )

	jl	SHORT $LN199@Go
	cmp	ecx, DWORD PTR [esi]
	jne	SHORT $LN199@Go

; 65   : 		_InterlockedIncrement(&nRefs);

	lock	 inc	 DWORD PTR [eax]

; 887  : 		}

	jmp	SHORT $LN200@Go
$LN199@Go:

; 888  : 		else
; 889  : 		{
; 890  : 			pNewData = pNewStringMgr->Allocate( pData->nDataLength, sizeof( XCHAR ) );

	mov	eax, DWORD PTR [ecx]
	push	2
	push	DWORD PTR [esi+4]
	call	DWORD PTR [eax]
	mov	edx, eax
	mov	DWORD PTR _pNewData$1$[ebp], edx

; 891  : 			if( pNewData == NULL )

	test	edx, edx
	je	$LN336@Go

; 894  : 			}
; 895  : 			pNewData->nDataLength = pData->nDataLength;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx+4], eax

; 59   : 		return (this+1);

	lea	eax, DWORD PTR [esi+16]

; 896  : 			CopyChars( PXSTR( pNewData->data() ), pData->nDataLength+1,

	mov	ecx, DWORD PTR [esi+4]
	inc	ecx
	push	ecx
	push	eax
	push	ecx

; 59   : 		return (this+1);

	lea	eax, DWORD PTR [edx+16]

; 896  : 			CopyChars( PXSTR( pNewData->data() ), pData->nDataLength+1,

	push	eax
	call	?CopyChars@?$CSimpleStringT@_W$0A@@ATL@@SAXPA_WIPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::CopyChars
	mov	esi, DWORD PTR _pNewData$1$[ebp]
	add	esp, 16					; 00000010H
$LN200@Go:

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	ecx, DWORD PTR _this$[ebp]

; 59   : 		return (this+1);

	lea	eax, DWORD PTR [esi+16]

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [ecx], eax
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 113  : 		if (pt_decode->MyDecryptFile(pszSource.GetBuffer(), pt_Ajust->Do(Local).GetBuffer(), pt_pass->Get_Ressource_huff(IDR_MYFILE).GetBuffer()))

	lea	eax, DWORD PTR $T15[ebp]
	push	eax
	call	?Do@AjustFileName@@QAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@V23@@Z ; AjustFileName::Do
	mov	DWORD PTR tv1670[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	esi, DWORD PTR [eax]

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [esi-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN218@Go

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [esi-12]
	mov	ecx, eax
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	esi, DWORD PTR tv1670[ebp]
	mov	esi, DWORD PTR [esi]
$LN218@Go:

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ecx]

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [eax-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN225@Go

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [eax-12]
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ecx]
$LN225@Go:
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 113  : 		if (pt_decode->MyDecryptFile(pszSource.GetBuffer(), pt_Ajust->Do(Local).GetBuffer(), pt_pass->Get_Ressource_huff(IDR_MYFILE).GetBuffer()))

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	esi
	push	eax
	mov	ecx, DWORD PTR [ecx+20]
	call	?MyDecryptFile@C_AES_Decode@@QAE_NPA_W00@Z ; C_AES_Decode::MyDecryptFile
	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	or	esi, -1

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR $T15[ebp]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	ecx, esi
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 113  : 		if (pt_decode->MyDecryptFile(pszSource.GetBuffer(), pt_Ajust->Do(Local).GetBuffer(), pt_pass->Get_Ressource_huff(IDR_MYFILE).GetBuffer()))

	mov	BYTE PTR $T34[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	add	edx, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], ecx
	dec	ecx
	test	ecx, ecx
	jg	SHORT $LN238@Go

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN238@Go:
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 113  : 		if (pt_decode->MyDecryptFile(pszSource.GetBuffer(), pt_Ajust->Do(Local).GetBuffer(), pt_pass->Get_Ressource_huff(IDR_MYFILE).GetBuffer()))

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, esi

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR $T11[ebp]
	add	edx, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN247@Go

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN247@Go:
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 113  : 		if (pt_decode->MyDecryptFile(pszSource.GetBuffer(), pt_Ajust->Do(Local).GetBuffer(), pt_pass->Get_Ressource_huff(IDR_MYFILE).GetBuffer()))

	lea	eax, DWORD PTR _timebuffer$36[ebp]
	push	eax
	call	__ftime64_s
	mov	eax, DWORD PTR _timebuffer$36[ebp+4]
	mov	ecx, 1000				; 000003e8H
	add	esp, 4
	mul	ecx
	cmp	BYTE PTR $T34[ebp], 0
	je	SHORT $LN3@Go
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp

; 38   : 	return (uint64_t)(((timebuffer.time * 1000) + timebuffer.millitm));

	mov	edi, eax
	mov	eax, DWORD PTR _timebuffer$36[ebp]
	mul	ecx
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 117  : 			delete pt_time;

	push	1
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp

; 38   : 	return (uint64_t)(((timebuffer.time * 1000) + timebuffer.millitm));

	mov	esi, eax
	add	edi, edx
	movzx	eax, WORD PTR _timebuffer$36[ebp+8]
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 117  : 			delete pt_time;

	mov	ecx, ebx
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp

; 38   : 	return (uint64_t)(((timebuffer.time * 1000) + timebuffer.millitm));

	cdq
	add	esi, eax
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 116  : 			Calcul = pt_time->Read_time();

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp

; 25   : 	Stop =  Build();

	mov	DWORD PTR [ebx+16], esi

; 38   : 	return (uint64_t)(((timebuffer.time * 1000) + timebuffer.millitm));

	adc	edi, edx

; 30   : 	return (Stop - Start);

	sub	esi, DWORD PTR [ebx+8]

; 25   : 	Stop =  Build();

	mov	DWORD PTR [ebx+20], edi

; 30   : 	return (Stop - Start);

	sbb	edi, DWORD PTR [ebx+12]
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 116  : 			Calcul = pt_time->Read_time();

	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi

; 117  : 			delete pt_time;

	mov	eax, DWORD PTR [ebx]
	call	DWORD PTR [eax]

; 118  : 			delete pt_Ajust;

	mov	eax, DWORD PTR $T32[ebp]
	test	eax, eax
	je	SHORT $LN256@Go
	push	1
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN256@Go:
	mov	BYTE PTR $T33[ebp], 1
	jmp	SHORT $LN31@Go
$LN3@Go:
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp

; 38   : 	return (uint64_t)(((timebuffer.time * 1000) + timebuffer.millitm));

	mov	esi, eax
	mov	eax, DWORD PTR _timebuffer$35[ebp]
	mul	ecx
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 124  : 			status = Mess.LoadString(IDS_STRING185);

	push	185					; 000000b9H
; File I:\Projets\AES\AES\AES\Calcul_temps.cpp

; 38   : 	return (uint64_t)(((timebuffer.time * 1000) + timebuffer.millitm));

	mov	ecx, eax
	add	esi, edx
	movzx	eax, WORD PTR _timebuffer$35[ebp+8]
	cdq
	add	ecx, eax

; 25   : 	Stop =  Build();

	mov	DWORD PTR [ebx+16], ecx

; 38   : 	return (uint64_t)(((timebuffer.time * 1000) + timebuffer.millitm));

	adc	esi, edx

; 25   : 	Stop =  Build();

	mov	DWORD PTR [ebx+20], esi
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 124  : 			status = Mess.LoadString(IDS_STRING185);

	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
	lea	ecx, DWORD PTR [esi+36]
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	eax, DWORD PTR [esi+36]

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [eax-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN329@Go

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [eax-12]
	lea	ecx, DWORD PTR [esi+36]
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	esi, DWORD PTR [esi+36]
	jmp	SHORT $LN281@Go
$LN329@Go:

; 91   : 		}
; 92   : 	}
; 93   : 	void Unlock() throw()
; 94   : 	{
; 95   : 		ATLASSERT( IsLocked() );
; 96   : 
; 97   : 		if(IsLocked())
; 98   : 		{
; 99   : 			nRefs++;  // Locked buffers can't be shared, so no interlocked operation necessary
; 100  : 			if( nRefs == 0 )
; 101  : 			{
; 102  : 				nRefs = 1;
; 103  : 			}
; 104  : 		}
; 105  : 	}
; 106  : };
; 107  : 
; 108  : class CNilStringData :
; 109  : 	public CStringData
; 110  : {
; 111  : public:
; 112  : 	CNilStringData() throw()
; 113  : 	{
; 114  : 		pStringMgr = NULL;
; 115  : 		nRefs = 2;  // Never gets freed by IAtlStringMgr
; 116  : 		nDataLength = 0;
; 117  : 		nAllocLength = 0;
; 118  : 		achNil[0] = 0;
; 119  : 		achNil[1] = 0;
; 120  : 	}
; 121  : 
; 122  : 	void SetManager(_In_ IAtlStringMgr* pMgr) throw()
; 123  : 	{
; 124  : 		ATLASSERT( pStringMgr == NULL );
; 125  : 		pStringMgr = pMgr;
; 126  : 	}
; 127  : 
; 128  : public:
; 129  : 	wchar_t achNil[2];
; 130  : };
; 131  : 
; 132  : template< typename BaseType, const int t_nSize >
; 133  : class CStaticString
; 134  : {
; 135  : public:
; 136  : 	CStaticString(_In_z_ const BaseType* psz) :
; 137  : 		m_psz( psz )
; 138  : 	{
; 139  : 	}
; 140  : 
; 141  : 	operator const BaseType*() const
; 142  : 	{
; 143  : 		return m_psz;
; 144  : 	}
; 145  : 
; 146  : 	static int __cdecl GetLength()
; 147  : 	{
; 148  : 		return (t_nSize/sizeof( BaseType ))-1;
; 149  : 	}
; 150  : 
; 151  : private:
; 152  : 	const BaseType* m_psz;
; 153  : 
; 154  : private:
; 155  : 	CStaticString(_In_ const CStaticString& str) throw();
; 156  : 	CStaticString& operator=(_In_ const CStaticString& str) throw();
; 157  : };
; 158  : 
; 159  : #define _ST( psz ) ATL::CStaticString< TCHAR, sizeof( _T( psz ) ) >( _T( psz ) )
; 160  : #define _SA( psz ) ATL::CStaticString< char, sizeof( psz ) >( psz )
; 161  : #define _SW( psz ) ATL::CStaticString< wchar_t, sizeof( L##psz ) >( L##psz )
; 162  : #define _SO( psz ) _SW( psz )
; 163  : 
; 164  : template< typename BaseType = char >
; 165  : class ChTraitsBase
; 166  : {
; 167  : public:
; 168  : 	typedef char XCHAR;
; 169  : 	typedef LPSTR PXSTR;
; 170  : 	typedef LPCSTR PCXSTR;
; 171  : 	typedef wchar_t YCHAR;
; 172  : 	typedef LPWSTR PYSTR;
; 173  : 	typedef LPCWSTR PCYSTR;
; 174  : };
; 175  : 
; 176  : template<>
; 177  : class ChTraitsBase< wchar_t >
; 178  : {
; 179  : public:
; 180  : 	typedef wchar_t XCHAR;
; 181  : 	typedef LPWSTR PXSTR;
; 182  : 	typedef LPCWSTR PCXSTR;
; 183  : 	typedef char YCHAR;
; 184  : 	typedef LPSTR PYSTR;
; 185  : 	typedef LPCSTR PCYSTR;
; 186  : };
; 187  : 
; 188  : template< typename TCharType, bool t_bMFCDLL = false >
; 189  : class CStrBufT;
; 190  : 
; 191  : template< typename BaseType , bool t_bMFCDLL = false>
; 192  : class CSimpleStringT
; 193  : {
; 194  : public:
; 195  : 	typedef typename ChTraitsBase< BaseType >::XCHAR XCHAR;
; 196  : 	typedef typename ChTraitsBase< BaseType >::PXSTR PXSTR;
; 197  : 	typedef typename ChTraitsBase< BaseType >::PCXSTR PCXSTR;
; 198  : 	typedef typename ChTraitsBase< BaseType >::YCHAR YCHAR;
; 199  : 	typedef typename ChTraitsBase< BaseType >::PYSTR PYSTR;
; 200  : 	typedef typename ChTraitsBase< BaseType >::PCYSTR PCYSTR;
; 201  : 
; 202  : public:
; 203  : 	explicit CSimpleStringT(_Inout_ IAtlStringMgr* pStringMgr)
; 204  : 	{
; 205  : 		ATLENSURE( pStringMgr != NULL );
; 206  : 		CStringData* pData = pStringMgr->GetNilString();
; 207  : 		Attach( pData );
; 208  : 	}
; 209  : 
; 210  : 	CSimpleStringT(_In_ const CSimpleStringT& strSrc)
; 211  : 	{
; 212  : 		CStringData* pSrcData = strSrc.GetData();
; 213  : 		CStringData* pNewData = CloneData( pSrcData );
; 214  : 		Attach( pNewData );
; 215  : 	}
; 216  : 
; 217  : 	CSimpleStringT(_In_ const CSimpleStringT<BaseType, !t_bMFCDLL>& strSrc)
; 218  : 	{
; 219  : 		CStringData* pSrcData = strSrc.GetData();
; 220  : 		CStringData* pNewData = CloneData( pSrcData );
; 221  : 		Attach( pNewData );
; 222  : 	}
; 223  : 
; 224  : 	CSimpleStringT(
; 225  : 		_In_z_ PCXSTR pszSrc,
; 226  : 		_Inout_ IAtlStringMgr* pStringMgr)
; 227  : 	{
; 228  : 		ATLENSURE( pStringMgr != NULL );
; 229  : 
; 230  : 		int nLength = StringLength( pszSrc );
; 231  : 		CStringData* pData = pStringMgr->Allocate( nLength, sizeof( XCHAR ) );
; 232  : 		if( pData == NULL )
; 233  : 		{
; 234  : 			ThrowMemoryException();
; 235  : 		}
; 236  : 		Attach( pData );
; 237  : 		SetLength( nLength );
; 238  : 		CopyChars( m_pszData, nLength, pszSrc, nLength );
; 239  : 	}
; 240  : 	CSimpleStringT(
; 241  : 		_In_reads_(nLength) const XCHAR* pchSrc,
; 242  : 		_In_ int nLength,
; 243  : 		_Inout_ IAtlStringMgr* pStringMgr)
; 244  : 	{
; 245  : 		ATLENSURE( pStringMgr != NULL );
; 246  : 
; 247  : 		if(pchSrc == NULL && nLength != 0)
; 248  : 			AtlThrow(E_INVALIDARG);
; 249  : 
; 250  : 		CStringData* pData = pStringMgr->Allocate( nLength, sizeof( XCHAR ) );
; 251  : 		if( pData == NULL )
; 252  : 		{
; 253  : 			ThrowMemoryException();
; 254  : 		}
; 255  : 		Attach( pData );
; 256  : 		SetLength( nLength );
; 257  : 		CopyChars( m_pszData, nLength, pchSrc, nLength );
; 258  : 	}
; 259  : 	~CSimpleStringT() throw()
; 260  : 	{
; 261  : 		CStringData* pData = GetData();
; 262  : 		pData->Release();
; 263  : 	}
; 264  : 
; 265  : 	operator CSimpleStringT<BaseType, !t_bMFCDLL>&()
; 266  : 	{
; 267  : 		return *(CSimpleStringT<BaseType, !t_bMFCDLL>*)this;
; 268  : 	}
; 269  : 
; 270  : 	CSimpleStringT& operator=(_In_ const CSimpleStringT& strSrc)
; 271  : 	{
; 272  : 		CStringData* pSrcData = strSrc.GetData();
; 273  : 		CStringData* pOldData = GetData();
; 274  : 		if( pSrcData != pOldData)
; 275  : 		{
; 276  : 			if( pOldData->IsLocked() || pSrcData->pStringMgr != pOldData->pStringMgr )
; 277  : 			{
; 278  : 				SetString( strSrc.GetString(), strSrc.GetLength() );
; 279  : 			}
; 280  : 			else
; 281  : 			{
; 282  : 				CStringData* pNewData = CloneData( pSrcData );
; 283  : 				pOldData->Release();
; 284  : 				Attach( pNewData );
; 285  : 			}
; 286  : 		}
; 287  : 
; 288  : 		return( *this );
; 289  : 	}
; 290  : 
; 291  : 	CSimpleStringT& operator=(_In_ const CSimpleStringT<BaseType, !t_bMFCDLL>& strSrc)
; 292  : 	{
; 293  : 		CStringData* pSrcData = strSrc.GetData();
; 294  : 		CStringData* pOldData = GetData();
; 295  : 		if( pSrcData != pOldData)
; 296  : 		{
; 297  : 			if( pOldData->IsLocked() || pSrcData->pStringMgr != pOldData->pStringMgr )
; 298  : 			{
; 299  : 				SetString( strSrc.GetString(), strSrc.GetLength() );
; 300  : 			}
; 301  : 			else
; 302  : 			{
; 303  : 				CStringData* pNewData = CloneData( pSrcData );
; 304  : 				pOldData->Release();
; 305  : 				Attach( pNewData );
; 306  : 			}
; 307  : 		}
; 308  : 
; 309  : 		return( *this );
; 310  : 	}
; 311  : 
; 312  : 	CSimpleStringT& operator=(_In_opt_z_ PCXSTR pszSrc)
; 313  : 	{
; 314  : 		SetString( pszSrc );
; 315  : 
; 316  : 		return( *this );
; 317  : 	}
; 318  : 
; 319  : 	CSimpleStringT& operator+=(_In_ const CSimpleStringT& strSrc)
; 320  : 	{
; 321  : 		Append( strSrc );
; 322  : 
; 323  : 		return( *this );
; 324  : 	}
; 325  : 	template <bool bMFCDLL>
; 326  : 	CSimpleStringT& operator+=(_In_ const CSimpleStringT<BaseType, bMFCDLL>& strSrc)
; 327  : 	{
; 328  : 		Append( strSrc );
; 329  : 
; 330  : 		return( *this );
; 331  : 	}
; 332  : 
; 333  : 	CSimpleStringT& operator+=(_In_z_ PCXSTR pszSrc)
; 334  : 	{
; 335  : 		Append( pszSrc );
; 336  : 
; 337  : 		return( *this );
; 338  : 	}
; 339  : 	template< int t_nSize >
; 340  : 	CSimpleStringT& operator+=(_In_ const CStaticString< XCHAR, t_nSize >& strSrc)
; 341  : 	{
; 342  : 		Append( static_cast<const XCHAR *>(strSrc), strSrc.GetLength() );
; 343  : 
; 344  : 		return( *this );
; 345  : 	}
; 346  : 	CSimpleStringT& operator+=(_In_ char ch)
; 347  : 	{
; 348  : 		AppendChar( XCHAR( ch ) );
; 349  : 
; 350  : 		return( *this );
; 351  : 	}
; 352  : 	CSimpleStringT& operator+=(_In_ unsigned char ch)
; 353  : 	{
; 354  : 		AppendChar( XCHAR( ch ) );
; 355  : 
; 356  : 		return( *this );
; 357  : 	}
; 358  : 	CSimpleStringT& operator+=(_In_ wchar_t ch)
; 359  : 	{
; 360  : 		AppendChar( XCHAR( ch ) );
; 361  : 
; 362  : 		return( *this );
; 363  : 	}
; 364  : 
; 365  : 	XCHAR operator[](_In_ int iChar) const
; 366  : 	{
; 367  : 		ATLASSERT( (iChar >= 0) && (iChar <= GetLength()) );  // Indexing the '\0' is OK
; 368  : 
; 369  : 		if( (iChar < 0) || (iChar > GetLength()) )
; 370  : 			AtlThrow(E_INVALIDARG);
; 371  : 
; 372  : 		return( m_pszData[iChar] );
; 373  : 	}
; 374  : 
; 375  : 	operator PCXSTR() const throw()
; 376  : 	{
; 377  : 		return( m_pszData );
; 378  : 	}
; 379  : 
; 380  : 	void Append(_In_z_ PCXSTR pszSrc)
; 381  : 	{
; 382  : 		Append( pszSrc, StringLength( pszSrc ) );
; 383  : 	}
; 384  : 	void Append(
; 385  : 		_In_reads_(nLength) PCXSTR pszSrc,
; 386  : 		_In_ int nLength)
; 387  : 	{
; 388  : 		// See comment in SetString() about why we do this
; 389  : 		UINT_PTR nOffset = pszSrc-GetString();
; 390  : 
; 391  : 		UINT nOldLength = GetLength();
; 392  : 		if (nOldLength < 0)
; 393  : 		{
; 394  : 			// protects from underflow
; 395  : 			nOldLength = 0;
; 396  : 		}
; 397  : 
; 398  : 		//Make sure the nLength is greater than zero
; 399  : 		ATLENSURE_THROW(nLength >=0, E_INVALIDARG);
; 400  : 
; 401  : 		//Make sure we don't read pass end of the terminating NULL
; 402  : 		nLength = StringLengthN(pszSrc, nLength);
; 403  : 
; 404  : 		//Make sure after the string doesn't exceed INT_MAX after appending
; 405  : 		ATLENSURE_THROW(INT_MAX - nLength >= static_cast<int>(nOldLength), E_INVALIDARG);
; 406  : 
; 407  : 		int nNewLength = nOldLength+nLength;
; 408  : 		PXSTR pszBuffer = GetBuffer( nNewLength );
; 409  : 		if( nOffset <= nOldLength )
; 410  : 		{
; 411  : 			pszSrc = pszBuffer+nOffset;
; 412  : 			// No need to call CopyCharsOverlapped, since the destination is
; 413  : 			// beyond the end of the original buffer
; 414  : 		}
; 415  : 		CopyChars( pszBuffer+nOldLength, nLength, pszSrc, nLength );
; 416  : 		ReleaseBufferSetLength( nNewLength );
; 417  : 	}
; 418  : 	void AppendChar(_In_ XCHAR ch)
; 419  : 	{
; 420  : 		UINT nOldLength = GetLength();
; 421  : 		int nNewLength = nOldLength+1;
; 422  : 		PXSTR pszBuffer = GetBuffer( nNewLength );
; 423  : 		pszBuffer[nOldLength] = ch;
; 424  : 		ReleaseBufferSetLength( nNewLength );
; 425  : 	}
; 426  : 	void Append(_In_ const CSimpleStringT& strSrc)
; 427  : 	{
; 428  : 		Append( strSrc.GetString(), strSrc.GetLength() );
; 429  : 	}
; 430  : 	template <bool bMFCDLL>
; 431  : 	void Append(_In_ const CSimpleStringT<BaseType, bMFCDLL>& strSrc)
; 432  : 	{
; 433  : 		Append( strSrc.GetString(), strSrc.GetLength() );
; 434  : 	}
; 435  : 	void Empty() throw()
; 436  : 	{
; 437  : 		CStringData* pOldData = GetData();
; 438  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
; 439  : 		if( pOldData->nDataLength == 0 )
; 440  : 		{
; 441  : 			return;
; 442  : 		}
; 443  : 
; 444  : 		if( pOldData->IsLocked() )
; 445  : 		{
; 446  : 			// Don't reallocate a locked buffer that's shrinking
; 447  : 			SetLength( 0 );
; 448  : 		}
; 449  : 		else
; 450  : 		{
; 451  : 			pOldData->Release();
; 452  : 			CStringData* pNewData = pStringMgr->GetNilString();
; 453  : 			Attach( pNewData );
; 454  : 		}
; 455  : 	}
; 456  : 	void FreeExtra()
; 457  : 	{
; 458  : 		CStringData* pOldData = GetData();
; 459  : 		int nLength = pOldData->nDataLength;
; 460  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
; 461  : 		if( pOldData->nAllocLength == nLength )
; 462  : 		{
; 463  : 			return;
; 464  : 		}
; 465  : 
; 466  : 		if( !pOldData->IsLocked() )  // Don't reallocate a locked buffer that's shrinking
; 467  : 		{
; 468  : 			CStringData* pNewData = pStringMgr->Allocate( nLength, sizeof( XCHAR ) );
; 469  : 			if( pNewData == NULL )
; 470  : 			{
; 471  : 				SetLength( nLength );
; 472  : 				return;
; 473  : 			}
; 474  : 
; 475  : 			CopyChars( PXSTR( pNewData->data() ), nLength,
; 476  : 				PCXSTR( pOldData->data() ), nLength );
; 477  : 
; 478  : 			pOldData->Release();
; 479  : 			Attach( pNewData );
; 480  : 			SetLength( nLength );
; 481  : 		}
; 482  : 	}
; 483  : 
; 484  : 	int GetAllocLength() const throw()
; 485  : 	{
; 486  : 		return( GetData()->nAllocLength );
; 487  : 	}
; 488  : 	XCHAR GetAt(_In_ int iChar) const
; 489  : 	{
; 490  : 		ATLASSERT( (iChar >= 0) && (iChar <= GetLength()) );  // Indexing the '\0' is OK
; 491  : 		if( (iChar < 0) || (iChar > GetLength()) )
; 492  : 			AtlThrow(E_INVALIDARG);
; 493  : 
; 494  : 		return( m_pszData[iChar] );
; 495  : 	}
; 496  : 	PXSTR GetBuffer()
; 497  : 	{
; 498  : 		CStringData* pData = GetData();
; 499  : 		if( pData->IsShared() )

	mov	esi, eax
$LN281@Go:
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 125  : 			pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());

	call	DWORD PTR __imp__GetLastError@0
	push	eax
	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	push	esi
	mov	ecx, DWORD PTR [eax+28]
	call	?MyHandleError@C_Error_Message@@QAEXPA_WH@Z ; C_Error_Message::MyHandleError

; 126  : 			delete pt_Ajust;

	test	edi, edi
	je	SHORT $LN288@Go
	push	1
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN288@Go:

; 127  : 			delete pt_time;

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	push	1
	call	DWORD PTR [eax]

; 128  : 			return false;

	mov	BYTE PTR $T33[ebp], 0
$LN31@Go:
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	or	ebx, -1

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR _Local$39[ebp]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, ebx

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	add	edx, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN297@Go

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN297@Go:
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 128  : 			return false;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	eax, DWORD PTR _tt$38[ebp]
	add	eax, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [eax+12], ebx
	dec	ebx
	test	ebx, ebx
	jg	SHORT $LN306@Go

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [eax]
	push	eax
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+4]
$LN306@Go:
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 128  : 			return false;

	mov	al, BYTE PTR $T33[ebp]
	jmp	SHORT $LN1@Go
$LN324@Go:

; 129  : 		}
; 130  : 	}
; 131  : 	delete pt_Ajust;

	test	edi, edi
	je	SHORT $LN327@Go
	push	1
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN327@Go:

; 132  : 	return false;

	xor	al, al
$LN1@Go:

; 133  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN333@Go:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 893  : 				ThrowMemoryException();

	call	?ThrowMemoryException@?$CSimpleStringT@_W$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<wchar_t,0>::ThrowMemoryException
$LN334@Go:
	call	?ThrowMemoryException@?$CSimpleStringT@_W$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<wchar_t,0>::ThrowMemoryException
$LN335@Go:
	call	?ThrowMemoryException@?$CSimpleStringT@_W$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<wchar_t,0>::ThrowMemoryException
$LN336@Go:
	call	?ThrowMemoryException@?$CSimpleStringT@_W$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<wchar_t,0>::ThrowMemoryException
$LN331@Go:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Go@C_Decode_Interactif@@QAE_NXZ$0:
	push	1
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Go@C_Decode_Interactif@@QAE_NXZ$2:
	lea	ecx, DWORD PTR _tt$38[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$?Go@C_Decode_Interactif@@QAE_NXZ$3:
	mov	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$?Go@C_Decode_Interactif@@QAE_NXZ$6:
	lea	ecx, DWORD PTR _Local$39[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$?Go@C_Decode_Interactif@@QAE_NXZ$8:
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$?Go@C_Decode_Interactif@@QAE_NXZ$10:
	lea	ecx, DWORD PTR $T15[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__ehhandler$?Go@C_Decode_Interactif@@QAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Go@C_Decode_Interactif@@QAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Go@C_Decode_Interactif@@QAE_NXZ ENDP			; C_Decode_Interactif::Go
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
;	COMDAT ??0C_Decode_Interactif@@QAE@XZ
_TEXT	SEGMENT
$T7 = -20						; size = 4
$T3 = -20						; size = 4
$T1 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0C_Decode_Interactif@@QAE@XZ PROC			; C_Decode_Interactif::C_Decode_Interactif, COMDAT
; _this$ = ecx

; 11   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0C_Decode_Interactif@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN117@C_Decode_I

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	call	eax

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [esi+8], eax
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 11   : {

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN117@C_Decode_I

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	call	eax

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [esi+12], eax
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 11   : {

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN117@C_Decode_I

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	call	eax

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [esi+16], eax
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 11   : {

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN117@C_Decode_I

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	call	eax

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [esi+36], eax
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 12   : 	pt_decode = new C_AES_Decode;

	push	24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	test	eax, eax
	je	SHORT $LN3@C_Decode_I
	xorps	xmm0, xmm0
	mov	ecx, eax
	movups	XMMWORD PTR [eax], xmm0
	movq	QWORD PTR [eax+16], xmm0
	call	??0C_AES_Decode@@QAE@XZ			; C_AES_Decode::C_AES_Decode
	jmp	SHORT $LN4@C_Decode_I
$LN3@C_Decode_I:
	xor	eax, eax
$LN4@C_Decode_I:
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 13   : 	pt_pass = new C_Password;

	push	1
	mov	DWORD PTR [esi+20], eax
	call	??2@YAPAXI@Z				; operator new
	mov	DWORD PTR $T3[ebp], eax

; 14   : 	pt_Erreur = new C_Error_Message;

	push	4
	mov	DWORD PTR [esi+24], eax
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@C_Decode_I
	mov	DWORD PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 1006 : 		CThisSimpleString( StringTraits::GetDefaultManager() )

	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	SHORT $LN117@C_Decode_I

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	call	eax

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [edi], eax
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 14   : 	pt_Erreur = new C_Error_Message;

	jmp	SHORT $LN8@C_Decode_I
$LN7@C_Decode_I:
	xor	edi, edi
$LN8@C_Decode_I:

; 15   : 	pt_fichier = new Manipulation_Fichier;

	push	1
	mov	DWORD PTR [esi+28], edi
	call	??2@YAPAXI@Z				; operator new
	mov	DWORD PTR $T7[ebp], eax
	add	esp, 4
	mov	DWORD PTR [esi+32], eax

; 16   : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN117@C_Decode_I:
	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN119@C_Decode_I:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0C_Decode_Interactif@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$??0C_Decode_Interactif@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$??0C_Decode_Interactif@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$??0C_Decode_Interactif@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$??0C_Decode_Interactif@@QAE@XZ$4:
	push	24					; 00000018H
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0C_Decode_Interactif@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0C_Decode_Interactif@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0C_Decode_Interactif@@QAE@XZ ENDP			; C_Decode_Interactif::C_Decode_Interactif
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
;	COMDAT ??0C_Error_Message@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??0C_Error_Message@@QAE@XZ PROC				; C_Error_Message::C_Error_Message, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0C_Error_Message@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 1006 : 		CThisSimpleString( StringTraits::GetDefaultManager() )

	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	SHORT $LN25@C_Error_Me

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [esi], eax
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@C_Error_Me:

; 205  : 		ATLENSURE( pStringMgr != NULL );

	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN23@C_Error_Me:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0C_Error_Message@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0C_Error_Message@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0C_Error_Message@@QAE@XZ ENDP				; C_Error_Message::C_Error_Message
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@C_Error_Message@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@C_Error_Message@@QAEXI@Z PROC		; C_Error_Message::__autoclassinit2, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	ret	4
?__autoclassinit2@C_Error_Message@@QAEXI@Z ENDP		; C_Error_Message::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
;	COMDAT ??_GC_Error_Message@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$dead$ = 8					; size = 4
??_GC_Error_Message@@QAEPAXI@Z PROC			; C_Error_Message::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_GC_Error_Message@@QAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [esi]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	or	eax, -1

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN14@scalar

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN14@scalar:
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_GC_Error_Message@@QAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_GC_Error_Message@@QAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_GC_Error_Message@@QAEPAXI@Z ENDP			; C_Error_Message::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
;	COMDAT ??1C_Error_Message@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1C_Error_Message@@QAE@XZ PROC				; C_Error_Message::~C_Error_Message, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1C_Error_Message@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [ecx]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	or	eax, -1

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN10@C_Error_Me

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN10@C_Error_Me:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1C_Error_Message@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1C_Error_Message@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1C_Error_Message@@QAE@XZ ENDP				; C_Error_Message::~C_Error_Message
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
;	COMDAT ?Current_Dir@C_Decode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?Current_Dir@C_Decode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ PROC ; C_Decode_Interactif::Current_Dir, COMDAT
; _this$dead$ = ecx

; 28   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Current_Dir@C_Decode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T1[ebp], 0
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN56@Current_Di

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [esi], eax
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 33   : 	return (Chaine);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 808  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false

	mov	ecx, 1
	sub	ecx, DWORD PTR [eax-4]

; 809  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

	mov	eax, DWORD PTR [eax-8]
	sub	eax, 260				; 00000104H
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 33   : 	return (Chaine);

	mov	DWORD PTR $T1[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 810  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

	or	ecx, eax
	jge	SHORT $LN30@Current_Di

; 811  : 		{
; 812  : 			PrepareWrite2( nLength );

	push	260					; 00000104H
	mov	ecx, esi
	call	?PrepareWrite2@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2
$LN30@Current_Di:
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 31   : 	::GetCurrentDirectory(MAX_PATH, Chaine.GetBuffer(MAX_PATH));

	push	DWORD PTR [esi]
	push	260					; 00000104H
	call	DWORD PTR __imp__GetCurrentDirectoryW@8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 560  : 			int nAlloc = GetData()->nAllocLength;

	mov	eax, DWORD PTR [esi]

; 750  : 		if( psz == NULL )

	test	eax, eax
	je	SHORT $LN52@Current_Di
$LN41@Current_Di:

; 751  : 		{
; 752  : 			return( 0 );
; 753  : 		}
; 754  : 		return( int( wcsnlen( psz, sizeInXChar ) ) );

	push	DWORD PTR [eax-8]
	push	eax
	call	_wcsnlen
	add	esp, 8

; 871  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	test	eax, eax
	js	SHORT $LN45@Current_Di
$LN52@Current_Di:
	mov	ecx, DWORD PTR [esi]
	cmp	eax, DWORD PTR [ecx-8]
	jg	SHORT $LN45@Current_Di

; 873  : 
; 874  : 		GetData()->nDataLength = nLength;

	mov	DWORD PTR [ecx-12], eax

; 875  : 		m_pszData[nLength] = 0;

	xor	edx, edx
	mov	ecx, DWORD PTR [esi]
	mov	WORD PTR [ecx+eax*2], dx
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 33   : 	return (Chaine);

	mov	eax, esi

; 35   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN45@Current_Di:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 872  : 			AtlThrow(E_INVALIDARG);

	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN56@Current_Di:

; 205  : 		ATLENSURE( pStringMgr != NULL );

	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN54@Current_Di:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Current_Dir@C_Decode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ$0:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN4@Current_Di
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
$LN4@Current_Di:
	ret	0
__ehhandler$?Current_Dir@C_Decode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Current_Dir@C_Decode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Current_Dir@C_Decode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ ENDP ; C_Decode_Interactif::Current_Dir
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@CFileDialog@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@CFileDialog@@QAEXI@Z PROC		; CFileDialog::__autoclassinit2, COMDAT
; _this$ = ecx
	push	1256					; 000004e8H
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	ret	4
?__autoclassinit2@CFileDialog@@QAEXI@Z ENDP		; CFileDialog::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxwin1.inl
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp
;	COMDAT ?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z
_TEXT	SEGMENT
$T5 = -1292						; size = 4
_this$GSCopy$1$ = -1288					; size = 4
_this$1$ = -1288					; size = 4
$T13 = -1281						; size = 1
_FileOpenDialog$ = -1280				; size = 1256
_local_File$ = -24					; size = 4
_OpenFilter$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_File$ = 8						; size = 4
?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z PROC	; C_Decode_Interactif::Open_File, COMDAT
; _this$ = ecx

; 68   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1280				; 00000500H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], ebx
	mov	esi, DWORD PTR _File$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN140@Open_File

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR _OpenFilter$[ebp], eax
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 69   : 	CString OpenFilter;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN141@Open_File

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR _local_File$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 1044 : 		CThisSimpleString( StringTraits::GetDefaultManager() )

	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2668 : 		if( (pv != NULL) && IS_INTRESOURCE( pv ) )

	test	esi, esi
	je	SHORT $LN134@Open_File
	test	esi, -65536				; ffff0000H
	jne	SHORT $LN63@Open_File

; 2669 : 		{
; 2670 : 			UINT nID = LOWORD( reinterpret_cast< DWORD_PTR >( pv ) );

	movzx	eax, si

; 2671 : 			(nID);
; 2672 : #ifdef _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 2673 : 			if( !LoadString( nID ) )

	lea	ecx, DWORD PTR _local_File$[ebp]
	push	eax
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW

; 1046 : 		if( !CheckImplicitLoad( pszSrc ) )

	jmp	SHORT $LN33@Open_File
$LN63@Open_File:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 734  : 		return( int( wcslen( psz ) ) );

	mov	ecx, esi
	lea	edx, DWORD PTR [ecx+2]
$LL135@Open_File:
	mov	ax, WORD PTR [ecx]
	add	ecx, 2
	test	ax, ax
	jne	SHORT $LL135@Open_File
	sub	ecx, edx
	sar	ecx, 1
	jmp	SHORT $LN62@Open_File
$LN134@Open_File:

; 731  : 		{
; 732  : 			return( 0 );

	xor	ecx, ecx
$LN62@Open_File:

; 602  : 		SetString( pszSrc, StringLength( pszSrc ) );

	push	ecx
	push	esi
	lea	ecx, DWORD PTR _local_File$[ebp]
	call	?SetString@?$CSimpleStringT@_W$0A@@ATL@@QAEXPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::SetString
$LN33@Open_File:
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 72   : 	BOOL status = Mess.LoadString(IDS_STRING189);

	add	ebx, 36					; 00000024H
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	189					; 000000bdH
	mov	ecx, ebx
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW

; 73   : 	OpenFilter = Mess;

	push	ebx
	lea	ecx, DWORD PTR _OpenFilter$[ebp]
	call	??4?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::operator=

; 74   : 	status = Mess.LoadString(IDS_STRING187);

	push	187					; 000000bbH
	mov	ecx, ebx
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW

; 75   : 	OpenFilter += Mess;

	push	ebx
	lea	ecx, DWORD PTR _OpenFilter$[ebp]
	call	??Y?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEAAV01@ABV?$CSimpleStringT@_W$0A@@1@@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::operator+=
	push	1256					; 000004e8H
	lea	eax, DWORD PTR _FileOpenDialog$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxwin1.inl

; 33   : 	{ CWinThread* pThread = AfxGetThread();

	call	?AfxGetThread@@YGPAVCWinThread@@XZ	; AfxGetThread

; 34   : 		return pThread != NULL ? pThread->GetMainWnd() : NULL; }

	test	eax, eax
	je	SHORT $LN69@Open_File
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	call	DWORD PTR [edx+116]
	jmp	SHORT $LN70@Open_File
$LN69@Open_File:
	xor	eax, eax
$LN70@Open_File:
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 77   : 	CFileDialog FileOpenDialog(

	mov	esi, DWORD PTR _OpenFilter$[ebp]
	lea	ecx, DWORD PTR _FileOpenDialog$[ebp]
	mov	edi, DWORD PTR _local_File$[ebp]
	push	1
	push	0
	push	eax
	push	esi
	push	6148					; 00001804H
	push	edi
	push	0
	push	1
	call	??0CFileDialog@@QAE@HPB_W0K0PAVCWnd@@KH@Z ; CFileDialog::CFileDialog

; 85   : 	FileOpenDialog.m_ofn.lpstrInitialDir = Current_Dir();

	lea	eax, DWORD PTR $T5[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	eax
	call	?Current_Dir@C_Decode_Interactif@@AAE?AV?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@XZ ; C_Decode_Interactif::Current_Dir
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _FileOpenDialog$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 377  : 		return( m_pszData );

	mov	ebx, DWORD PTR [eax]
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 85   : 	FileOpenDialog.m_ofn.lpstrInitialDir = Current_Dir();

	call	?GetOFN@CFileDialog@@QAEAAUtagOFNW@@XZ	; CFileDialog::GetOFN
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	DWORD PTR [eax+44], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	or	eax, -1

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR $T5[ebp]
	add	edx, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN84@Open_File

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN84@Open_File:
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 86   : 	status = Mess.LoadString(IDS_STRING188);

	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
	push	188					; 000000bcH
	lea	ecx, DWORD PTR [ebx+36]
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 377  : 		return( m_pszData );

	mov	ebx, DWORD PTR [ebx+36]
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 87   : 	FileOpenDialog.m_ofn.lpstrTitle = Mess;

	lea	ecx, DWORD PTR _FileOpenDialog$[ebp]
	call	?GetOFN@CFileDialog@@QAEAAUtagOFNW@@XZ	; CFileDialog::GetOFN

; 88   : 
; 89   : 	if (FileOpenDialog.DoModal() == IDOK)

	lea	ecx, DWORD PTR _FileOpenDialog$[ebp]
	mov	DWORD PTR [eax+48], ebx
	call	?DoModal@CFileDialog@@UAEHXZ		; CFileDialog::DoModal
	cmp	eax, 1
	jne	SHORT $LN2@Open_File

; 90   : 	{
; 91   : 		pszSource = FileOpenDialog.m_ofn.lpstrFile;

	lea	ecx, DWORD PTR _FileOpenDialog$[ebp]
	call	?GetOFN@CFileDialog@@QAEAAUtagOFNW@@XZ	; CFileDialog::GetOFN
	mov	edx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _this$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 730  : 		if( psz == NULL )

	test	edx, edx
	jne	SHORT $LN95@Open_File

; 731  : 		{
; 732  : 			return( 0 );

	xor	ecx, ecx

; 602  : 		SetString( pszSrc, StringLength( pszSrc ) );

	push	ecx
	push	edx
	mov	ecx, eax
	call	?SetString@?$CSimpleStringT@_W$0A@@ATL@@QAEXPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::SetString
	mov	BYTE PTR $T13[ebp], 1
	jmp	SHORT $LN8@Open_File
$LN95@Open_File:

; 734  : 		return( int( wcslen( psz ) ) );

	mov	ecx, edx
	lea	ebx, DWORD PTR [ecx+2]
$LL136@Open_File:
	mov	ax, WORD PTR [ecx]
	add	ecx, 2
	test	ax, ax
	jne	SHORT $LL136@Open_File
	mov	eax, DWORD PTR _this$1$[ebp]
	sub	ecx, ebx
	sar	ecx, 1

; 602  : 		SetString( pszSrc, StringLength( pszSrc ) );

	push	ecx
	push	edx
	mov	ecx, eax
	call	?SetString@?$CSimpleStringT@_W$0A@@ATL@@QAEXPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::SetString
	mov	BYTE PTR $T13[ebp], 1
	jmp	SHORT $LN8@Open_File
$LN2@Open_File:
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 94   : 	return false;

	mov	BYTE PTR $T13[ebp], 0
$LN8@Open_File:
	lea	ecx, DWORD PTR _FileOpenDialog$[ebp]
	call	??1CFileDialog@@UAE@XZ			; CFileDialog::~CFileDialog
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	or	ebx, -1
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 94   : 	return false;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	add	edi, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, ebx
	lock	 xadd	 DWORD PTR [edi+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN122@Open_File

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edi]
	push	edi
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN122@Open_File:
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 94   : 	return false;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	add	esi, -16				; fffffff0H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [esi+12], ebx
	dec	ebx
	test	ebx, ebx
	jg	SHORT $LN131@Open_File

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [esi]
	push	esi
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+4]
$LN131@Open_File:
; File I:\Projets\AES\AES\AES\C_Decode_Interactif.cpp

; 94   : 	return false;

	mov	al, BYTE PTR $T13[ebp]

; 96   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN140@Open_File:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN141@Open_File:
	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN138@Open_File:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z$0:
	lea	ecx, DWORD PTR _OpenFilter$[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z$4:
	lea	ecx, DWORD PTR _local_File$[ebp]
	jmp	??1?$CSimpleStringT@_W$0A@@ATL@@QAE@XZ	; ATL::CSimpleStringT<wchar_t,0>::~CSimpleStringT<wchar_t,0>
__unwindfunclet$?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z$1:
	lea	ecx, DWORD PTR _local_File$[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__unwindfunclet$?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z$2:
	lea	ecx, DWORD PTR _FileOpenDialog$[ebp]
	jmp	??1CFileDialog@@UAE@XZ			; CFileDialog::~CFileDialog
__unwindfunclet$?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z$3:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__ehhandler$?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1296]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Open_File@C_Decode_Interactif@@AAE_NPA_W@Z ENDP	; C_Decode_Interactif::Open_File
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxwin1.inl
;	COMDAT ?AfxGetMainWnd@@YGPAVCWnd@@XZ
_TEXT	SEGMENT
?AfxGetMainWnd@@YGPAVCWnd@@XZ PROC			; AfxGetMainWnd, COMDAT

; 33   : 	{ CWinThread* pThread = AfxGetThread();

	call	?AfxGetThread@@YGPAVCWinThread@@XZ	; AfxGetThread

; 34   : 		return pThread != NULL ? pThread->GetMainWnd() : NULL; }

	test	eax, eax
	je	SHORT $LN3@AfxGetMain
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	jmp	DWORD PTR [edx+116]
$LN3@AfxGetMain:
	xor	eax, eax
	ret	0
?AfxGetMainWnd@@YGPAVCWnd@@XZ ENDP			; AfxGetMainWnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
;	COMDAT ?Append@?$CSimpleStringT@_W$0A@@ATL@@QAEXPB_WH@Z
_TEXT	SEGMENT
tv341 = -8						; size = 4
_nOffset$1$ = -4					; size = 4
_pszSrc$ = 8						; size = 4
_nLength$ = 12						; size = 4
?Append@?$CSimpleStringT@_W$0A@@ATL@@QAEXPB_WH@Z PROC	; ATL::CSimpleStringT<wchar_t,0>::Append, COMDAT
; _this$ = ecx

; 387  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 388  : 		// See comment in SetString() about why we do this
; 389  : 		UINT_PTR nOffset = pszSrc-GetString();

	mov	edx, DWORD PTR _pszSrc$[ebp]
	push	ebx
	mov	ebx, ecx
	mov	ecx, edx
	push	esi
	mov	eax, DWORD PTR [ebx]
	sub	ecx, eax
	sar	ecx, 1
	mov	DWORD PTR _nOffset$1$[ebp], ecx

; 519  : 		return( GetData()->nDataLength );

	mov	esi, DWORD PTR [eax-12]

; 390  : 
; 391  : 		UINT nOldLength = GetLength();
; 392  : 		if (nOldLength < 0)
; 393  : 		{
; 394  : 			// protects from underflow
; 395  : 			nOldLength = 0;
; 396  : 		}
; 397  : 
; 398  : 		//Make sure the nLength is greater than zero
; 399  : 		ATLENSURE_THROW(nLength >=0, E_INVALIDARG);

	mov	eax, DWORD PTR _nLength$[ebp]

; 519  : 		return( GetData()->nDataLength );

	mov	DWORD PTR tv341[ebp], esi

; 390  : 
; 391  : 		UINT nOldLength = GetLength();
; 392  : 		if (nOldLength < 0)
; 393  : 		{
; 394  : 			// protects from underflow
; 395  : 			nOldLength = 0;
; 396  : 		}
; 397  : 
; 398  : 		//Make sure the nLength is greater than zero
; 399  : 		ATLENSURE_THROW(nLength >=0, E_INVALIDARG);

	test	eax, eax
	js	SHORT $LN42@Append

; 750  : 		if( psz == NULL )

	push	edi
	test	edx, edx
	jne	SHORT $LN26@Append

; 751  : 		{
; 752  : 			return( 0 );

	xor	edi, edi
	jmp	SHORT $LN10@Append
$LN26@Append:

; 753  : 		}
; 754  : 		return( int( wcsnlen( psz, sizeInXChar ) ) );

	push	eax
	push	edx
	call	_wcsnlen
	add	esp, 8
	mov	edi, eax
$LN10@Append:

; 400  : 
; 401  : 		//Make sure we don't read pass end of the terminating NULL
; 402  : 		nLength = StringLengthN(pszSrc, nLength);
; 403  : 
; 404  : 		//Make sure after the string doesn't exceed INT_MAX after appending
; 405  : 		ATLENSURE_THROW(INT_MAX - nLength >= static_cast<int>(nOldLength), E_INVALIDARG);

	mov	ecx, 2147483647				; 7fffffffH
	sub	ecx, edi
	cmp	ecx, esi
	jl	SHORT $LN42@Append

; 406  : 
; 407  : 		int nNewLength = nOldLength+nLength;

	add	esi, edi

; 804  : 		if (nLength < 0)

	js	SHORT $LN42@Append

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [ebx]

; 808  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false

	mov	ecx, 1

; 809  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

	mov	eax, DWORD PTR [edx-8]
	sub	ecx, DWORD PTR [edx-4]
	sub	eax, esi

; 810  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

	or	ecx, eax
	jge	SHORT $LN32@Append

; 811  : 		{
; 812  : 			PrepareWrite2( nLength );

	push	esi
	mov	ecx, ebx
	call	?PrepareWrite2@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2
	mov	edx, DWORD PTR [ebx]
$LN32@Append:

; 408  : 		PXSTR pszBuffer = GetBuffer( nNewLength );
; 409  : 		if( nOffset <= nOldLength )

	mov	eax, DWORD PTR _nOffset$1$[ebp]
	mov	ecx, DWORD PTR tv341[ebp]
	cmp	eax, ecx

; 410  : 		{
; 411  : 			pszSrc = pszBuffer+nOffset;

	lea	eax, DWORD PTR [edx+eax*2]
	jbe	SHORT $LN17@Append

; 408  : 		PXSTR pszBuffer = GetBuffer( nNewLength );
; 409  : 		if( nOffset <= nOldLength )

	mov	eax, DWORD PTR _pszSrc$[ebp]
$LN17@Append:

; 412  : 			// No need to call CopyCharsOverlapped, since the destination is
; 413  : 			// beyond the end of the original buffer
; 414  : 		}
; 415  : 		CopyChars( pszBuffer+nOldLength, nLength, pszSrc, nLength );

	push	edi
	push	eax
	lea	eax, DWORD PTR [edx+ecx*2]
	push	edi
	push	eax
	call	?CopyChars@?$CSimpleStringT@_W$0A@@ATL@@SAXPA_WIPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::CopyChars

; 871  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	mov	eax, DWORD PTR [ebx]

; 412  : 			// No need to call CopyCharsOverlapped, since the destination is
; 413  : 			// beyond the end of the original buffer
; 414  : 		}
; 415  : 		CopyChars( pszBuffer+nOldLength, nLength, pszSrc, nLength );

	add	esp, 16					; 00000010H

; 871  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	pop	edi
	cmp	esi, DWORD PTR [eax-8]
	jg	SHORT $LN42@Append

; 873  : 
; 874  : 		GetData()->nDataLength = nLength;

	mov	DWORD PTR [eax-12], esi

; 875  : 		m_pszData[nLength] = 0;

	xor	ecx, ecx
	mov	eax, DWORD PTR [ebx]
	mov	WORD PTR [eax+esi*2], cx
	pop	esi
	pop	ebx

; 416  : 		ReleaseBufferSetLength( nNewLength );
; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN42@Append:

; 872  : 			AtlThrow(E_INVALIDARG);

	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN50@Append:
	int	3
?Append@?$CSimpleStringT@_W$0A@@ATL@@QAEXPB_WH@Z ENDP	; ATL::CSimpleStringT<wchar_t,0>::Append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
;	COMDAT ?Append@?$CSimpleStringT@_W$0A@@ATL@@QAEXABV12@@Z
_TEXT	SEGMENT
tv358 = -12						; size = 4
_nOffset$1$ = -8					; size = 4
_this$1$ = -4						; size = 4
$T6 = 8							; size = 4
_strSrc$ = 8						; size = 4
?Append@?$CSimpleStringT@_W$0A@@ATL@@QAEXABV12@@Z PROC	; ATL::CSimpleStringT<wchar_t,0>::Append, COMDAT
; _this$ = ecx

; 427  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 519  : 		return( GetData()->nDataLength );

	mov	eax, DWORD PTR _strSrc$[ebp]

; 427  : 	{

	mov	edx, ecx
	push	ebx
	push	esi
	push	edi

; 519  : 		return( GetData()->nDataLength );

	mov	ebx, DWORD PTR [eax]

; 389  : 		UINT_PTR nOffset = pszSrc-GetString();

	mov	ecx, ebx
	mov	eax, DWORD PTR [edx]
	sub	ecx, eax
	sar	ecx, 1

; 427  : 	{

	mov	DWORD PTR _this$1$[ebp], edx

; 428  : 		Append( strSrc.GetString(), strSrc.GetLength() );

	mov	edi, DWORD PTR [ebx-12]

; 519  : 		return( GetData()->nDataLength );

	mov	esi, DWORD PTR [eax-12]

; 389  : 		UINT_PTR nOffset = pszSrc-GetString();

	mov	DWORD PTR _nOffset$1$[ebp], ecx

; 519  : 		return( GetData()->nDataLength );

	mov	DWORD PTR tv358[ebp], esi

; 399  : 		ATLENSURE_THROW(nLength >=0, E_INVALIDARG);

	test	edi, edi
	js	$LN50@Append

; 750  : 		if( psz == NULL )

	test	ebx, ebx
	jne	SHORT $LN34@Append

; 751  : 		{
; 752  : 			return( 0 );

	xor	edi, edi
	jmp	SHORT $LN18@Append
$LN34@Append:

; 753  : 		}
; 754  : 		return( int( wcsnlen( psz, sizeInXChar ) ) );

	push	edi
	push	ebx
	call	_wcsnlen
	mov	edx, DWORD PTR _this$1$[ebp]
	add	esp, 8
	mov	edi, eax
$LN18@Append:

; 405  : 		ATLENSURE_THROW(INT_MAX - nLength >= static_cast<int>(nOldLength), E_INVALIDARG);

	mov	ecx, 2147483647				; 7fffffffH
	sub	ecx, edi
	cmp	ecx, esi
	jl	SHORT $LN50@Append

; 406  : 
; 407  : 		int nNewLength = nOldLength+nLength;

	add	esi, edi

; 804  : 		if (nLength < 0)

	js	SHORT $LN50@Append

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	eax, DWORD PTR [edx]

; 808  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false

	mov	ecx, 1

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	DWORD PTR $T6[ebp], eax

; 808  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false

	sub	ecx, DWORD PTR [eax-4]

; 809  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

	mov	eax, DWORD PTR [eax-8]
	sub	eax, esi

; 810  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

	or	ecx, eax
	jge	SHORT $LN58@Append

; 811  : 		{
; 812  : 			PrepareWrite2( nLength );

	push	esi
	mov	ecx, edx
	call	?PrepareWrite2@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN40@Append
$LN58@Append:

; 810  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

	mov	eax, DWORD PTR $T6[ebp]
$LN40@Append:

; 409  : 		if( nOffset <= nOldLength )

	mov	ecx, DWORD PTR _nOffset$1$[ebp]
	mov	edx, DWORD PTR tv358[ebp]
	cmp	ecx, edx
	ja	SHORT $LN25@Append

; 410  : 		{
; 411  : 			pszSrc = pszBuffer+nOffset;

	lea	ebx, DWORD PTR [eax+ecx*2]
$LN25@Append:

; 412  : 			// No need to call CopyCharsOverlapped, since the destination is
; 413  : 			// beyond the end of the original buffer
; 414  : 		}
; 415  : 		CopyChars( pszBuffer+nOldLength, nLength, pszSrc, nLength );

	push	edi
	push	ebx
	lea	eax, DWORD PTR [eax+edx*2]
	push	edi
	push	eax
	call	?CopyChars@?$CSimpleStringT@_W$0A@@ATL@@SAXPA_WIPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::CopyChars

; 871  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	mov	eax, DWORD PTR _this$1$[ebp]

; 415  : 		CopyChars( pszBuffer+nOldLength, nLength, pszSrc, nLength );

	add	esp, 16					; 00000010H

; 871  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	mov	ecx, DWORD PTR [eax]
	cmp	esi, DWORD PTR [ecx-8]
	jg	SHORT $LN50@Append

; 873  : 
; 874  : 		GetData()->nDataLength = nLength;

	mov	DWORD PTR [ecx-12], esi

; 875  : 		m_pszData[nLength] = 0;

	xor	ecx, ecx
	mov	eax, DWORD PTR [eax]
	pop	edi
	mov	WORD PTR [eax+esi*2], cx
	pop	esi
	pop	ebx

; 429  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN50@Append:

; 872  : 			AtlThrow(E_INVALIDARG);

	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN59@Append:
	int	3
?Append@?$CSimpleStringT@_W$0A@@ATL@@QAEXABV12@@Z ENDP	; ATL::CSimpleStringT<wchar_t,0>::Append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
;	COMDAT ??Y?$CSimpleStringT@_W$0A@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_pszSrc$1$ = -8						; size = 4
tv357 = -4						; size = 4
_nOffset$1$ = 8						; size = 4
_strSrc$ = 8						; size = 4
??Y?$CSimpleStringT@_W$0A@@ATL@@QAEAAV01@ABV01@@Z PROC	; ATL::CSimpleStringT<wchar_t,0>::operator+=, COMDAT
; _this$ = ecx

; 320  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 519  : 		return( GetData()->nDataLength );

	mov	eax, DWORD PTR _strSrc$[ebp]

; 320  : 	{

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 519  : 		return( GetData()->nDataLength );

	mov	ecx, DWORD PTR [eax]

; 389  : 		UINT_PTR nOffset = pszSrc-GetString();

	mov	edx, ecx

; 519  : 		return( GetData()->nDataLength );

	mov	DWORD PTR _pszSrc$1$[ebp], ecx

; 389  : 		UINT_PTR nOffset = pszSrc-GetString();

	mov	eax, DWORD PTR [edi]
	sub	edx, eax

; 428  : 		Append( strSrc.GetString(), strSrc.GetLength() );

	mov	ebx, DWORD PTR [ecx-12]

; 389  : 		UINT_PTR nOffset = pszSrc-GetString();

	sar	edx, 1
	mov	DWORD PTR _nOffset$1$[ebp], edx

; 519  : 		return( GetData()->nDataLength );

	mov	esi, DWORD PTR [eax-12]
	mov	DWORD PTR tv357[ebp], esi

; 399  : 		ATLENSURE_THROW(nLength >=0, E_INVALIDARG);

	test	ebx, ebx
	js	SHORT $LN52@operator

; 750  : 		if( psz == NULL )

	test	ecx, ecx
	jne	SHORT $LN36@operator

; 751  : 		{
; 752  : 			return( 0 );

	xor	ebx, ebx
	jmp	SHORT $LN20@operator
$LN36@operator:

; 753  : 		}
; 754  : 		return( int( wcsnlen( psz, sizeInXChar ) ) );

	push	ebx
	push	ecx
	call	_wcsnlen
	add	esp, 8
	mov	ebx, eax
$LN20@operator:

; 405  : 		ATLENSURE_THROW(INT_MAX - nLength >= static_cast<int>(nOldLength), E_INVALIDARG);

	mov	ecx, 2147483647				; 7fffffffH
	sub	ecx, ebx
	cmp	ecx, esi
	jl	SHORT $LN52@operator

; 406  : 
; 407  : 		int nNewLength = nOldLength+nLength;

	add	esi, ebx

; 804  : 		if (nLength < 0)

	js	SHORT $LN52@operator

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [edi]

; 808  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false

	mov	ecx, 1

; 809  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

	mov	eax, DWORD PTR [edx-8]
	sub	ecx, DWORD PTR [edx-4]
	sub	eax, esi

; 810  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

	or	ecx, eax
	jge	SHORT $LN42@operator

; 811  : 		{
; 812  : 			PrepareWrite2( nLength );

	push	esi
	mov	ecx, edi
	call	?PrepareWrite2@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2
	mov	edx, DWORD PTR [edi]
$LN42@operator:

; 409  : 		if( nOffset <= nOldLength )

	mov	eax, DWORD PTR _nOffset$1$[ebp]
	mov	ecx, DWORD PTR tv357[ebp]
	cmp	eax, ecx

; 410  : 		{
; 411  : 			pszSrc = pszBuffer+nOffset;

	lea	eax, DWORD PTR [edx+eax*2]
	jbe	SHORT $LN27@operator

; 408  : 		PXSTR pszBuffer = GetBuffer( nNewLength );
; 409  : 		if( nOffset <= nOldLength )

	mov	eax, DWORD PTR _pszSrc$1$[ebp]
$LN27@operator:

; 412  : 			// No need to call CopyCharsOverlapped, since the destination is
; 413  : 			// beyond the end of the original buffer
; 414  : 		}
; 415  : 		CopyChars( pszBuffer+nOldLength, nLength, pszSrc, nLength );

	push	ebx
	push	eax
	lea	eax, DWORD PTR [edx+ecx*2]
	push	ebx
	push	eax
	call	?CopyChars@?$CSimpleStringT@_W$0A@@ATL@@SAXPA_WIPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::CopyChars

; 871  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	mov	eax, DWORD PTR [edi]

; 415  : 		CopyChars( pszBuffer+nOldLength, nLength, pszSrc, nLength );

	add	esp, 16					; 00000010H

; 871  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	cmp	esi, DWORD PTR [eax-8]
	jg	SHORT $LN52@operator

; 873  : 
; 874  : 		GetData()->nDataLength = nLength;

	mov	DWORD PTR [eax-12], esi

; 875  : 		m_pszData[nLength] = 0;

	xor	ecx, ecx
	mov	eax, DWORD PTR [edi]
	mov	WORD PTR [eax+esi*2], cx

; 321  : 		Append( strSrc );
; 322  : 
; 323  : 		return( *this );

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 324  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN52@operator:

; 872  : 			AtlThrow(E_INVALIDARG);

	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN62@operator:
	int	3
??Y?$CSimpleStringT@_W$0A@@ATL@@QAEAAV01@ABV01@@Z ENDP	; ATL::CSimpleStringT<wchar_t,0>::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
;	COMDAT ??Y?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEAAV01@ABV?$CSimpleStringT@_W$0A@@1@@Z
_TEXT	SEGMENT
_pszSrc$1$ = -8						; size = 4
tv357 = -4						; size = 4
_nOffset$1$ = 8						; size = 4
_str$ = 8						; size = 4
??Y?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEAAV01@ABV?$CSimpleStringT@_W$0A@@1@@Z PROC ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::operator+=, COMDAT
; _this$ = ecx

; 1365 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

	mov	eax, DWORD PTR _str$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 1365 : 	{

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 519  : 		return( GetData()->nDataLength );

	mov	ecx, DWORD PTR [eax]

; 389  : 		UINT_PTR nOffset = pszSrc-GetString();

	mov	edx, ecx

; 519  : 		return( GetData()->nDataLength );

	mov	DWORD PTR _pszSrc$1$[ebp], ecx

; 389  : 		UINT_PTR nOffset = pszSrc-GetString();

	mov	eax, DWORD PTR [edi]
	sub	edx, eax

; 428  : 		Append( strSrc.GetString(), strSrc.GetLength() );

	mov	ebx, DWORD PTR [ecx-12]

; 389  : 		UINT_PTR nOffset = pszSrc-GetString();

	sar	edx, 1
	mov	DWORD PTR _nOffset$1$[ebp], edx

; 519  : 		return( GetData()->nDataLength );

	mov	esi, DWORD PTR [eax-12]
	mov	DWORD PTR tv357[ebp], esi

; 399  : 		ATLENSURE_THROW(nLength >=0, E_INVALIDARG);

	test	ebx, ebx
	js	SHORT $LN54@operator

; 750  : 		if( psz == NULL )

	test	ecx, ecx
	jne	SHORT $LN38@operator

; 751  : 		{
; 752  : 			return( 0 );

	xor	ebx, ebx
	jmp	SHORT $LN22@operator
$LN38@operator:

; 753  : 		}
; 754  : 		return( int( wcsnlen( psz, sizeInXChar ) ) );

	push	ebx
	push	ecx
	call	_wcsnlen
	add	esp, 8
	mov	ebx, eax
$LN22@operator:

; 405  : 		ATLENSURE_THROW(INT_MAX - nLength >= static_cast<int>(nOldLength), E_INVALIDARG);

	mov	ecx, 2147483647				; 7fffffffH
	sub	ecx, ebx
	cmp	ecx, esi
	jl	SHORT $LN54@operator

; 406  : 
; 407  : 		int nNewLength = nOldLength+nLength;

	add	esi, ebx

; 804  : 		if (nLength < 0)

	js	SHORT $LN54@operator

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [edi]

; 808  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false

	mov	ecx, 1

; 809  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

	mov	eax, DWORD PTR [edx-8]
	sub	ecx, DWORD PTR [edx-4]
	sub	eax, esi

; 810  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

	or	ecx, eax
	jge	SHORT $LN44@operator

; 811  : 		{
; 812  : 			PrepareWrite2( nLength );

	push	esi
	mov	ecx, edi
	call	?PrepareWrite2@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::PrepareWrite2
	mov	edx, DWORD PTR [edi]
$LN44@operator:

; 409  : 		if( nOffset <= nOldLength )

	mov	eax, DWORD PTR _nOffset$1$[ebp]
	mov	ecx, DWORD PTR tv357[ebp]
	cmp	eax, ecx

; 410  : 		{
; 411  : 			pszSrc = pszBuffer+nOffset;

	lea	eax, DWORD PTR [edx+eax*2]
	jbe	SHORT $LN29@operator

; 408  : 		PXSTR pszBuffer = GetBuffer( nNewLength );
; 409  : 		if( nOffset <= nOldLength )

	mov	eax, DWORD PTR _pszSrc$1$[ebp]
$LN29@operator:

; 412  : 			// No need to call CopyCharsOverlapped, since the destination is
; 413  : 			// beyond the end of the original buffer
; 414  : 		}
; 415  : 		CopyChars( pszBuffer+nOldLength, nLength, pszSrc, nLength );

	push	ebx
	push	eax
	lea	eax, DWORD PTR [edx+ecx*2]
	push	ebx
	push	eax
	call	?CopyChars@?$CSimpleStringT@_W$0A@@ATL@@SAXPA_WIPB_WH@Z ; ATL::CSimpleStringT<wchar_t,0>::CopyChars

; 871  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	mov	eax, DWORD PTR [edi]

; 415  : 		CopyChars( pszBuffer+nOldLength, nLength, pszSrc, nLength );

	add	esp, 16					; 00000010H

; 871  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	cmp	esi, DWORD PTR [eax-8]
	jg	SHORT $LN54@operator

; 873  : 
; 874  : 		GetData()->nDataLength = nLength;

	mov	DWORD PTR [eax-12], esi

; 875  : 		m_pszData[nLength] = 0;

	xor	ecx, ecx
	mov	eax, DWORD PTR [edi]
	mov	WORD PTR [eax+esi*2], cx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 1368 : 		return( *this );

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 1369 : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN54@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 872  : 			AtlThrow(E_INVALIDARG);

	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN65@operator:
	int	3
??Y?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEAAV01@ABV?$CSimpleStringT@_W$0A@@1@@Z ENDP ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
;	COMDAT ?StringLengthN@?$CSimpleStringT@_W$0A@@ATL@@SAHPB_WI@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
_sizeInXChar$ = 12					; size = 4
?StringLengthN@?$CSimpleStringT@_W$0A@@ATL@@SAHPB_WI@Z PROC ; ATL::CSimpleStringT<wchar_t,0>::StringLengthN, COMDAT

; 749  : 	{

	push	ebp
	mov	ebp, esp

; 750  : 		if( psz == NULL )

	mov	eax, DWORD PTR _psz$[ebp]
	test	eax, eax
	jne	SHORT $LN2@StringLeng

; 755  : 	}

	pop	ebp
	ret	0
$LN2@StringLeng:

; 751  : 		{
; 752  : 			return( 0 );
; 753  : 		}
; 754  : 		return( int( wcsnlen( psz, sizeInXChar ) ) );

	mov	DWORD PTR _psz$[ebp], eax

; 755  : 	}

	pop	ebp

; 751  : 		{
; 752  : 			return( 0 );
; 753  : 		}
; 754  : 		return( int( wcsnlen( psz, sizeInXChar ) ) );

	jmp	_wcsnlen
?StringLengthN@?$CSimpleStringT@_W$0A@@ATL@@SAHPB_WI@Z ENDP ; ATL::CSimpleStringT<wchar_t,0>::StringLengthN
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
;	COMDAT ?ReleaseBuffer@?$CSimpleStringT@_W$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT
_nNewLength$ = 8					; size = 4
?ReleaseBuffer@?$CSimpleStringT@_W$0A@@ATL@@QAEXH@Z PROC ; ATL::CSimpleStringT<wchar_t,0>::ReleaseBuffer, COMDAT
; _this$ = ecx

; 557  : 	{

	push	ebp
	mov	ebp, esp

; 558  : 		if( nNewLength == -1 )

	mov	edx, DWORD PTR _nNewLength$[ebp]
	push	esi
	mov	esi, ecx
	cmp	edx, -1
	jne	SHORT $LN6@ReleaseBuf

; 559  : 		{
; 560  : 			int nAlloc = GetData()->nAllocLength;

	mov	eax, DWORD PTR [esi]

; 750  : 		if( psz == NULL )

	test	eax, eax
	jne	SHORT $LN7@ReleaseBuf

; 751  : 		{
; 752  : 			return( 0 );

	xor	edx, edx
	jmp	SHORT $LN18@ReleaseBuf
$LN7@ReleaseBuf:

; 753  : 		}
; 754  : 		return( int( wcsnlen( psz, sizeInXChar ) ) );

	push	DWORD PTR [eax-8]
	push	eax
	call	_wcsnlen
	add	esp, 8
	mov	edx, eax
$LN6@ReleaseBuf:

; 871  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	test	edx, edx
	js	SHORT $LN11@ReleaseBuf
$LN18@ReleaseBuf:
	mov	eax, DWORD PTR [esi]
	cmp	edx, DWORD PTR [eax-8]
	jg	SHORT $LN11@ReleaseBuf

; 873  : 
; 874  : 		GetData()->nDataLength = nLength;

	mov	DWORD PTR [eax-12], edx

; 875  : 		m_pszData[nLength] = 0;

	xor	ecx, ecx
	mov	eax, DWORD PTR [esi]
	pop	esi
	mov	WORD PTR [eax+edx*2], cx

; 561  : 			nNewLength = StringLengthN( m_pszData, nAlloc);
; 562  : 		}
; 563  : 		SetLength( nNewLength );
; 564  : 	}

	pop	ebp
	ret	4
$LN11@ReleaseBuf:

; 872  : 			AtlThrow(E_INVALIDARG);

	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN19@ReleaseBuf:
	int	3
?ReleaseBuffer@?$CSimpleStringT@_W$0A@@ATL@@QAEXH@Z ENDP ; ATL::CSimpleStringT<wchar_t,0>::ReleaseBuffer
_TEXT	ENDS
END
