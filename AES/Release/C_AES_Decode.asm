; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28106.4 

	TITLE	i:\projets\aes\aes\aes\c_aes_decode.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_1FO@GBKEFGLF@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAE?$AAn?$AAh?$AAa?$AAn@ ; `string'
EXTRN	__imp__CryptReleaseContext@8:PROC
EXTRN	__imp__CryptDestroyKey@4:PROC
EXTRN	__imp__CryptDestroyHash@4:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__CryptDecrypt@24:PROC
EXTRN	__imp__CryptDeriveKey@20:PROC
EXTRN	__imp__lstrlenW@4:PROC
EXTRN	__imp__CryptHashData@16:PROC
EXTRN	__imp__CryptCreateHash@20:PROC
EXTRN	_free:PROC
EXTRN	__imp__CryptImportKey@24:PROC
EXTRN	_malloc:PROC
EXTRN	__imp__ReadFile@20:PROC
EXTRN	__imp__CreateFileW@28:PROC
EXTRN	__imp__CryptAcquireContextW@20:PROC
;	COMDAT ??_C@_1FO@GBKEFGLF@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAE?$AAn?$AAh?$AAa?$AAn@
CONST	SEGMENT
??_C@_1FO@GBKEFGLF@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAE?$AAn?$AAh?$AAa?$AAn@ DB 'M'
	DB	00H, 'i', 00H, 'c', 00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H
	DB	'f', 00H, 't', 00H, ' ', 00H, 'E', 00H, 'n', 00H, 'h', 00H, 'a'
	DB	00H, 'n', 00H, 'c', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'C', 00H
	DB	'r', 00H, 'y', 00H, 'p', 00H, 't', 00H, 'o', 00H, 'g', 00H, 'r'
	DB	00H, 'a', 00H, 'p', 00H, 'h', 00H, 'i', 00H, 'c', 00H, ' ', 00H
	DB	'P', 00H, 'r', 00H, 'o', 00H, 'v', 00H, 'i', 00H, 'd', 00H, 'e'
	DB	00H, 'r', 00H, ' ', 00H, 'v', 00H, '1', 00H, '.', 00H, '0', 00H
	DB	00H, 00H					; `string'
PUBLIC	??0C_AES_Decode@@QAE@XZ				; C_AES_Decode::C_AES_Decode
PUBLIC	??1C_AES_Decode@@QAE@XZ				; C_AES_Decode::~C_AES_Decode
PUBLIC	?MyDecryptFile@C_AES_Decode@@QAE_NPA_W00@Z	; C_AES_Decode::MyDecryptFile
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1C_AES_Decode@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0C_AES_Decode@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0C_AES_Decode@@QAE@XZ$0
__ehfuncinfo$??0C_AES_Decode@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0C_AES_Decode@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp
;	COMDAT ?MyDecryptFile@C_AES_Decode@@QAE_NPA_W00@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -32					; size = 4
_hSourceFile$1$ = -28					; size = 4
_pszDestinationFile$GSCopy$1$ = -24			; size = 4
tv714 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -20						; size = 4
_hDestinationFile$1$ = -20				; size = 4
_fReturn$1$ = -13					; size = 1
_pszPassword$GSCopy$1$ = -12				; size = 4
_dwKeyBlobLen$8 = -12					; size = 4
_dwCount$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pszSourceFile$ = 8					; size = 4
_pszDestinationFile$ = 12				; size = 4
_pszPassword$ = 16					; size = 4
?MyDecryptFile@C_AES_Decode@@QAE_NPA_W00@Z PROC		; C_AES_Decode::MyDecryptFile, COMDAT
; _this$ = ecx

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _pszSourceFile$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _pszPassword$[ebp]
	push	esi
	push	edi

; 35   : 	//---------------------------------------------------------------
; 36   : 	// Declare and initialize local variables.
; 37   : 	bool fReturn = false;
; 38   : 	HANDLE hSourceFile = INVALID_HANDLE_VALUE;
; 39   : 	HANDLE hDestinationFile = INVALID_HANDLE_VALUE;
; 40   : 	DWORD dwCount;
; 41   : 	PBYTE pbBuffer = NULL;
; 42   : 	DWORD dwBlockLen;
; 43   : 	DWORD dwBufferLen;
; 44   : 
; 45   : 	hSourceFile = CreateFile(pszSourceFile, FILE_READ_DATA, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	push	0
	push	128					; 00000080H
	push	3
	push	0
	push	1
	mov	edi, ecx
	mov	DWORD PTR _pszPassword$GSCopy$1$[ebp], ebx
	mov	ecx, DWORD PTR _pszDestinationFile$[ebp]
	or	esi, -1
	push	1
	push	eax
	mov	DWORD PTR _this$GSCopy$1$[ebp], edi
	mov	DWORD PTR _pszDestinationFile$GSCopy$1$[ebp], ecx
	mov	BYTE PTR _fReturn$1$[ebp], 0
	call	DWORD PTR __imp__CreateFileW@28
	mov	ebx, eax
	mov	DWORD PTR _hSourceFile$1$[ebp], ebx

; 46   : 
; 47   : 	if (INVALID_HANDLE_VALUE == hSourceFile)

	cmp	ebx, esi
	jne	SHORT $LN5@MyDecryptF

; 48   : 	{
; 49   : 		BOOL status;
; 50   : 		status = Mess.LoadString(IDS_STRING132);

	lea	ecx, DWORD PTR [edi+4]
	push	132					; 00000084H
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T6[ebp], ecx

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [ecx-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN25@MyDecryptF

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [ecx-12]
	lea	ecx, DWORD PTR [edi+4]
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR $T6[ebp], eax
$LN25@MyDecryptF:
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp

; 51   : 		pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());

	call	DWORD PTR __imp__GetLastError@0
	mov	ecx, DWORD PTR [edi]
	push	eax
	push	DWORD PTR $T6[ebp]
	call	?MyHandleError@C_Error_Message@@QAEXPA_WH@Z ; C_Error_Message::MyHandleError

; 118  : 	{
; 119  : 		CloseHandle(hSourceFile);

	push	ebx
	mov	ebx, DWORD PTR __imp__CloseHandle@4
	call	ebx
	jmp	$LN15@MyDecryptF
$LN5@MyDecryptF:

; 52   : 		goto Exit_MyDecryptFile;
; 53   : 	}
; 54   : 
; 55   : 	hDestinationFile = CreateFile(pszDestinationFile, FILE_WRITE_DATA, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	push	0
	push	128					; 00000080H
	push	2
	push	0
	push	1
	push	2
	push	DWORD PTR _pszDestinationFile$GSCopy$1$[ebp]
	call	DWORD PTR __imp__CreateFileW@28
	mov	esi, eax
	mov	DWORD PTR _hDestinationFile$1$[ebp], esi

; 56   : 	
; 57   : 	if (INVALID_HANDLE_VALUE == hDestinationFile)

	cmp	esi, -1
	jne	SHORT $LN7@MyDecryptF

; 58   : 	{
; 59   : 		BOOL status;
; 60   : 		status = Mess.LoadString(IDS_STRING134);

	lea	ecx, DWORD PTR [edi+4]
	push	134					; 00000086H
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T7[ebp], eax

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [eax-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN32@MyDecryptF

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [eax-12]
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR $T7[ebp], eax
$LN32@MyDecryptF:
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp

; 61   : 		pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());

	call	DWORD PTR __imp__GetLastError@0
	mov	ecx, DWORD PTR [edi]
	push	eax
	push	DWORD PTR $T7[ebp]
	call	?MyHandleError@C_Error_Message@@QAEXPA_WH@Z ; C_Error_Message::MyHandleError

; 62   : 		goto Exit_MyDecryptFile;

	jmp	$LN14@MyDecryptF
$LN7@MyDecryptF:

; 63   : 	}
; 64   : 
; 65   : 	if (!pszPassword || !pszPassword[0])

	mov	eax, DWORD PTR _pszPassword$GSCopy$1$[ebp]
	test	eax, eax
	je	SHORT $LN11@MyDecryptF
	cmp	WORD PTR [eax], 0
	je	SHORT $LN11@MyDecryptF

; 81   : 		}
; 82   : 	}
; 83   : 	else
; 84   : 	{
; 85   : 			// here
; 86   : 		CryptCreateHash(hCryptProv, _Hash, 0, 0, &hHash);

	lea	esi, DWORD PTR [edi+16]
	push	esi
	push	0
	push	0
	push	32772					; 00008004H
	push	DWORD PTR [edi+8]
	call	DWORD PTR __imp__CryptCreateHash@20

; 87   : 		CryptHashData(hHash, (BYTE *)pszPassword, lstrlen(pszPassword), 0);

	mov	ebx, DWORD PTR _pszPassword$GSCopy$1$[ebp]
	push	0
	push	ebx
	call	DWORD PTR __imp__lstrlenW@4
	push	eax
	push	ebx
	push	DWORD PTR [esi]
	call	DWORD PTR __imp__CryptHashData@16

; 88   : 		CryptDeriveKey(hCryptProv, ENCRYPT_ALGORITHM, hHash, KEYLENGTH, &hKey);

	lea	eax, DWORD PTR [edi+12]
	push	eax
	push	4
	push	DWORD PTR [esi]
	mov	DWORD PTR tv714[ebp], eax
	push	26625					; 00006801H
	push	DWORD PTR [edi+8]
	call	DWORD PTR __imp__CryptDeriveKey@20
	jmp	SHORT $LN12@MyDecryptF
$LN11@MyDecryptF:

; 66   : 	{
; 67   : 
; 68   : 		DWORD dwKeyBlobLen;
; 69   : 		PBYTE pbKeyBlob = NULL;
; 70   : 		BOOL Status = ReadFile(hSourceFile, &dwKeyBlobLen, sizeof(DWORD), &dwCount, NULL);

	push	0
	lea	eax, DWORD PTR _dwCount$[ebp]
	push	eax
	push	4
	lea	eax, DWORD PTR _dwKeyBlobLen$8[ebp]
	push	eax
	push	ebx
	call	DWORD PTR __imp__ReadFile@20

; 71   : 		
; 72   : 		(pbKeyBlob = (PBYTE)malloc(dwKeyBlobLen));

	push	DWORD PTR _dwKeyBlobLen$8[ebp]
	call	_malloc
	add	esp, 4
	mov	esi, eax

; 73   : 	
; 74   : 		Status = ReadFile(hSourceFile, pbKeyBlob, dwKeyBlobLen, &dwCount, NULL);

	lea	eax, DWORD PTR _dwCount$[ebp]
	push	0
	push	eax
	push	DWORD PTR _dwKeyBlobLen$8[ebp]
	push	esi
	push	ebx
	call	DWORD PTR __imp__ReadFile@20

; 75   : 	
; 76   : 		CryptImportKey(hCryptProv, pbKeyBlob, dwKeyBlobLen, 0, 0, &hKey);

	lea	eax, DWORD PTR [edi+12]
	push	eax
	push	0
	push	0
	push	DWORD PTR _dwKeyBlobLen$8[ebp]
	mov	DWORD PTR tv714[ebp], eax
	push	esi
	push	DWORD PTR [edi+8]
	call	DWORD PTR __imp__CryptImportKey@24

; 77   : 
; 78   : 		if (pbKeyBlob)

	test	esi, esi
	je	SHORT $LN12@MyDecryptF

; 79   : 		{
; 80   : 			free(pbKeyBlob);

	push	esi
	call	_free
	add	esp, 4
$LN12@MyDecryptF:

; 89   : 	
; 90   : 	}
; 91   : 	dwBlockLen = 1000 - 1000 % ENCRYPT_BLOCK_SIZE;
; 92   : 	dwBufferLen = dwBlockLen;
; 93   : 	pbBuffer = (PBYTE)malloc(dwBufferLen);

	push	1000					; 000003e8H
	call	_malloc
	mov	edi, DWORD PTR _hSourceFile$1$[ebp]
	add	esp, 4
	mov	esi, eax

; 94   : 
; 95   : 	bool fEOF = false;

	xor	bl, bl
$LL4@MyDecryptF:

; 96   : 	do
; 97   : 	{
; 98   : 		BOOL Status =ReadFile(hSourceFile, pbBuffer, dwBlockLen, &dwCount, NULL);

	push	0
	lea	eax, DWORD PTR _dwCount$[ebp]
	push	eax
	push	1000					; 000003e8H
	push	esi
	push	edi
	call	DWORD PTR __imp__ReadFile@20

; 99   : 	
; 100  : 		if (dwCount < dwBlockLen)

	cmp	DWORD PTR _dwCount$[ebp], 1000		; 000003e8H
	mov	eax, 1
	movzx	ebx, bl
	cmovb	ebx, eax

; 101  : 		{
; 102  : 			fEOF = TRUE;
; 103  : 		}
; 104  : 		CryptDecrypt(hKey, 0, fEOF, 0, pbBuffer, &dwCount);

	lea	eax, DWORD PTR _dwCount$[ebp]
	push	eax
	push	esi
	push	0
	movzx	eax, bl
	push	eax
	mov	eax, DWORD PTR tv714[ebp]
	push	0
	push	DWORD PTR [eax]
	call	DWORD PTR __imp__CryptDecrypt@24

; 105  : 	
; 106  : 		WriteFile(hDestinationFile,pbBuffer,dwCount,&dwCount,NULL);

	push	0
	lea	eax, DWORD PTR _dwCount$[ebp]
	push	eax
	push	DWORD PTR _dwCount$[ebp]
	push	esi
	push	DWORD PTR _hDestinationFile$1$[ebp]
	call	DWORD PTR __imp__WriteFile@20

; 107  : 	
; 108  : 	} while (!fEOF);

	test	bl, bl
	je	SHORT $LL4@MyDecryptF

; 109  : 	fReturn = true;

	mov	BYTE PTR _fReturn$1$[ebp], 1
$Exit_MyDecryptFile$68:

; 110  : 
; 111  : Exit_MyDecryptFile:
; 112  : 
; 113  : 	if (pbBuffer)

	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	test	esi, esi
	je	SHORT $LN65@MyDecryptF

; 114  : 	{
; 115  : 		free(pbBuffer);

	push	esi
	call	_free
	add	esp, 4
$LN65@MyDecryptF:

; 116  : 	}
; 117  : 	if (hSourceFile)

	mov	esi, DWORD PTR _hDestinationFile$1$[ebp]
	mov	ebx, DWORD PTR _hSourceFile$1$[ebp]
$LN14@MyDecryptF:
	test	ebx, ebx
	je	SHORT $LN66@MyDecryptF

; 118  : 	{
; 119  : 		CloseHandle(hSourceFile);

	push	ebx
	mov	ebx, DWORD PTR __imp__CloseHandle@4
	call	ebx
	jmp	SHORT $LN15@MyDecryptF
$LN66@MyDecryptF:

; 116  : 	}
; 117  : 	if (hSourceFile)

	mov	ebx, DWORD PTR __imp__CloseHandle@4
$LN15@MyDecryptF:

; 120  : 	}
; 121  : 	if (hDestinationFile)

	test	esi, esi
	je	SHORT $LN16@MyDecryptF

; 122  : 	{
; 123  : 		CloseHandle(hDestinationFile);

	push	esi
	call	ebx
$LN16@MyDecryptF:

; 124  : 	}
; 125  : 	if (hHash)

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $LN17@MyDecryptF

; 126  : 	{
; 127  : 		if (!(CryptDestroyHash(hHash)))

	push	eax
	call	DWORD PTR __imp__CryptDestroyHash@4
	test	eax, eax
	jne	SHORT $LN18@MyDecryptF

; 128  : 		{
; 129  : 			BOOL status;
; 130  : 			status = Mess.LoadString(IDS_STRING148);

	push	148					; 00000094H
	lea	ecx, DWORD PTR [edi+4]
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	esi, DWORD PTR [edi+4]

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [esi-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN39@MyDecryptF

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [esi-12]
	lea	ecx, DWORD PTR [edi+4]
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	esi, DWORD PTR [edi+4]
$LN39@MyDecryptF:
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp

; 131  : 			pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());

	call	DWORD PTR __imp__GetLastError@0
	mov	ecx, DWORD PTR [edi]
	push	eax
	push	esi
	call	?MyHandleError@C_Error_Message@@QAEXPA_WH@Z ; C_Error_Message::MyHandleError
$LN18@MyDecryptF:

; 132  : 		}
; 133  : 		hHash = NULL;

	mov	DWORD PTR [edi+16], 0
$LN17@MyDecryptF:

; 134  : 	}
; 135  : 	if (hKey)

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN20@MyDecryptF

; 136  : 	{
; 137  : 		if (!(CryptDestroyKey(hKey)))

	push	eax
	call	DWORD PTR __imp__CryptDestroyKey@4
	test	eax, eax
	jne	SHORT $LN20@MyDecryptF

; 138  : 		{
; 139  : 			BOOL status = Mess.LoadString(IDS_STRING149);

	push	149					; 00000095H
	lea	ecx, DWORD PTR [edi+4]
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	esi, DWORD PTR [edi+4]

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [esi-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN46@MyDecryptF

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [esi-12]
	lea	ecx, DWORD PTR [edi+4]
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	esi, DWORD PTR [edi+4]
$LN46@MyDecryptF:
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp

; 140  : 			pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());

	call	DWORD PTR __imp__GetLastError@0
	mov	ecx, DWORD PTR [edi]
	push	eax
	push	esi
	call	?MyHandleError@C_Error_Message@@QAEXPA_WH@Z ; C_Error_Message::MyHandleError
$LN20@MyDecryptF:

; 141  : 		}
; 142  : 	}
; 143  : 	if (hCryptProv)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN64@MyDecryptF

; 144  : 	{
; 145  : 		if (!(CryptReleaseContext(hCryptProv, 0)))

	push	0
	push	eax
	call	DWORD PTR __imp__CryptReleaseContext@8
	test	eax, eax
	jne	SHORT $LN64@MyDecryptF

; 146  : 		{
; 147  : 			BOOL status = Mess.LoadString(IDS_STRING150);

	push	150					; 00000096H
	lea	ecx, DWORD PTR [edi+4]
	call	?LoadStringW@?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::LoadStringW
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	ebx, DWORD PTR [edi+4]

; 73   : 		return( nRefs > 1 );

	cmp	DWORD PTR [ebx-4], 1

; 499  : 		if( pData->IsShared() )

	jle	SHORT $LN53@MyDecryptF

; 500  : 		{
; 501  : 			Fork( pData->nDataLength );

	push	DWORD PTR [ebx-12]
	lea	ecx, DWORD PTR [edi+4]
	call	?Fork@?$CSimpleStringT@_W$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<wchar_t,0>::Fork
	mov	ebx, DWORD PTR [edi+4]
$LN53@MyDecryptF:
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp

; 148  : 			pt_Erreur->MyHandleError(Mess.GetBuffer(), GetLastError());

	call	DWORD PTR __imp__GetLastError@0
	mov	ecx, DWORD PTR [edi]
	push	eax
	push	ebx
	call	?MyHandleError@C_Error_Message@@QAEXPA_WH@Z ; C_Error_Message::MyHandleError
$LN64@MyDecryptF:

; 149  : 		}
; 150  : 	}
; 151  : 	return fReturn;
; 152  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	al, BYTE PTR _fReturn$1$[ebp]
	xor	ecx, ebp
	pop	edi
	pop	esi
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MyDecryptFile@C_AES_Decode@@QAE_NPA_W00@Z ENDP		; C_AES_Decode::MyDecryptFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp
;	COMDAT ??1C_AES_Decode@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1C_AES_Decode@@QAE@XZ PROC				; C_AES_Decode::~C_AES_Decode, COMDAT
; _this$ = ecx

; 18   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1C_AES_Decode@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx

; 19   : 	delete pt_Erreur;

	mov	edi, DWORD PTR [ebx]
	or	esi, -1
	test	edi, edi
	je	SHORT $LN6@C_AES_Deco
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [edi]

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, esi

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], eax
	dec	eax
	test	eax, eax
	jg	SHORT $LN18@C_AES_Deco

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN18@C_AES_Deco:
	push	4
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@C_AES_Deco:

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	edx, DWORD PTR [ebx+4]
	sub	edx, 16					; 00000010H

; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	lock	 xadd	 DWORD PTR [edx+12], esi
	dec	esi
	test	esi, esi
	jg	SHORT $LN27@C_AES_Deco

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN27@C_AES_Deco:
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp

; 21   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1C_AES_Decode@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1C_AES_Decode@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1C_AES_Decode@@QAE@XZ ENDP				; C_AES_Decode::~C_AES_Decode
; Function compile flags: /Ogtp
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp
;	COMDAT ??0C_AES_Decode@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0C_AES_Decode@@QAE@XZ PROC				; C_AES_Decode::C_AES_Decode, COMDAT
; _this$ = ecx

; 10   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0C_AES_Decode@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	$LN52@C_AES_Deco

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [esi+4], eax
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp

; 10   : {

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 11   : 	pt_Erreur = new C_Error_Message;

	push	4
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	SHORT $LN3@C_AES_Deco
	mov	DWORD PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\afxstr.h

; 52   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\cstringt.h

; 1006 : 		CThisSimpleString( StringTraits::GetDefaultManager() )

	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	test	ecx, ecx
	je	SHORT $LN53@C_AES_Deco

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 59   : 		return (this+1);

	add	eax, 16					; 00000010H

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	DWORD PTR [edi], eax
; File I:\Projets\AES\AES\AES\C_AES_Decode.cpp

; 11   : 	pt_Erreur = new C_Error_Message;

	jmp	SHORT $LN4@C_AES_Deco
$LN3@C_AES_Deco:
	xor	edi, edi
$LN4@C_AES_Deco:

; 12   : 	CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0);

	push	0
	push	1
	push	OFFSET ??_C@_1FO@GBKEFGLF@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAE?$AAn?$AAh?$AAa?$AAn@
	push	0
	lea	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi], edi
	push	eax
	call	DWORD PTR __imp__CryptAcquireContextW@20

; 14   : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@C_AES_Deco:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.23.28105\atlmfc\include\atlsimpstr.h

; 205  : 		ATLENSURE( pStringMgr != NULL );

	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN53@C_AES_Deco:
	push	-2147467259				; 80004005H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN50@C_AES_Deco:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0C_AES_Decode@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$CStringT@_WV?$StrTraitMFC@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::~CStringT<wchar_t,StrTraitMFC<wchar_t,ATL::ChTraitsCRT<wchar_t> > >
__ehhandler$??0C_AES_Decode@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0C_AES_Decode@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0C_AES_Decode@@QAE@XZ ENDP				; C_AES_Decode::C_AES_Decode
END
